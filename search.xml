<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[折腾个人博客]]></title>
    <url>%2Fweb%2Fblog_changelog%2F</url>
    <content type="text"><![CDATA[说明这只是个一文不名的独立博客，但折腾它是博主的一种乐趣（消遣）。前文《搭建个人博客》只是简单说明了建站过程和定制点。本文《折腾个人博客》作为本博客今后的「变更日志」；也会回溯本博客的演变过程，简述具体做法及其考量；顺便展开讲讲前文中提及的「定制点」（可折腾的东西）。变更日志折腾日志2017.01 ~ 07修改 PV 数的显示方式由准确数，改为模糊数：1024 显示 1.0 k +改用 Disqus 评论系统由于 多说 关停服务，将评论数据全部导出后，修正内容、转换格式后，导入至 Disqus网站内容汉化清理、简化 所有文章所有夹英夹中的博客主题文案和文章内容（假洋鬼子的文风并不好…）加速 网站访问停用 Google Analytics，只用 百度统计停用 Google Fonts，改用 css.net 的字体资源使用 Hexo Plugin hexo-all-minifier压缩 页面及其引用资源的占用的存储空间大小使用 BootCDN 的 *.min.js *.min.css 资源，替换所有相关开源包的 *.js *.css相关资源传输耗时从 100 ms+ 下降到 100 ms-点击 才去加载 Disqus 的所有相关资源简化 404 页面简化 显示的文本去掉 错误链接重定向去掉 错误链接的收集显示效果添加 每篇文章的字数统计，及其 显示添加 CC 3.0 的署名协议声明到每篇文章的末尾添加 社交网络的链接到边栏提高 每页显示文章数量上限简化 显示文章的发布日志和更新日志只显示一个日期优先显示文章的更新日期如无显示文章的发布日期简化 边栏「热榜」模块的显示元素添加 边栏「热榜」模块的动画效果去掉 每篇文章下的百度分享按钮开启 Hexo Theme NexT 的博客背景 Canvas-nest 动效PC 浏览器的效果不错，但移动端的效果太显眼，影响页面浏览，遂关优化 用于博客文章的 PV 统计的 LeanCloud 调用代码添加 《旧博客索引》（作为博客的第一篇文章）添加 博客变更记录（本文）2015.01 ~ 2016.12很多折腾都记不清了，写个大概。使用 Hexo 静态博客生成器 制作 独立博客通过网上常见的教程学会尝试后，选用 Hexo Theme：Jacman根据当时的审美以及其组件的完备性作出选择Fork Jacman 后，看源码，修改博客的渲染效果顶栏、边栏、底栏、边距、配色、字体、Logo……文章显示更新日期、PV 量等……自定义 Jack 博客主题组件热榜（PV Top N）PV 文章阅读数（文章和主页文章流的显示）UV 独立访客统计（在边栏）添加 一言：随机显示动漫名台词（在底栏）添加 博客秀、GitHub 秀、豆瓣秀（在边栏）PV 阅读数统计根据网上教程，通过 LeanCloud 的 API 实现修改统计策略：本地的测试环境下，不会增加 PV 计数增加 黑名单、白名单：文章 URL、域名是否增加计数？是否显示计数？热榜（PV Top N）根据统计数据，在边栏显示 Top N 的排名404 页面处理在 404 页面下，通过 js 脚本控制，自动发布评论，记录错误的 URL 链接因为一些文章的路径修改后，外链引用出现错误跳转到 404 页面时，会自动更正链接，跳转到正确的页面去根据错误 URL 链接的统计，在 404 页面补充跳转规则，命中规则后，自动重定向到正确的 URL 上评论启用 多说 的评论系统添加 Disqus，同时使用两个评论系统动态加载 Disqus：点击后加载添加 js 脚本片段，让访客自动为文章点赞（后来删掉了）添加 显示评论人的 IP 和 UA 信息定制化 评论模块的 CSS 显示效果打赏添加 打赏模块（在边栏底部、每篇文章的底部）添加 支付宝 网页版打赏添加 PalPay 网页版打赏添加 支付宝、微信 二维码打赏定制 打赏文案 和 动效自动化脚本（Windows 批处理脚本）可将 Evernote 中的笔记 导出为 HTML 格式的博客文章。可将 Evernote 中的笔记 导出为 MARKDOWN 格式的博客文章。可将 Evernote 笔记中的图片 自动导出并上传到图床，将文章中图片的本地链接替换为图床中的链接。集中处理 图片：压缩、自动上传、删除、修改（七牛云）。可一键 清理、重新生成网页，然后打开浏览器，显示网站主页。可一键 自动上传将网页部署到多个 GitHub Page 和 Gitcafe Page 等多个服务。个人域名使用个人域名：icehe.me补充备用域名：icehe.gitcafe.io同时使用两个 Page 服务 icehe.me（指向 icehe.github.io） 和 icehe.gitcafe.io分流加速：使用 DNSPod 进行配置国外 IP 访问 icehe.github.io国内 IP 访问 icehe.gitcafe.io博客边栏显示主站和备用站分别给两个域名都添加了 Google Analytics、Google Webmaster、百度统计和百度站长工具由于 Gitcafe 被 Coding.net 收购，放弃了 icehe.gitcafe.io 的使用。自动化 导入个人时间管理日志自动导出 自己在 Evernote 上做的 时间管理日志修改内容以适应 Hexo 的文章要求自动导入 成为 Hexo 文章，并部署到网站上后来改用更便捷的 App 进行管理时间，不再更新博客上的时间管理日志改用 macOS 平台，重制所有相关脚本由 批处理脚本 改用 Shell、Python 和 AppleScript 等改用 NexT 博客主题fork 该项目后，重新根据 Jacman，迁移个人定制的功能例如「热榜 PV Top N」调整 CSS：边距、动效、字体、字号、配色调整 swig，定制化 首页的文章流的信息布局简化 分类去掉 标签 的显示FontAwesome 等图标字体变得常用过程中对博客内容做过无数次重构例如「关于」页面（即现在的「简历」）、「导航」页面Markdown 格式的文章中，为了提升内容的展示效果，直接混用了 HTML 标签……博客类型静态博客 VS 动态博客更简单的方式选择「去折腾」自己搭建个人博客真的有必要么？可能写写私人日记，跟好友聊聊天就足够了，连博客也没必要开。如果要开，也可以选择已有的平台：cnblogs 博客园、CSDN、SegmentFault、简书、知乎专栏 ……优缺点：「可发现性」更强，节省了「被发现」的成本。UGC（用户生产内容）平台对其内容，天生有自己的一套内容发现机制，如「发现」、「分类」、「最新文章」等。当然少不了推荐机制，只要内容做得足够好，平台也会主动来扩大你的内容的影响力，如「最热文章」、「推荐」等。不用特意做 SEO（优化搜索引擎的收录效果）。一个好平台会帮你做好相关的优化工作；如果平台的内容足够好，就算它的 SEO 优化做得不够，搜索引擎会主动适应它例如「知乎」就不算是 SEO 方面足够友好的站点，但是优秀内容足够多，有许多外链引用，百度就会千方百计去兼容它。所以，多做点外链宣传就好，加友链，在社交网络或各种社区的讨论区推广。可能你会嫌它们的「外观」丑、「定制性」不强，不能让每一个地方都能调整得符合你的心意。但有利就有弊，这是「便捷」的代价，你可以更专注于内容的生产，而非去折腾网站的细节。也可以用 GitHub：将一个 Project 作为个人博客的载体：因为 Web 端（浏览器）的 GitHub 项目代码页面能渲染显示 *.md 等 Markdown 格式的文件。将一个 Project 的 Issues 作为载体：也支持 Markdown 语法的渲染显示，同时还兼具「评论」功能。将一本 GitBook 作为载体，用写书的方式来写博客，也支持「评论」，可以算是静态博客的一种了。特点静态 指的是被请求的网页已经提早做好了，服务器直接将其发给浏览器即可。动态 指的是被请求的网页需要服务器根据具体情况实时计算得出，生成完成后再发给浏览器。区别在于：是否需要有在线的服务器去生成网页。动态博客运行的硬件环境 —— 服务器云服务器：现今通常的选择国内：阿里云、腾讯云、美团云…国外：AWS、Google、Linode…本地服务器：比较麻烦首先得拥有 公网 IP，才能被外界访问得到，然后对外提供服务。然而购买公网 IP 服务的费用，并不比购买一个拥有公网 IP 的云服务器便宜多少。要考虑服务器的「硬件配置」（处理能力）：带宽、流量、CPU、内存、存储空间 等……运行的软件环境HTTP 服务器: Nginx、Apache 等语言环境：PHP（PHP-FPM）…数据存储：MySQL、Redis ……静态博客优点省钱不用花钱购买服务器。省心（易上手）不用配置、维护服务器，不用过多关心服务器的细节。安全不需要过多关心服务器的安全问题，例如被入侵、D-DOS 等问题耐折腾静态博客可以折腾的东西也很多，能够满足我折腾的欲望（见后文）。访问速度快首先少了动态生成网页这个耗时的过程，而且还能挂载到多个 CDN 中，加速世界各地对这些网页的访问。服务稳定只要确保生成好的页面没有问题，就能保证浏览器的展示效果，不会像动态博客服务器那样，可能由于软硬件环境导致动态生成的网页出错。只要挂载网站页面和资源的服务（器）还算靠谱，基本很难碰到服务器宕机的情况。缺点少了亲身了解服务器各种细节、动手实践应用各种 Web 知识的机会，少学不少东西。考虑我一开始 图省事，选择了静态博客。尝试搭建个人博客的新手，推荐从静态博客入门。由浅入深，门槛够低好入坑，以后还想要搭建动态博客也不迟。静态博客生成器静态博客生成器有不少，Top 4：Jekyll GitHub 的官方推荐（Ruby）；Hugo 基于 Go 语言，热门（Go）；Hexo 我的选择，基于 Node.js（JavaScript）；中国台湾的一个年轻人（大学时）编写的，中英文档齐全~GitBook 用写书的方式来写博客；其它可参阅网站 StaticGen 。挂载空间Page 服务的挂载方法，可见前文《搭建个人博客》。通常使用：Page 服务：GitHub Page全球通用，时不时会被国内封锁，不知道什么时候会全面封锁。Coding Page相当于 GitHub Page 的国内版，来自 Coding.net 的服务。在国内访问速度比较靠谱。GitLab Page还有其它代码托管服务商的 Page，请自行搜索。CDN 服务：又拍云、七牛云等 CDN 服务商，可以提供静态网站的挂载和加速。但通常网站要先备案，才能提供服务，具体可见本文「网站备案」 小节。传统方式：用云服务器或本地服务器，配置好 Apache 或 nginx 等 HTTP 服务器，在浏览器请求页面时，将网页文件返回去。毕竟不是动态博客，基本没有必要这么做，浪费带宽、网费、电费等软硬件费用。基础外观博客主题我选择的是 Hexo，从官网的 Themes 页面中选择我一开始用 Jacman。扁平、简洁、美观；基础功能比较完备，包括基本的评论、分享、各种边栏组件等。后来改用 NexT。黑白扁平、很简洁、更美观；上述 Jacman 主题的作者 WuChong 现在也在用这个主题。基础功能非常完备，而且还在持续的优化维护中；之前不少需要我自己手动添加的第三方服务，都提供了详尽的支持。例如：文章的阅读量计数（PV）：基于 LeanCloud 来实现（以前靠自己看教程来添加）；网站的独立访客量（UV）：用不蒜子等第三方服务来统计（同上）。选用一个基础功能完备、符合自己审美的博客主题，可以省很多功夫。可以自己做一个独一无二的个人专用 theme，但若是没有前端和设计的功底，恐怕效果不佳、费时费力还不好维护。当然经过一番折腾，能学到一些前端和设计的知识。一开始没有能力独立做一个靠谱的 theme，也可以在别人的 theme 的基础上，进行个性化的修改。我就 fork 了别人的 theme，定制了自己的模块和 CSS 效果（链接）。这样可以深入定制间距 margin padding、颜色、字体、字体样式，隐藏不想要的元素，增加新的功能模块……如果过程中做出了一些还不错的成果，也乐意分享的话，可以提 pull request 将它们回馈到 theme 的母项目中。简述博客主题的制作：使用 模板引擎（或者说 模板库），配合静态博客生成器的 API，来生成博客的各种页面。例如：ejs、swig 等Hexo Theme 的简要制作说明。前人已经贡献了不少模板引擎以及相关的辅助工具到 Hexo Plugins 了。可以看看各种 Hexo Themes 的效果。文章内容Hexo 中的文章支持 Markdown 语法的渲染，也支持直接以 HTML 格式的发布的文章。熟识 Markdown 各种语法。要多用，摸清它在 Hexo 及其 Theme 中的支持程度，及其显示效果。有些效果 Markdown 支持不了，就直接用 HTML 标签来补。但是能用 Markdown 实现的，还是用 Markdown，简洁明了易于维护。其实还有 Hexo 及其 Theme 支持的表现力更强的「标签」，例如：Hexo「标签插件」Hexo Theme NexT 的「内置标签」；字体123body &#123; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif;&#125;曾经有个妹子说，被我这个博客的字体吸引了，这个吸引人的字体就是 Lato（西文字体）。可惜这个字体不是我主动选的，是 NexT 博客主题的默认设置的最优先使用的字体；第二优先使用的字体是 Apple 的字体「PingFang SC」苹方 简体中文版；Windows 系统不默认安装以上字体，访问本站将用第三优先级的「YaHei」雅黑，效果不理想。注意：字体资源需要额外加载时间，会影响网页的加载速度。通常使用 Google Fonts，但是在国内被墙，严重拖慢加载速度。优化：从更快速稳定的 CDN 中加载；国外用 Google Fonts，国内则优先使用墙内资源（自行搜索）；如果访客主要在墙内，全用墙内的资源也没差。图标（字体）「用字体来打包常用图标资源，以便加载和使用」。最常用 FontAwesome，点击详见 图标列表。国内曾出现过 Font 屌，可惜作者已弃坑。用这种简便的方式引入图标资源，在必要的地方使用它们可以提高内容的表现力，吸引别人的注意。FontAwesome 用法1. 先引用 FontAwesome 的静态资源。在 Chrome 浏览器访问本网页；→ 按快捷键 ⌘ ⌥ u 查看本网页的源码；→ 按快捷键 ⌘ f 查找；→ 输入 awesome 回车 ↩ 就可以找到以下这行引用。1&lt;link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"/&gt;`2. 在页面需要的地方插入以下 HTML 标签，即可显示 &nbsp;在 Chrome 浏览器访问本网页；→ 右键点击上一行的心形图标；→ 在谈出菜单中，点击审查元素，即可看到以下这行引用。1&lt;i class="fa fa-heart"&gt;&lt;/i&gt;class 样式FontAwesome 还有其它一些 class 样式。维度众多：宽度、大小、旋转、翻转、动态图标、图标列表显示 等，详见官网的 Examples 样例。宽度：给 HTML 标签的 class 添加 fa-fw 可以让这些图标以等宽的形式显示。非等宽： &nbsp; 等宽：12345678910111213 &lt;i class="fa fa-fw fa-file"&gt;&lt;/i&gt; &lt;i class="fa fa-fw fa-bookmark"&gt;&lt;/i&gt; &lt;i class="fa fa-fw fa-bath"&gt;&lt;/i&gt; j``- __大小__：大（ +33% ）`fa-lg`，以及两到五倍 `fa-2x` `fa-3x` `fa-4x` `fa-5x` &lt;br/&gt; &lt;i class="fa fa-camera-retro"&gt;&lt;/i&gt; &amp;nbsp; &lt;i class="fa fa-camera-retro fa-lg"&gt;&lt;/i&gt; &amp;nbsp; &lt;i class="fa fa-camera-retro fa-2x"&gt;&lt;/i&gt; &amp;nbsp; &lt;i class="fa fa-camera-retro fa-3x"&gt;&lt;/i&gt; &amp;nbsp; &lt;i class="fa fa-camera-retro fa-4x"&gt;&lt;/i&gt; &amp;nbsp; &lt;i class="fa fa-camera-retro fa-5x"&gt;&lt;/i&gt; ``` html &lt;i class="fa fa-camera-retro"&gt;&lt;/i&gt; &lt;i class="fa fa-camera-retro fa-lg"&gt;&lt;/i&gt; &lt;i class="fa fa-camera-retro fa-2x"&gt;&lt;/i&gt; &lt;i class="fa fa-camera-retro fa-3x"&gt;&lt;/i&gt; &lt;i class="fa fa-camera-retro fa-4x"&gt;&lt;/i&gt; &lt;i class="fa fa-camera-retro fa-5x"&gt;&lt;/i&gt;动态图标：旋转 fa-spin ，跳动 fa-pulse 12345&lt;i class="fa fa-spinner fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;i class="fa fa-circle-o-notch fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;i class="fa fa-refresh fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;i class="fa fa-cog fa-spin fa-3x fa-fw"&gt;&lt;/i&gt;&lt;i class="fa fa-spinner fa-pulse fa-3x fa-fw"&gt;&lt;/i&gt;网站 logo这里说的是 favicon.ico，在一个网站被访问或被收藏时，显示在该网站的浏览器标签页（tab）网页名称左边的那个小图标就是网站 logo 的 ico。因为通常显示得比较小，所以最好选择一个比较简洁明了、有辨识度的图标。如果选择的图片不是 ico 格式的，可以找一个工具网站，进行格式转换。CSS即「级联样式表」（百度百科）。我的常用自定义样式：方便以 class 的方式，给网站模块和文章的页面元素添加样式。12345.bold &#123; font-weight: bold; &#125;.center &#123; text-align: center; &#125;.hidden &#123; display: none; &#125;.no_underline &#123; border-bottom: 0; &#125;.white &#123; color: white; &#125;例如：加粗1&lt;span class="bold"&gt;加粗&lt;/span&gt;这里只是一种演示，能用就用 Markdown 的语法进行加粗：__加粗的文本__ 或 **加粗**。1&lt;span class="bold hidden"&gt;隐藏元素&lt;/span&gt;不用 &lt;!-- … --&gt; 是因为要同时修改两处。这里要隐藏直接给 class 加上 hidden，否则直接去掉就好了。CSS 框架我熟悉的有 Less.js、stylus（都是我用过的 Hexo Theme 中所依赖的）简洁、有序，降低 CSS 声明的冗余度，提高复用性。大大简化原始的 CSS 书写，提高编写效率。配色其实也是 CSS 配置的一环。博客主题有自带的配色方案。如果不满意，可以看看网上的调色盘，不断尝试直到找到满意的配色；直接修改博客主题源码的 CSS 模板，重新生成页面，就可以查看效果。即使有能力「审美」，不代表有能力「生产美」。建议还是找到一个靠谱的博客主题和靠谱的配色方案，不要自己调 RGB 找颜色，配色真的是一项学问。首先配色很浪费时间，即使一时找到满意的配色，通常也不耐看，一段时间后又要重新配。个人经验之谈……虽然折腾独立博客是一种乐趣，但我还是觉得花时间写好一篇文章更有价值。要搞清楚自己做独立博客的目的，折腾这些是不是对于你要专注的发展方向有助益？主页信息流常见内容：虽然有人定制这个页面：显示一张或几张相片；几个主要页面的链接；作品展示；各种动效、视频等。但博主还是希望别人关注自己的博客内容，所以通常还是用来显示文章流。文章信息流文章显示形式：分页 不分页？可以直接取消文章流（只留文章的「归档」信息流）首页直接显示文章。显示 全文、摘要，还是用自定义的描述文本？摘要的截取方式：最初的段落？最初的几百字？特别指定的部分？显示 发布时间、更新时间？时间的 展示格式是否显示更新时间，用 作者指定的时间 或 文章文件的修改时间（取自系统文件属性）？显示 文章配图?摘取文章内容中的图片，或是另外指定？显示 分类、标签？显示一个、多个还是全部？显示 PV 阅读数统计方式？LeanCloud，自建 API 服务，或其它第三方服务。显示格式：10,233 10.2k 10k + 等？显示 评论数？顶栏常见内容：网站 Logo网站名口号 Slogon箴言、座右铭？导航栏 nav包含到各个页面的链接：首页、分类、标签、归档、友链、留言板、关于、RSS 订阅、……搜索栏广告位……显示形式：通常固定在页面顶部；一直浮动显示页面内容上方。边栏常见内容：导航分类标签友链留言板关于：个人、网站简介RSS 订阅微信公众号 推广最近、热门、推荐文章评论社交网络展示就是以一个小方框模块来集中显示一些博主的社交网络信息GitHub 动态Douban 动态微博秀（动态）打赏广告位……做法：其实不一定需要有边栏，比起啥都有（我认为杂乱无章）啥都想展示，还是有侧重点的展示比较好。不能只能考虑自己觉得爽，也要考虑访客爽才行，别人其实不一定想看到那么多东西，了解你那么多东西。页脚常见内容：版权声明作者名备案声明导航通常对应网页 head（顶栏）的导航「返回顶部」的链接箴言、座右铭社交网络的链接推荐文章友链杂七杂八……不推荐加太多乱七八糟的东西，其实别人看到也不会点击查看。拓展元素「评论」系统国外常用：DisqusFacebook Comments Plugin其它自行搜索。国内常用：畅言（需要国内备案）网易云跟帖多说（盛极一时可是没盈利，已关闭，我只能从它完全迁移到了 Disqus）以上多种系统 Hexo Theme NexT 都默认支持。为了优化访问速度，我停掉 Disqus 的自动加载，只有你想看或写评论时，点击「加载评论」才去加载。毕竟 Disqus 的服务被墙了，加载它会严重超时，影响访问速度。延展特性不同的评论系统，支持的特性可能有所区别，需要适当的取舍，或者同时支持多个评论系统：评论权限控制需要登录注册？可能是第三方登录：国外的 Google、Facebook、Twitter 等国内的 QQ、微信、微博 等游客可评论？需要留邮箱、网站等联系方式？可匿名评论？评论审核？先审后显？可删改？评论支持「楼中楼」像是最常见的百度贴吧那种还是说，直接使用「复制需要引用的所有评论原文」的方式来实现的？带「分享 Share」按钮国内常用的社交网络和国外的还是有较大区别的，支持的平台可能有较大不同。带「赞 Like」按钮：可以对 这篇文章 或者 对某条评论 进行针对性的态度表达。例如还带。或者是其它「表态」：除赞之外的其它情感表达，例如「踩」vote down，还有高兴、悲伤、愤怒等。带「评分 Rating」一般都用 5 个星级来评分。评论可显示评论网友的 IP 和 UA 信息（操作系统、浏览器）？据说显示 macOS 的逼格比较高？（滑稽）是否显示头像，是否可自定义头像？可订阅该文章「评论」？可推荐博客的相关（其它）文章文章数据统计？PV 数、趋势等文章路径变更，评论可以修正依附的文章链接？评论的导入导出支持哪些其它厂商的评论系统服务（如无，可以使用相关的格式转换工具）……尝试和感想关于「评论」尝试过让 Disqus 和 多说 同时加载，感觉加载太慢了，占地方不说，看起来还是有点怪。改成过自动加载 多说，Disqus 要点击之后才加载。后来只用 多说，毕竟基本还是用中文写博客，没什么外国人看，更别说去评论了，所以还是只用国内的服务。最后 多说 宣布停止运营，转投 Disqus。还得将评论数据导出，转换成 Disqus 兼容的格式后导入。关于「赞」按钮：我曾经加过一些很二的 js 脚本到网站中。例如，如果访客访问一篇文章，发现 ta 还没给它点过赞，就会自动点赞…… 这么做毫无意义，只是虚荣心作祟罢了。关于「评分」按钮：在朋友的博客发现了这个组件之后，本来一度很想给自己的博客也加上。心里挣扎了一番后，还是觉得博客简洁一点更好看。而且本来访客就很少，没必要做评分。「分享」组件博客系统 或者 博客主题 自带。评论系统 通常也附带。使用其它第三方组件，百度分享（样式实在太丑），以及其它 js 的开源包，例如 share.js。根本就不去使用，毕竟我倾向于让网站简洁一些。如果内容够好，别人自然会复制你的文章链接然后分享出去。友链「友链」的意义？对我来说，是有交情的朋友的独立博客，我才会去加这个外链接。但更常见的理由还是：通过增加个人网站的「外链引用」来进行 SEO。所以才会在博客里看到许多关于「请求互相添加友链」的请求评论，即使他们互相不认识。「友链」放哪里？首页边栏、底栏；特定的页面：通常链接会加到主页的导航栏中：「关于」页面；专门的「友链」页面；而我放到了博客的「导航页」中。PV Top N 热榜有了文章 PV 的统计数据，自然就能通过查询 PV 前 N 名的文章，从而实现一个文章 PV 的热榜。「热榜」详见博客右边栏的「站点概览」或 博客导航 的第二节。可以用浏览器的「审查元素」去常看展示效果和实现代码，源码详见 Theme NexT 。实现 PV 计数用的 LeanCloud，API 完备、文档清晰，定制化的查询很容易实现。除了 PV 计数，其实还可以做很多其它数据的统计和活用，可以开一下你的脑洞。文章评论热榜的实现也是用类似的做法。随机显示名言一言随机显示动漫台词，可以加在 head 页头、footer 页脚、sidebar 边栏等地方。也是用其别人的 API 服务来实现的，不过现在已经去掉这个模块了。类似服务让我也想自己写一个出来，可以加上古今中外的古诗词、歌词、名台词、名言等。（暂时想到可以用 LeanCloud 的云服务来简单实现一个，有空有兴致再尝试）RSS 订阅网上教程很多，在此不赘述。只提一个问题：网站内容混入了「控制字符」后，然后可能被收录到用于 RSS 订阅的文件中，如 atom.xml；通常这些文件以 UTF-8 的编码进行解码，控制字符导致其无法被正确解析，因而无法订阅。网上的解决方法通常是：根据 Chrome 等浏览器读取错误的 atom.xml 这些 RSS 订阅文件时的报错信息，来了解混入了哪些控制字符，它们在哪里（哪些文件）；然后用文本编辑器搜索出它们，删掉即可。但是！不是所有文本编辑器都支持「搜索控制字符」；即使支持，你知道如何输入这些控制字符吗？建议使用 Vim（亲测可用）、Emacs 来进行操作。用 Vim 打开包含控制字符的文件；在 NORMAL 模式下，输入 / 进入搜索模式；直接输入 0x05，然后回车，就能直接搜索到对应的控制字符；有些控制字符，可以通过先按前缀键 ^ v 然后按控制字符的对应键来输入；通常这些控制字符都是没有作用的，删除之。Vim 的目录搜索、批量替换等其它详细用法请自行搜索。署名协议比起开源项目的授权许可协议，文章的署名协议其实不用太纠结。要的就是「我把它用起来了」的优越感；虽然我写的东西不敢说有很大价值，最重要的还是以防万一，有个声明比较稳妥，便于维权。我用的协议见文末。Hexo Theme NexT 提供了支持：只要在博客主题的 _config.yml 配置文件中开启 post_copyright 相关配置，就会自动在每篇文章下添加署名协议。打赏详见《实现网站的打赏功能》Hexo Theme NexT 也自带了打赏模块，详见官方文章 开启打赏功能。会自动在每篇文章末尾添加打赏用的二维码和文案。毕竟没几个人会打赏，为了精简网页元素，所以我只留了这一个入口 打赏博主。404 页面就是访问到一个网站下的无效网页 URL 地址时，显示出来的页面。HTTP Status Code（状态码）：404 NOT FOUND（找不到页面）。比较流行的做法：接入「腾讯公益 404」其实什么都不做也没啥，反正你挂载网页用的服务商也有自己的 404 页面，可能不够有个性，但不会太难看。当然这样的话，如果网站是挂在个人域名下的，看 404 页面就能明显地看出你在哪里挂载的博客页面。静态博客生成器，通常是在本地生成网页，浏览器访问本地网页查看效果，然后再将网页上传到互联网上。这么做 404 页面是不好测试的，简单的测试方法是：得将 404.html 等页面上传到你网站所在的互联网空间，才能看到效果。进阶做法毕竟进阶做法，请自行检索实现方法，动手尝试，仅提供简单的思路。自动反馈错误链接就是「自动将访客访问到错误网页地址收集起来」。思路一、通常可以用 JavaScript 来先获取错误链接，然后调用 HTTP API（如 LeanCloud 等）来收集。思路二、开启网站的评论系统对匿名评论的支持，还是用 JavaScript 在 404 页面自动发表评论来反馈相关错误信息。……有了错误链接的数据，就可以进行下一步「错误链接重定向」了。错误链接重定向文章链接变更后，外链引用（包括搜索引擎的结果）没有及时更新或无法更新，需要 404 页面做处理，重定向正确的网页地址。因为刚开始用独立博客，没有考虑过页面 URL 的配置问题，以至于文章的发布的「年月日」成了文章页面 URL 路径的其中一部分。URL 不便于修改，而且比较长难记难输入，也不好看。实现方法：其实就是用原生 JavaScript 先获取错误的链接，匹配可能的旧链接，将网页重定向到对应的新链接、正确链接。npm我选用的静态博客生成器 Hexo 基于 Node.js，必然用到 Node.js 的包管理器 npm 。反正我觉得 npm 不是特别省心，升级 Hexo 或者相关插件时不时会出现一些恼人的错误。毕竟 npm 上的项目依赖通常比较多，版本号一日千里（夸张的说法），更新变动不少；有时不一定是用户的问题，也有可能是作者一不小心弄错了。例如，对应的依赖项目的版本有大更新，不兼容过去的版本，作者忘了锁住所需的依赖项目的版本号。解决方法：最简单靠谱的方法：回退依赖项目的版本，即使用稳定的旧版本。需要修改 Hexo 博客源码根目录下的 package.json 手动声明指定依赖项目的版本号。上网搜索别人的经验，若无则等待，等他人修复好了提供教程。去对应的 GitHub 项目的 Issues 查看；若无自行创建一个，提醒作者修复。疑难杂症的粗暴解决方法：Hexo 博客源码根目录下，npm update 更新依赖项目；不行的话，试试删掉 Hexo 博客源码根目录下的 node_modules 目录，重新 npm install ；不行的话，删掉系统用户的根目录下的 node_modules 目录，重新 npm install -g ；再不行，先更新一下系统软件（macOS 用 Homebrew 管理软件的话，用 brew update 和 brew upgrade），可能是需要 Node.js 及其相关的更新。站长进阶网站分析统计国外常用 Google Analytics。Google Analytics（分析）不仅可以帮助您衡量销售与转化情况，而且能为您提供新鲜的深入信息，帮助您了解访问者如何使用您的网站，他们如何到达您的网站，以及您可以如何吸引他们不断回访。国内常用 百度统计。百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，有了这些信息，可以帮助用户改善访客在用户的网站上的使用体验，不断提升网站的投资回报率。简而言之：分析访客，分析网站网页的价值。谷歌的服务由于被墙，在许多网络环境下加载 Google Analytics 所需的资源都会超时，严重拖慢了网站的访问速度，所以停止了对它的使用。特别对于我这个一文不名（$0）、纯属自嗨的独立博客来说，没必要进行那么多的分析。不过是想尝试使用网站分析统计服务，满足自己对它们的好奇心罢了。访客主要来自国内，留一个 百度统计 即可。做了许多优化之后，现在本网站的网页基本实现了秒开。站长工具搜索引擎收录国外基本都用 Google Webmaster您希望提高您的网站在网络上的曝光度？我们可以助您一臂之力。您可以通过 Google Search Console 跟踪您的网站在搜索结果中的排名，并可以浏览更多网站站长资源。为您的网站获取支持。如果您的网站出现问题，您可以通过我们的常见问题列表、支持文档和测试工具快速获取帮助。了解如何打造卓越的网站。想要打造能够让用户畅享卓越体验并能在搜索结果中名列前茅的网站？请查看我们的课程和指南，了解如何打造用户可轻松找到的高品质网站。国内常用 百度站长工具关键词影响力，是百度站长平台针对站点对于关键词数据分析的需求，推出的全新概念。涵盖该关键词下百度搜索可以为站点带来的全部收益指标，包括：排名、百度搜索流量、展现量等。在H5版本的站长平台工具中首发的关键词影响力工具检测数值有：整体影响力、最大影响力、站点影响力。网站分析服务 和 站长工具 的用途是不一样的。简而言之，站长工具 对我们最重要的用途是：告诉搜索引擎我们的个人网站的存在，让它们去收录我们的个人网站的网页到它们的搜索结果中；然后查看实际的收录效果。触发搜索引擎的收录行为的方法：（详情请见官方网站和文档）被动等待它们的爬虫来抓站；主动上站长工具，手动触发爬虫去抓站；主动提交站点地图 sitemap.xml 的地址，RSS 订阅用的 atom.xml 的地址也可以；还可以使用官方提供的 API，主动按需推送新上线的网页的地址和内容。站内搜索最简单的方式：设置一个搜索按钮，链接到以下地址后，访客再自行搜索：Google：https://www.google.com/?q=site:icehe.me百度：https://www.baidu.com/s?wd=site:icehe.me或者设置一个搜索框，将访客输入其中的 “关键词” 拼成以下 URL 地址，然后再跳转过去：Google：https://www.google.com/?q=site:icehe.me%20keyword百度：https://www.baidu.com/s?wd=site:icehe.me%20关键词本质是使用搜索引擎的语法：[keyword] site:[site_url]示例：测试 site:icehe.me 测试链接（然而跳转后还要按回车键才行……）Google 和 百度 都有提供专门的站内搜索功能，可是用起来还是不够方便。还是因为 Google.com 被墙，国内的非翻墙用户以上的方法都用不了。百度的站内搜索，体验不够好，被我放弃。本地服务：比如 Hexo 的博客主题 NexT 就自带了 Local Search 功能。本质是生成博客时，也根据博客的内容生成一个 search.xml 文件作为博客搜索的索引库，保存到线上；然后使用博客的 Local Search 搜索框时，Web 端（浏览器）的 js 脚本会根据 search.xml 文件执行检索操作。确实是一种很便捷、廉价的实现方式，我很喜欢，就用了这种方式。其它搜索服务：Algolia、Swiftype、微搜索（国人作品，已废弃）体验都非常好。可免费使用一段时间，但终究要付费，好服务价格不菲！推荐土豪使用。否则试用期过后，虽然通常可继续使用，但功能受限：网站的索引不再持续更新，或者索引量上限很低。网站域名购买途径：国内域名运营商：例如，万网。购买域名后，如需正常使用，首先要进行 “中国特色” 的「备案」将域名实名绑定到特定的自然人或法人，以便「追责」。国外域名运营商：NameCheap、GoDaddy，域名比价网站 domcomp 。无需备案，也无法备案。需要将域名转到国内网站接入商，才能进行备案。等于将网站域名（接入服务）绑定到服务商，以便随时「拔掉你网站服务器的网线」。网站备案为什么我没有备案？（答案并不敏感和复杂）（六）安装备案电子标识：网站所有者应于 15 日内将备案电子标识安装在网站首页的右下方……这个备案标识实在太丑了，我不愿意放……没备案的麻烦：国内的许多针对网站站长的服务，要求你的网站备案了才能使用。例如：「畅言」的评论系统；网站挂载到 CDN 进行加速访问（「七牛云」等）；不将域名绑定到微信公众号，就无法保证你的网站在微信内顺畅地访问：被转码、拦截，正常的 js 脚本也被阻止运行，跳转很麻烦甚至无法跳转等。域名的 DNS 解析我用国内的免费版的 DNSPod 服务就够了。当然，你在哪购买的域名（我用了 NameCheap），可以尝试用那个域名销售商的 DNS 服务。如果你选的 DNS 服务是国外的，在国内，你域名的 DNS 查询稳定性和速度可能不理想，所以我还是使用国内的服务。不靠谱的服务商会可能会让 DNS 查询比较花时间，我不希望这成为个人网站访问速度的瓶颈。图床 与 图片最简单的方法：直接把图片放在挂载网站的空间中，例如 GitHub Page 的项目。虽然每个 GitHub 账户在不付费的情况下，有一定储存容量上限，但一般够用。稍微不够用，可以多申请几个 GitHub 帐号来缓缓。如果图片太多还是使用第三方的图床服务比较靠谱。图床服务商：又拍云：服务很好，但对于一文不名的独立博客来说费用太贵；七牛云：服务不错，免费 10 GB 空间，够用；微博：…… 其实就是你用微博发图片，然后使用图片引用链接而已。……图片压缩：虽然图床空间一般够用，下载速度也不差，但要是图片太大也是会影响的网页的加载速度的。所以，首先确保网站页面在常用的网页浏览设备的显示效果良好，然后多余的像素、占用的比特空间可以都压缩掉。图片压缩方法：上传前压缩：可以是命名行指令和脚本；或者是专用的带 GUI 的 Apps。长传后压缩：或者图床空间自带压缩效果……床服务的上传服务的 API 带压缩的选项。访问速度优化Chrome 浏览器自带的开发者工具，就自带网络资源加载和网页性能的分析工具。如果使用 Google 和 百度 的网站分析统计工具 或 站长工具，里面也有优化分析工具，给你提供建议。其它可以上网搜索相关的内容。性能优化这条道路无穷无尽，我也走过弯路，做过许多无用功……其实在大多数地方达到「秒开」（1~2 sec）就够了，没必要追求太机制的体验。但是要是囿于某些资源，页面能看全了，但「菊花」（刷新标识）还是转个不停，这就感觉很不好了。为了优化访问速度，我主要做了：Google Analytics 只留「百度统计」；停掉 Disqus 的自动加载，只有你想看或写评论时，点击「加载评论」才去加载；字体、图片、js 库，优先用国内的 CDN 资源，否则放国内图床（七牛云），再不济就放 Coding Page 的博客源码项目里。网站结构我的思路所有页面即文章（POST），包括「关于」页面这种，除了 404 页面。会在首页文章流显示的是 POST 类型文章的链接；不在首页文章流显示的是 PAGE 类型的页面；首页是 INDEX 类型的页面。尽量不使用 PAGE 类型的页面，除非是打算不暴露外链的隐藏文章，哈。自动化的尝试Evernote 笔记导出为 Hexo 文章文章导出为 HTML，挪到博客源码的文章目录下；其中的图片资源，先经过脚本工具压缩，再上传图床，计算得出其网络路径；网页的 HTML 文件，会经过一番修改：补充一些 Hexo 生成文章页面需要的元标签；将其中图片的本地路径，替换为网络路径。参考代码：Python_for_Day_LogAppleScript_for_EvernoteAppleScript_for_memy_scripts_on_win当然，其它一些笔记软件可以导出为 Markdown 格式的文件就更好弄了。注意它们支持的可能是自定义过拓展过的 Markdown 语法，Hexo 或你的 Hexo Theme 不一定支持。所以 Markdown 标签可能也需要经过一定的替换等处理（考验你的正则表达式），然后做好测试，检查实际显示效果（难免百密一疏）。其它经验关于 Evernote用脚本在 macOS 导出 Evernote 的笔记，可以用 AppleScript；但其命令行的 API 不如 Windows 上的好，Evernote 有专门的 *.exe 的支持批处理或 Power Shell 的脚本调用。以前文章导出为 Evernote 的专用笔记格式 .enex 时，图片以 BASE64 的格式存储，还要先转码后保存成单独的文件进行处理；.enex 中的文章正文，基本符合 HTML 的标准；.enex 格式中有一些 Evernote 专用的标签，保存版本号、图片引用、文章名、分类、标签、笔记本名等。重复的工作有些不会长久使用的自动化操作，还是手动来做更快，写脚本维护成本确实非常高，并不省心，只是觉得用得爽有成就感。根本在于这些脚本的没有「放大效应」「规模效应」，可能只有你自己一个人用，所以没能成规模地节省很多人的时间。当然最后还是要说一句，折腾自动化还是挺有成就感的。虽然可能没什么人在意，找工作时面试官也不会在意。吐槽：效率软件的使用，面试官通常也不看重，我泪目，我承认有一定道理，但是不服…… 至少我搬砖比一般人快多了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 宏定义与位操作]]></title>
    <url>%2Fc%2B%2B%2Fmacro_and_bit_operations%2F</url>
    <content type="text"><![CDATA[提醒：不过多赘述「宏」以及本文相关的其它 C++ 基础知识，不明之处暂请自行 Google。宏定义即 Macro。PrintPrint Expr &amp; Result便捷地打印程序输出：变量或表达式，以及计算结果。重复 cout &lt;&lt; variable &lt;&lt; endl; 这种用于打印程序输出的代码实在麻烦，但不得不写，所以，为了更便捷地打印程序输出，写了一些辅助的「宏」。1#define v(x) cout &lt;&lt; '\t' &lt;&lt; #x &lt;&lt; " = " &lt;&lt; (x) &lt;&lt; endl;关键：用宏定义的展开，减少代码量。#x 的语法可以获取 x 所代表的变量或表达式的具体内容。(x) 中的括号不能去掉！否则可能会得出意想不到的错误结果。提示：在程序的预处理阶段，会展开代码中「宏定义」，即对「宏名」进行简单的字符串替换，详情自行 Google。打印工具的宏定义print_tools.h1234567891011121314151617// 说明："CPP_TEST" 为本 Demo 项目名#ifndef CPP_TEST_PRINT_TOOLS_H#define CPP_TEST_PRINT_TOOLS_Husing std::cout;using std::endl;// 打印字符串#define l(str) cout &lt;&lt; str &lt;&lt; endl;// 打印变量或表达式，及其结果#define v(x) cout &lt;&lt; '\t' &lt;&lt; #x &lt;&lt; " = " &lt;&lt; (x) &lt;&lt; endl;// 打印一个空行（分隔不同的程序输出）#define el cout &lt;&lt; endl;#endif //CPP_TEST_PRINT_TOOLS_H说明：这种声明是为了避免项目重复引入该头文件（即 #include &quot;print_tools.h&quot; ）时，重复定义其中的内容。作用：防止重复定义1234#ifndef CPP_TEST_PRINT_TOOLS_H#define CPP_TEST_PRINT_TOOLS_H// …#endif //CPP_TEST_PRINT_TOOLS_H演示打印工具main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include "print_tools.h" // 引入上述的宏//using namespace std; // 不将整个 std 引入，因为其中很多东西都用不上。/* 后文的样例中，需要额外引入的「库和对象」放这 */#include &lt;map&gt;using std::map;// …/* 宏定义 */#define MAX(a, b) ((abs((a) - (b)) == (a) - (b)) ? (a) : (b))// …/* 「函数前置声明」放这 */bool isIncr(int *ary, int count);// …int main() &#123; /* 运行的「测试代码」放这 */ l("test") int x = 1; int y = -1; v(x) v(x &gt;&gt; 31) v(y) v(y &gt;&gt; 31) el l("MAX") v(MAX(10, 20)) v(MAX(-10, -20)) el l("用一个递归算法，判断一个数组中的值，是否递增？") int ary = new int[5]&#123;1, 4, 5, 9, 7&#125;; v(isIncr(ary, 5)) delete []ary; ary = new int[5]&#123;1, 4, 5, 7, 9&#125;; v(isIncr(ary, 5)) delete []ary; el //… return 0;&#125;/* 「函数定义」放这 */bool isIncr(int *ary, int count); &#123; return count == 1 || (count != 0 &amp;&amp; ary[count - 2] &lt;= ary[count - 1] &amp;&amp; isIncr(ary, --count));&#125;// …输出123456789101112131415test x = 1 x &gt;&gt; 31 = 0 y = -1 y &gt;&gt; 31 = -1MAX MAX(10, 20) = 20 MAX(-10, -20) = -10用一个递归算法，判断一个数组中的值，是否递增？ isIncr(ary, 5) = 0 isIncr(ary, 5) = 1…进阶可参考《宏定义的黑魔法 - 宏菜鸟起飞手册》数值的大小关系判断两个数值的大小关系。以宏定义的方式实现1#define MAX(a, b) (abs((a) - (b)) == ((a) - (b)) ? (a) : (b))数值的 sign判断 signed（有符号）类型的数值的 sign（正负符号）。以宏定义的方式实现1#define IS_UNSIGNED(a) (a &gt;= 0 &amp;&amp; ~a &gt;= 0)unsigned 数值类型判断数值类型是否有符号（signed），即是否区分正负。以宏定义的方式实现1#define IS_UNSIGNED_TYPE(type) ((type)0 - 1 &gt; 0)各种语言的数值类型基本都实现了正负值的区分（signed），所以只使用 unsigned 来标识少数无符号的数值类型，而很少出现 signed 这种说法。int 变量的 bytes当前运行环境下（与 CPU 和 OS 有关），一个 int（整型）数值类型变量所占用的 bytes（字节数）。以宏定义的方式实现1`#define SIZE_OF(value) ((char*)(&amp;value + 1) - (char*)&amp;value)`宏定义语法 #### 用于连接前后两段代码。宏定义1#define CONCAT_CODE(a, b) (a##e##b)测试代码1v(CONCAT_CODE(2, 3))输出1CONCAT_CODE(2, 3) = 2000解释：因为 CONCAT_CODE(2, 3) 将代码 2、e、3 连接成 2e3，等于 int 2 * pow(10, 3) = 2 * 1000 = 2000。位操作即 Bit Operations，对数值（用二进制表示）的 bit（比特位）进行直接操作。int 整型数值整型，表示整数的数值类型。下文中，进行位操作的变量的类型，主要为 int 等表示整数的数值类型。暂不包括浮点数，float、double、long。int 可描述的数值范围：32 位（bits）操作系统（OS）下，占用 4 bytes-2^32 ~ 2^32 - 1（此处 2^32 表示 2 的 32 次方）64 位操作系统下，占用 8 bytes-2^64 ~ 2^64 - 1下文中，默认运行环境为 32 位的操作系统。数值表示方式：0x4F 中的 0x 表示该数值在以 16 进制进行展示；&#39;0010&#39;B 中的 B 表示该数值在以 2 进制进行展示。注意：C / C++ 中，不支持直接以 2 进制的形式声明数值；如有需要，通常以 16 进制的形式声明和表示二进制数值（bits）。以 16 进制展示数值：0x 00 00 00 00 = int 00x 00 00 00 01 = int +10x FF FF FF FF = int -1下文默认你知晓「在底层如何以二进制比特位来储存和表示整型数值，特别是『负数』。」负数：以二进制方式进行储存和表示时，最高位（最左）的 bit 是 1。int 0 在物理层面使用了 0x 00 00 00 00 这个数值来表示，所以，int 等整数数值类型，所能描述的正数的范围被比负数范围小 1。移位求积快速求 int 2 的 3 次方每左移一位，数值增大 2 倍（除非溢出）12 &lt;&lt; 3快速求 int x 的 7 倍1(x &lt;&lt; 3) - x2 的幂判断 int 数值是否为 2 的若干次幂（即 2 的 n 次方）。数值在计算机中通常都以 0 和 1 的二进制形式存储着，其实关键在于，这个问题等价于判断一个整数的二进制形式是否「有且只有一位 bit 为 1」。测试代码12345678int x = 1024;v(x)v(std::bitset&lt;12&gt;(x))v(!(x &amp; (x - 1)))x = 513;v(x)v(std::bitset&lt;12&gt;(x))v(!(x &amp; (x - 1)))思路：x - 1 等价于「二进制表示的整数 x，从最后（右）一位 1 开始（包括这个 1）的所有 bit 都取反」，那么 x &amp; (x - 1) 就是去除 x 二进制表示中的最后一个为 1 的 bit；如果去除最后一位 1 后 x 变成了 0 了，它就是 2 的若干次幂。输出1234567判断一个 int 是否为 2 的若干次幂 x = 1024 std::bitset&lt;12&gt;(x) = 010000000000 !(x &amp; (x - 1)) = 1 x = 513 std::bitset&lt;12&gt;(x) = 001000000001 !(x &amp; (x - 1)) = 0求负数以位操作的方式，求 int x 的负数。123// `~` 是「按位取反」的操作符-x = ~x + 1-x = ~(x - 1)不详述推导过程，只提供简单的记忆方式：假设现在的运行环境是 8 位的操作系统，&#39;00 00 00 00&#39;B = int 0&#39;00 00 00 01&#39;B = int +1&#39;11 11 11 11&#39;B = int -1对以上三个数值进行通过简单的观察和推算，就能得出上面提供的公式。求平均值求两个 int 数值的平均值一般求法1(x + y) / 2缺点：如果 x + y 的数值超出 int 可描述的数值范围（即溢出），会得出错误的结果。位操作的求法1(x &amp; y) + ((x ^ y) &gt;&gt; 1)提示：从二进制角度来说，(x &amp; y) 等于「所有为 1 的 bit（比特位）相加的结果除以二」；(x ^ y) &gt;&gt; 1 等于「将 x、y 两数相加等于 1 的 bit（一个为 0 另一个为 1）除以二」。求绝对值以位操作的方式，求 int x 的绝对值。「求负数」的延伸。以下为思路：sign（符号位）的计算：x &lt; 0 时，x &gt;&gt; 31 = -1x &gt;= 0 时，x &gt;&gt; 31 = 0&gt;&gt; 右移操作，最高位（最左）用原最高位的数值进行补位：原最高位为 1，右移后，新的最高位补 1，原最高位为 0，右移后，新的最高位补 0。数值取反：~x = -1 ^ x = 0xFFFFFFFF ^ x代入求负数的公式: -x = ~x + 1 = (-1 ^ x) + 1注意：^ &gt;&gt; 等位操作符的优先级低于 + -，所以，书写时不能漏掉括号，以免算式出错。补充条件:x = 0 ^ x（进一步观察得到的，可能需要灵感）观察规律：x &lt; 0 时，abs(x) = -x = (-1 ^ x) + 1 = (-1 ^ x) - (-1)x &gt;= 0 时，abs(x) = x = 0 ^ x = (0 ^ x) - (0)得到启示：abs(x) = ((x &gt;&gt; 31) ^ x) - (x &gt;&gt; 31)解法：函数声明1234int myAbs(int x) &#123; int mask = x &gt;&gt; 31; return (mask ^ x) - mask;&#125;测试代码12345v(myAbs(0))v(myAbs(1))v(myAbs(-1))v(myAbs(17))v(myAbs(-29))输出12345myAbs(0) = 0myAbs(1) = 1myAbs(-1) = 1myAbs(17) = 17myAbs(-29) = 29多少个 bit 为 1数值变量的二进制表示中，有多少个 bit（比特位）为 1。说明：暂时想到的方法，还是需要用到循环（复杂度 o(n)）。提示：为 1 的 bit 分布稀疏时，如何快速求解（减少代码所需循环次数）！基础知识：将一个 int 变量（二进制表示中，从左到右数）最后一个为 1 的 bit 设置为 0：1b &amp; (b - 1)解法：函数声明12345678int countBit(int x) &#123; int cnt = 0; while (x != 0) &#123; ++cnt; x &amp;= x - 1; &#125; return cnt;&#125;测试代码12v(countBit(46)) // int 46 == '0101110'Bv(countBit(21)) // int 37 == '0010101'B输出12countBit(46) = 4countBit(21) = 3相邻 bit 不同时为 1n 位的二进制数字串，有多少个子串不存在相邻的 bit 同时为 1。思路：n == 1 时，有 0 和 1 两种符合条件的可能情况；n == 2 时，则有 00、01 和 10 三种可能；n == 3 时，则有 000、001、010、100、101 五种可能…根据归纳法，我们发现它类似于斐波那契数列。函数声明123456789101112131415int separate1(unsigned int n) &#123;// switch(n) &#123;// case 1:// return 2;// case 2:// return 3;// default:// return separate1(n - 2) + separate1(n - 1);// &#125; // 压缩 return 1 == n ? 2 : 2 == n ? 3 : separate1(n - 2) + separate1(n - 1);&#125;测试代码12345l("n 位的二进制数字串，有多少个子串不存在相邻的 bit 同时为 1")v(separate1(1))v(separate1(2))v(separate1(3))v(separate1(4))输出12345n 位的二进制数字串，有多少个子串不存在相邻的 bit 同时为 1 separate1(1) = 2 separate1(2) = 3 separate1(3) = 5 separate1(4) = 8不用 / 的除法不用除号完成除法。（利用位操作和加减法，甚至乘法）函数声明：方法 1 - 除法的直式计算（这里没有用到 * 乘号）12345678910111213141516171819int div1(int x, int y) &#123; if (y == 0) &#123; return 0; // should error &#125; if (x &lt; y) &#123; return 0; &#125; int c = y; int k = 0; for (; x &gt;= c; c &lt;&lt;= 1, ++k) &#123; if (x - c &lt; y) &#123; return 1 &lt;&lt; k; &#125; &#125; return div2(x - (c &gt;&gt; 1), y) + (1 &lt;&lt; (k - 1));&#125;除法的直式计算，就是我们国内小学教育教的那种除法算法，即是平时用草稿手写进行的那种除法计算。以上方法，并不便于进行详细解释。所以，简单地说，可以这么理解：我们平时进行的是十进制的直式除法计算，这里只是在二进制下进行这一过程。函数声明：方法 2 - 稍加改进方法 112345678910111213int div2(const int x, const int y) &#123; int leftNum = x; int result = 0; while (leftNum &gt;= y) &#123; int multi = 1; while (multi * y &lt;= (leftNum &gt;&gt; 1)) &#123; multi &lt;&lt;= 1; &#125; // multi * y 大于剩余数的一半时，终止 result += multi; leftNum -= multi * y; &#125; return result;&#125;测试代码123l("不用除号实现除法")v(div1(1112, 12))v(div2(1112, 12))输出123不用除号实现除法 div1(1112, 12) = 92 div2(1112, 12) = 92不用 + 的加法不用加号完成加法。思路：在二进制下，对两个数的相加为 1 的 bit，用「^ 异或」来求和；对两个数相加为 0 并进位 1 的 bit，先进行「&amp; 按位与」操作，然后「&lt;&lt; 1 进位」，然后再求和。函数声明：方法 1 - 递归123456789101112int add1(int x, int y) &#123;// if (0 == y) &#123;// return x;// &#125;//// int tmpSum = x ^ y; // 求和// int carry = (x &amp; y) &lt;&lt; 1; // 进位// return add(tmpSum, carry); // 缩写 return 0 == y ? x : add1(x ^ y, (x &amp; y) &lt;&lt; 1);&#125;函数声明：方法 2 - 迭代123456789int add2(int x, int y) &#123; int sum = 0; while (y != 0) &#123; sum = x ^ y; y = (x &amp; y) &lt;&lt; 1; x = sum; &#125; return sum;&#125;测试代码12345l("不用加号实现加法")v(add1(98, 103))v(add1(10, 6))v(add2(98, 103))v(add2(10, 6))输出12345不用加号实现加法 add1(98, 103) = 201 add1(10, 6) = 16 add2(98, 103) = 201 add2(10, 6) = 16不用 * 的乘法不用乘号完成乘法。思路：跟上文说的「不用 / 做除法」的思路类似，也是参考小学的时候学的「写草稿计算乘积」的算法。基础：顺着上文 「2 的幂」 小节的思路，可以知道得出一个 int 整数 最后一个为 1 的 bit 所代表的数值：两个公式等价12b &amp; ~(b - 1)b &amp; (-b)函数声明12345678910111213141516171819202122232425262728293031// 需要额外引用的工具库#include &lt;map&gt;using std::map;using std::string;int multiply(int x, int y) &#123; bool neg = (y &lt; 0); if (neg) &#123; y = -y; &#125; map&lt;int, int&gt; bitMap; for (int i = 0; i &lt; 32; ++i) &#123; bitMap[1 &lt;&lt; i] = i; &#125; int product = 0; while (y &gt; 0) &#123; // `被乘数 * 乘数` 找出乘数在二进制下的最后一位 1 在第 n 位 int shiftBits = bitMap[y &amp; ~(y - 1)]; // 叠加被乘数自身被左移 n 位的值（即乘以 2 的次方） product += (x &lt;&lt; shiftBits); // 去掉乘数在二进制下的最后一位为 1 的 bit！ y &amp;= (y - 1); &#125; if (neg) &#123; product = -product; &#125; return product;&#125;测试代码123l("不用乘号实现乘法")v(multiply(10, 6))v(multiply(29, 7))输出123不用乘号实现乘法 multiply(10, 6) = 60 multiply(29, 7) = 203大小端判断内存以什么字节序储存数据：Big Endian or Little Endian 大小端？简要说明大小端的区别（字节序）：内存 0x4000 ~ 0x4003 的低地址在左，高地址在右内存地址：从低到高（从左到右）。数据 0x 12 34 56 78 高字节在左，低字节在右！字节高低：从高到低（从左到右）。大端：从左到右 存放数据（操作系统常用顺序）高字节，从 低地址 开始放。小端：从右到左 存放数据（网络传输常用顺序）高字节，从 高地址 开始放。详情参考：详解大端模式和小端模式解法：函数声明1234bool isLittleEndian() &#123; unsigned short data = 0x1122; return 0x22 == *((unsigned char*)&amp;data);&#125;测试代码1v(isLittleEndian()) // 运行在 MBP 的 macOS 上。输出1isLittleEndian() = 1数值交换交换两个变量的数值。函数声明：方法 0 - 借助临时变量12345void swap0(int &amp;x, int &amp;y) &#123; int tmp = x; x = y; y = x;&#125;现在要求：在不使用第三个变量的情况下，实现两个变量的数值交换。函数声明：方法 1 - 加减法12345void swap1(int &amp;x, iny &amp;y) &#123; x = x + y; // 原理： y = x - y; // = (x + y) - y = x x = x - y; // = (x + y) - x = y&#125;利用「加减」来交换变量的方法已经很巧妙了，可是当 x + y 的值超出 int 能表示的数值范围（溢出）时，会出错。函数声明：方法 2 - 位操作123456void swap2(int &amp;x, int &amp;y) &#123; // 因为 x ^ x = 0，0 ^ x = x 且 x ^ y ^ z = x ^ z ^ y（交换率） x = x ^ y; // 所以： y = x ^ y; // = (x ^ y) ^ y = x ^ (y ^ y) = x ^ 0 = x x = x ^ y; // = (x ^ y) ^ x = (x ^ x) ^ y = 0 ^ y = y&#125;利用更精妙的「位操作」方法，可以完美解决这个问题！而且还特别好记，因为每一步都是 x ^ y。测试代码1234567891011121314151617x = 12;y = 34;l("initial state")v(x)v(y)swap0(x, y);l("after swap0()")v(x)v(y)swap1(x, y);l("after swap1()")v(x)v(y)swap2(x, y);l("after swap2()")v(x)v(y)输出123456789101112initial state x = 12 y = 34after swap0() x = 34 y = 12after swap1() x = 12 y = 34after swap2() x = 34 y = 12但是我们必须要知道：在其它语言里，有更直接的变量交换方法。在 Python 中变量的方法1234x = 12y = 34x, y = y, x // 一定程度上解放了脑力print(x, y)输出134 12后记程序源文件附件：CMakeLists.txtprint_tools.hmain.cpp发到七牛云存储之后，才想起来用 GitHubGist 更方便:cpp_macro_and_bit_operations。重做这些老题目，需要不到一整天的时间；但是将这些解答输出成本文，却需要超过一天。于是，我面临这样一个纠结的问题：从个人角度来看，到底值不值得将它们写成博文？其实，在写本文之前、思考解题的过程中，我已经写了足以让自己理解、可用于复习的相关笔记和代码。如果要写这样一篇博文，当然要以「别人也能看得懂」为标准来认真地写，写得足够条理清晰。这样一来，就比写个人笔记更费神费时得多了。当然，写作的过程中，我复习了相关的知识点，再一次理清了自己的思路，增进了理解（还给他人分享了经验）。但是，我与其付出整整一天的时间和精力去复习总结这些内容，好像还不如继续深入学习其它知识。我纠结了。根据以往经验，我倾向于认为：不值得这么做。至少不应该急着写。应该隔一段时间，遗忘曲线下行之后再写，可以更好地增进记忆效果了。这次就算了。接下来，我要试着一直学下去，先不写总结归纳的文章，看学习效果是不是更好。吐槽：这种「自学」方面的实验，本来学生时代就该做了。如果当年一早搞清楚怎样的学习方法更适合自己，然后又快又好地进步，或许现在就不会活得那么窘迫了。（提醒自己：不要再埋怨了，不要埋怨，不要埋怨……）]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 快速入门]]></title>
    <url>%2Fpython%2Fquick_start%2F</url>
    <content type="text"><![CDATA[内容：《廖学峰的 Python 教程》笔记的再整理；本文由一些简单的说明、Python3 代码及其运行结果组成。定位：查阅自己的笔记来回忆遗忘的 Python3 用法（因为我不常用 Python）；让不会 Python3 但已经学会其它编程语言的人，在阅读本文后，可以简单上手使用它。工具：笔记内容由 Jupyter（交互式的编程笔记）写就，以 Markdown 格式导出，并发布为本文。基础Python 代码文件后缀是 *.py在 Python 代码文件首行的「文件编码声明」如下：1# -*- coding: utf-8 -*-注释1# 单行注释1234567# 以下是 多行字符的写法'''多行字符串首行严格来说 Python 没有专用的多行注释符。不过可以利用「多行字符串」的写法，来进行「多行代码的注释」。多行字符串末尾'''&apos;多行字符串首行\n严格来说 Python 没有专用的多行注释符。\n不过可以利用「多行字符串」的写法，\n来进行「多行代码的注释」。\n多行字符串末尾&apos; 变量123# 常量：命名全大写PI = 3.1415926PI3.1415926 12# 字符串'字符串'&apos;字符串&apos; 1"\t转义\\字符串\n"&apos;\t转义\\字符串\n&apos; 运算12# 与True and FalseFalse 12# 或True or FalseTrue 12# 非not FalseTrue 12# 除法10 / 33.3333333333333335 12# 整除10 // 33 12# 取余10 % 31 简单的 IO12# 输入name = input()test_input 12# 输出print(name)test_input 1234lines = '''line0line1line2'''print(lines)line0 line1 line2 字符串 str12# 字符编码ord('A')65 12# 中文字符编码ord('中')20013 12# 转义字符串'\u4e2d\u6587'&apos;中文&apos; 12# 编码转换'ABC'.encode('ascii') # 输出的 `b'…'` 其中的 b 代表数据类型为 bytesb&apos;ABC&apos; 12# 中文编码转换'中文'.encode('utf-8')b&apos;\xe4\xb8\xad\xe6\x96\x87&apos; 1'中文'.encode('GBK')b&apos;\xd6\xd0\xce\xc4&apos; 1'中文'.encode('ascii')--------------------------------------------------------------------------- UnicodeEncodeError Traceback (most recent call last) &lt;ipython-input-56-b318511b2a75&gt; in &lt;module&gt;() ----&gt; 1 &apos;中文&apos;.encode(&apos;ascii&apos;) UnicodeEncodeError: &apos;ascii&apos; codec can&apos;t encode characters in position 0-1: ordinal not in range(128) 12# 解码b'ABC'.decode('utf-8')&apos;ABC&apos; 12# 中文解码b'\xd6\xd0\xce\xc4'.decode('gbk')&apos;中文&apos; 12# 字符串长度len('ABC')3 12# 中文字符串长度len('中文')2 12# 中文字符串转码后的长度len('中文'.encode('utf-8'))6 字符串输出格式化12# %d 整数'%2d-%02d' % (3, 5)&apos; 3-05&apos; 12# %f 浮点数'%.2f' % PI&apos;3.14&apos; 12# %s 字符串'Age: %s' % 25&apos;Age: 25&apos; 12# %x 十六进制整数'%x' % 43&apos;2b&apos; 12# 输出格式为 'xx.x%'"%.1f%%" % 72&apos;72.0%&apos; 12# 字符串的单个字符替换'abcba'.replace('a', 'A')&apos;AbcbA&apos; 列表 list123# 列表 listlist1 = ['0', 'a1', '2b', '3c']list1[&apos;0&apos;, &apos;a1&apos;, &apos;2b&apos;, &apos;3c&apos;] 12# 列表长度len(list1)4 12# 索引（下标）访问list1[0]&apos;0&apos; 1list1[2]&apos;2b&apos; 12# 越界访问list1[4]--------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-33-895f56fd4693&gt; in &lt;module&gt;() 1 ## 越界访问 ----&gt; 2 list1[4] IndexError: list index out of range 12# 负数索引访问list1[-1]&apos;3c&apos; 123# 追加一个元素list1.append('last_elem')list1[&apos;0&apos;, &apos;a1&apos;, &apos;2b&apos;, &apos;3c&apos;, &apos;last_elem&apos;] 123# 插入一个元素list1.insert(1, 'insert_elem')list1[&apos;0&apos;, &apos;insert_elem&apos;, &apos;a1&apos;, &apos;2b&apos;, &apos;3c&apos;, &apos;last_elem&apos;] 123# 删除一个列表末尾的元素list1.pop()list1[&apos;0&apos;, &apos;insert_elem&apos;, &apos;a1&apos;, &apos;2b&apos;, &apos;3c&apos;] 123# 删除一个指定位置的元素list1.pop(1)list1[&apos;0&apos;, &apos;a1&apos;, &apos;2b&apos;, &apos;3c&apos;] 123# 替换一个指定位置的元素list1[2] = '233'list1[&apos;0&apos;, &apos;a1&apos;, &apos;233&apos;, &apos;3c&apos;] 123# 元素类型混合的列表mix_list = ['Apple', 1.1, True, 4]mix_list[&apos;Apple&apos;, 1.1, True, 4] 1234# 列表嵌套aList = [1, 2, 3]bList = ['a', aList, 'c']bList[&apos;a&apos;, [1, 2, 3], &apos;c&apos;] 1234# 列表排序l1 = ['c', 'a', 'b']l1.sort() # 字典序l1[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 元组 tuple123# 元组 tuplet1 = (1, 2, 3)t1(1, 2, 3) 12# 元组元素不可变t1[1] = '0'--------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-11-000b1c67bf12&gt; in &lt;module&gt;() 1 # 元组元素不可变 ----&gt; 2 t1[1] = &apos;0&apos; TypeError: &apos;tuple&apos; object does not support item assignment 123# 单个元素的元组t2 = (2) # 错误的声明方式t22 12t2 = (1,) # 正确的声明方式：`,` 逗号用于消除歧义t2(1,) 123# “可变”的元组t3 = ('a', 'b', ['A', 'B'])t3(&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) 1234# 修改“可变”的元组：实际只是修改元组中的某个（可变的）列表而已t3[2][0] = 'X't3[2][1] = 'Y't3(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 语句12345678910# 条件语句age = 20if age &gt;= 18: # 不能忘了写冒号 print('adult')elif age&gt;= 6: # 条件分支 print('teenager')else: # 最后的默认分支 print('kid')adult 123456# 循环语句names = ['Apple', 'Boy', 'Cat']for name in names: # for 循环 print(name)Apple Boy Cat 1234567# 循环求和sum = 0for x in [1, 2, 3]: sum += xsum6 12345678sum = 0n = 99while n &gt; 0: # while 循环 sum += n n = n - 2sum2500 123# 整数列生成：range()r = range(5)rrange(0, 5) 12#（将正数列）转换为列表：list()list(r)[0, 1, 2, 3, 4] 字典 dict123# 字典 dictd1 = &#123;'Alice': 95, 'Bob': 75, 'Cat': 85&#125;d1{&apos;Alice&apos;: 95, &apos;Bob&apos;: 75, &apos;Cat&apos;: 85} 123# 添加元素（键值对 key-value pair）到字典d1['Ice'] = 90d1{&apos;Alice&apos;: 95, &apos;Bob&apos;: 75, &apos;Cat&apos;: 85, &apos;Ice&apos;: 90} 12# 访问不存在的元素d1['2B']--------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-21-8e60e5923ffc&gt; in &lt;module&gt;() 1 # 访问不存在的元素 ----&gt; 2 d1[&apos;2B&apos;] KeyError: &apos;2B&apos; 12# 判断字典是否存在某个元素（键 key）'Hero' in d1False 12# 字典某个元素不存在时，返回自定义的默认值d1.get('Hero', -1)-1 12# 删除一个字典元素d1.pop('Ice') # 这时会返回这个元素的值90 集合 set12345# 集合 set# 集合是一个 key（键）的集合，不存储 value（值）s1 = set([1, 2, 3]) # 传入的参数是列表，用于初始化s1{1, 2, 3} 123# 没有重复的 keys1 = set([1, 1, 1, 2, 2, 3, 3]) # 重复的 key 会被合并s1{1, 2, 3} 123# 添加一个元素s1.add(4)s1{1, 2, 3, 4} 123# 无法重复添加相同的元素s1.add(4)s1{1, 2, 3, 4} 123# 删除一个元素s1.remove(4)s1{1, 2, 3} 123# 准备（集合运算）s2 = set([2, 3, 4])s2{2, 3, 4} 12# 集合的交集s1 &amp; s2{2, 3} 12# 集合的并集s1 | s2{1, 2, 3, 4} 函数 function内置函数 build-in12# 绝对值abs(-100)100 12# 最大值max(1, 3, 2)3 1234# 类型转换## 整数int('123')123 1int(1.23)1 12## 浮点数float('12.3')12.3 12## 字符串str(123)&apos;123&apos; 12## 布尔bool(1)True 1bool('')False 12## 非零即 Truebool(-1)True 自定义函数12345678# 自定义函数def my_abs(x): if x &gt;= 0: return x else: return -xmy_abs(-1)1 12# 语句「跳过」pass12345## 什么也不做的函数def nop(): passnop()12345## 什么也不做的分支if age &gt;= 1: passelse: # 缺少了 pass 的空分支会报错 File &quot;&lt;ipython-input-52-597539bfdf28&gt;&quot;, line 5 # 缺少了 pass 的空分支会报错 ^ SyntaxError: unexpected EOF while parsing 12345678910111213# 函数参数的类型检查def my_abs(x): #### 类型检查的语法 isinstance(…) if not isinstance(x, (int, float)): #### 报参数错误 raise TypeError('bad oprand type') if x &gt;= 0: return x else: return -xmy_abs('12')--------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-53-01e3e9adef36&gt; in &lt;module&gt;() 11 return -x 12 ---&gt; 13 my_abs(&apos;12&apos;) &lt;ipython-input-53-01e3e9adef36&gt; in my_abs(x) 4 if not isinstance(x, (int, float)): 5 #### 报参数错误 ----&gt; 6 raise TypeError(&apos;bad oprand type&apos;) 7 8 if x &gt;= 0: TypeError: bad oprand type 12# 导入编程模块import math # 导入 math 包，其中包含 `sin()` 与 `cos()` 函数12345678# 多个返回值def move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y = step * math.sin(angle) return nx, nymove(100, 100, 60, math.pi / 6) # 实际上返回值是元组(151.96152422706632, 29.999999999999996) 123# `x, y = …` 的赋值方式可以分别按序获得函数返回的元组中的各个元素x, y = move(100, 100, 60, math.pi / 6)x151.96152422706632 1y29.999999999999996 函数参数123456789# 函数参数def power(x, n): # 多个函数参数 s = 1 while n &gt; 0: n -= 1 s = s * x return spower(2, 3)8 12# 缺失参数报错power(2)--------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-68-c11c9f54ebfc&gt; in &lt;module&gt;() 1 # 缺失参数报错 ----&gt; 2 power(2) TypeError: power() missing 1 required positional argument: &apos;n&apos; 默认参数 default param12345678910# 默认参数 default param：也可以称为缺省参数def power(x, n=2): # 必选参数必须在默认参数之前 s = 1 while n &gt; 0: n -= 1 s = s * x return spower(2)4 123456# 注意：默认参数的一个 bug（错用）def add_end(L=[]): L.append('END') return Ladd_end() # 1st output[&apos;END&apos;] 1add_end() # 2nd[&apos;END&apos;, &apos;END&apos;] 1add_end() # 3rd[&apos;END&apos;, &apos;END&apos;, &apos;END&apos;] 12345678# 避免上述默认参数问题的方法def add_end(L=None): if L is None: L = [] L.append('END') return Ladd_end() # 1st[&apos;END&apos;] 1add_end() # 2nd 仍然正确[&apos;END&apos;] 可变参数123456789# 可变参数def sum(nums): # 一般的函参写法（函参 = 函数参数） sum = 0 for x in nums: sum += x return sumsum([1, 2, 3])# 一般的函参调用方式：用列表作为函参6 1sum((1, 2, 3)) # 用元组作为函参6 12345678# 多函参的调用方式！def sum(*nums): sum = 0 for x in nums: sum += x return sumsum(1, 2, 3) # 三个函参6 1sum(1, 2, 3, 4) # 四个函参10 关键字参数12345678# 关键字参数## 可变参数，将传入的函参组装成元组 tuple## 关键字参数，则将它们组装成字典 dictdef person(name, age, **kw): print('name:', name, 'age:', age, 'others:', kw)person('Ice', 24)name: Ice age: 24 others: {} 1person('IceHe', 25, city='Beijing')name: IceHe age: 25 others: {&apos;city&apos;: &apos;Beijing&apos;} 1person('IceHe', 25, city='Beijing', job='Engineer')name: IceHe age: 25 others: {&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;} 12345# 限制关键字参数的名字def person(name, age, *, city, job): # 简化写法！ print(name, age, city, job)person('Alice', '12', 'beijing', 'student') # 错误用法--------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-88-e06e0578d736&gt; in &lt;module&gt;() 3 print(name, age, city, job) 4 ----&gt; 5 person(&apos;Alice&apos;, &apos;12&apos;, &apos;beijing&apos;, &apos;student&apos;) # Error TypeError: person() takes 2 positional arguments but 4 were given 1person('Alice', '12', city='beijing', job='student') # 正确用法Alice 12 beijing student 参数组合1234567# 参数组合## 参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = {&apos;x&apos;: 99} 1234def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = {&apos;ext&apos;: None} 1234# 通过 tuple 和 dict 也可以调用上述函数args = (1, 2, 3, 4)kw = &#123;'d': 88, 'x': '#'&#125;f1(*args, **kw) ##### 不要漏掉 `*` 和 `**`a = 1 b = 2 c = 3 args = (4,) kw = {&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;} 12args = (1, 2, 3)f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = {&apos;x&apos;: &apos;#&apos;} 递归函数1234567# 递归函数def factorial(n): if n == 1: return 1 return n * factorial(n - 1)factorial(5)120 12# 递归嵌套过深导致栈溢出factorial(1000)--------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-95-e1ef40be0628&gt; in &lt;module&gt;() 1 # 递归嵌套过深导致栈溢出 ----&gt; 2 factorial(1000) NameError: name &apos;factorial&apos; is not defined 123456789# 尾递归（优化内存使用）def factorial2(n, p=1): if n == 1: return p # （尾递归的）思路：将中间结果先计算出来，再返回去！就可以减少使用的栈空间（只用一个栈帧） return factorial2(n - 1, n * p)# 虽然已经使用了尾递归的写法，可是 Python 编译器没有做相关优化，所以还是会栈溢出factorial2(1000)--------------------------------------------------------------------------- RecursionError Traceback (most recent call last) &lt;ipython-input-98-354f146d0995&gt; in &lt;module&gt;() 7 8 # 虽然已经使用了尾递归的写法，可是 Python 编译器没有做相关优化，所以还是会栈溢出 ----&gt; 9 factorial2(1000) &lt;ipython-input-98-354f146d0995&gt; in factorial2(n, p) 4 return p 5 # （尾递归的）思路：将中间结果先计算出来，再返回去！就可以减少使用的栈空间（只用一个栈帧） ----&gt; 6 return factorial2(n - 1, n * p) 7 8 # 虽然已经使用了尾递归的写法，可是 Python 编译器没有做相关优化，所以还是会栈溢出 ... last 1 frames repeated, from the frame below ... &lt;ipython-input-98-354f146d0995&gt; in factorial2(n, p) 4 return p 5 # （尾递归的）思路：将中间结果先计算出来，再返回去！就可以减少使用的栈空间（只用一个栈帧） ----&gt; 6 return factorial2(n - 1, n * p) 7 8 # 虽然已经使用了尾递归的写法，可是 Python 编译器没有做相关优化，所以还是会栈溢出 RecursionError: maximum recursion depth exceeded in comparison 12345678# 教程中原来的尾递归写法（以上是我自己的写法）def fact(n): return fact_iter(n, 1)def fact_iter(n, p): if n == 1: return p return fact_iter(n - 1, n * p)切片123# 准备切片素材L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']L[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;] 12# 取前 3 个元素[L[0], L[1], L[2]] # 笨拙的写法[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 12# 快捷的写法：切片！L[:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 12# L[:3] 等价于以下写法L[0:3][&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 12# 切片第一个参数「起始索引」！（参数由 `:` 分隔）L[1:3] # 即从第几个元素开始切[&apos;Sarah&apos;, &apos;Tracy&apos;] 12# 从倒数的索引开始切片L[-2:][&apos;Bob&apos;, &apos;Jack&apos;] 12# 切片第二个参数「末尾索引」！L[-2:-1] # 体会它与 `L[-2:]` 的区别：不包括末尾索引位置的那个元素！[&apos;Bob&apos;] 123# 切片第三个参数「索引步长」！L = list(range(10)) # 复习：整数列生成L[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 1L[::2] # 每两个元素中取一个元素[0, 2, 4, 6, 8] 1L[::-2] # 负的步长 -&gt; 倒序取元素！[9, 7, 5, 3, 1] 12# 复制列表L[:][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 1L.copy() # 另一种复制方法[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 12# 元组切片tuple(range(10))[:3](0, 1, 2) 12# 字符串切片'ABCDEFG'[:3]&apos;ABC&apos; 1'ABCDEFG'[::3]&apos;ADG&apos; 迭代 iterate123456# 迭代d = &#123;'a': 1, 'b': 2, 'c': 3&#125;for k in d: # 单个参数只能获取到元组的键（key） print(k)a b c 12for k, v in d: # 两个参数也不能正确地分别获取到元组的键值对（key 和 value） print(k, v)--------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-131-106ecdc04604&gt; in &lt;module&gt;() ----&gt; 1 for k, v in d: # 两个参数也不能正确地分别获取到元组的键值对（key 和 value） 2 print(k, v) ValueError: not enough values to unpack (expected 2, got 1) 123# 直接获取元组的 value 的写法：`*.values()`for v in d.values(): print(v)1 2 3 123# 正确获取元组的 key =&gt; value 的写法：`*.items()`for k, v in d.items(): print(k, '=&gt;', v)a =&gt; 1 b =&gt; 2 c =&gt; 3 123# 字符串迭代for c in 'ABC': print(c)A B C 对象可否迭代 Iterable1234# 判断对象是否可迭代？from collections import Iterable # 只导入特定包中的需要用到的特定对象isinstance('abc', Iterable)True 1isinstance([1, 2, 3], Iterable)True 1isinstance(123, Iterable)False 123# `enumerate()` 函数，将列表变成 key-value pairfor i, v in enumerate(['A', 'B', 'C']): print(i, '=&gt;', v)0 =&gt; A 1 =&gt; B 2 =&gt; C 123# 同时引用两个变量for x, y in [(1, 1), (2, 4), (3, 9)]: print(x, '=&gt;', y)1 =&gt; 1 2 =&gt; 4 3 =&gt; 9 列表生成式 range123# 列表生成式r = range(1, 11)rrange(1, 11) 1list(r) # 然后用 `list()` 转换为真正的列表[0, 1, 2, 3, 4] 12345678# 如何获得列表 [1*1, 2*2, …, n*n]## 笨拙的写法L = []for x in range(1, 11): L.append(x * x)L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 12## 便捷的写法：列表生成式！[x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 12# 多重循环（一般很少用到三重甚至三重以上的循环）[m + n for m in 'ABC' for n in 'XYZ'][&apos;AX&apos;, &apos;AY&apos;, &apos;AZ&apos;, &apos;BX&apos;, &apos;BY&apos;, &apos;BZ&apos;, &apos;CX&apos;, &apos;CY&apos;, &apos;CZ&apos;] 1[x * y for x in range(1, 4) for y in range(1, 4)][1, 2, 3, 2, 4, 6, 3, 6, 9] 列表生成式的应用1234# 例子：列出目录文件import os # 导入 os 包（模块），用途暂略[d for d in os.listdir('.')][&apos;.ipynb_checkpoints&apos;, &apos;Fabonacci.ipynb&apos;, &apos;python3.ipynb&apos;] 1234# 多个参数的列表生成式d = &#123;'x': 'A', 'y': 'B', 'z': 'C'&#125;[k + '=' + v for k, v in d.items()][&apos;x=A&apos;, &apos;y=B&apos;, &apos;z=C&apos;] 123# 例子：字符串转换为小写strs = ['Hello', 'World', 'IBM', 'Apple'][s.lower() for s in strs][&apos;hello&apos;, &apos;world&apos;, &apos;ibm&apos;, &apos;apple&apos;] 生成器 generator12345# 生成器 generator## 对比「列表生成器」L = [x * x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] 123## 「生成器」只在有需要时，才会计算下一个需要获取的值！g = (x * x for x in range(10)) # Lazy Calculationg&lt;generator object &lt;genexpr&gt; at 0x102e98360&gt; 1next(g) # 1st0 1next(g) # 2nd1 1next(g) # 3rd4 123# 用循环语句从生成器获取值（因为用 `next(generator)` 不够方便）for n in g: print(n)9 16 25 36 49 64 81 12345678910# 例子：斐波拉契数列def fibonacci(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n += 1 return 'done'fibonacci(7)1 1 2 3 5 8 13 &apos;done&apos; 说明：多变量赋值语句a, b = b, a + b等价于123t = (b , a + b)a = t[0]b = t[1]yield123456789# yielddef odd(): print('step 1') yield 1 # yield 是相对于 return 的存在 print('step 2') yield 3 print('step 3') yield 5123o = odd()next(o) # 1ststep 1 1 1next(o) # 2ndstep 2 3 1next(o) # 3rdstep 3 5 1next(o) # error：StopIteration--------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &lt;ipython-input-176-97e97a5e3d6b&gt; in &lt;module&gt;() ----&gt; 1 next(o) # error：StopIteration StopIteration: 1234567891011# 对 StopIteration 的错误捕获g = fibonacci(6)while True: try: x = next(g) print('g:', x) except StopIteration as e: print('Generator return value:', e.value) break1 1 2 3 5 8 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-177-1ce57457c858&gt; in &lt;module&gt;() 5 while True: 6 try: ----&gt; 7 x = next(g) 8 print(&apos;g:&apos;, x) 9 except StopIteration as e: TypeError: &apos;str&apos; object is not an iterator 生成器的应用1234567891011121314151617181920212223242526# 例子：杨辉三角def triangles(): yield [1] L = [1, 1] yield L cnt = 2 while True: tmpL = [1] i = 1 while i &lt; cnt: tmpL.append(L[i - 1] + L[i]) i += 1 tmpL.append(1) L = tmpL cnt += 1 yield tmpLn = 0for t in triangles(): print(t) n += 1 if n == 10: break[1] [1, 1] [1, 2, 1] [1, 3, 3, 1] [1, 4, 6, 4, 1] [1, 5, 10, 10, 5, 1] [1, 6, 15, 20, 15, 6, 1] [1, 7, 21, 35, 35, 21, 7, 1] [1, 8, 28, 56, 70, 56, 28, 8, 1] [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 迭代器 Iterator可以用 for 遍历的数据类型集合数据类型：list, tuple, dict, set, strgenerator：生成器和带 yield 的 generator function1234# 判断可否迭代from collections import Iterableisinstance([], Iterable)True 1isinstance(&#123;&#125;, Iterable)True 1isinstance('abc', Iterable)True 1isinstance((x for x in range(10)), Iterable)True 1isinstance(100, Iterable)False 生成器可以用 next() 不断调用并返回下一个值，直到最后抛出 StopIteration可以被 next() 调用，不断返回下一个值的对象称为迭代器1234# 判断是否是一个 Iteratorfrom collections import Iteratorisinstance((x for x in range(10)), Iterator)True 1isinstance([], Iterator)False 1isinstance(&#123;&#125;, Iterator)False 1isinstance('abc', Iterator)False 123# list, dict, str 等是 Iterable 但不是 Iterator 的对象可以通过 `iter()` 获得一个对应 Iterator 的对象for x in list(range(1, 6)): print(x)1 2 3 4 5 12345678# 以下代码等价于以上代码it = iter(list(range(1, 6)))while True: try: print(next(it)) except StopIteration: break1 2 3 4 5 高阶函数12# 函数对象abs&lt;function abs&gt; 123# 将函数签名赋值给变量f = absf&lt;function abs&gt; 12# 用函数签名调用函数f(-10)10 12345# 简单的高阶函数def add(x, y, f): return f(x) + f(y)add(-5, 6, f)11 map &amp; reducemap1234567# Python 内建 `map()` &amp; `reduce()`def f(x): return x * x# mapm = map(f, range(1, 10))m&lt;map at 0x102e402e8&gt; 1list(m)[1, 4, 9, 16, 25, 36, 49, 64, 81] 1234567# 以上的 map 写法等价于以下的循环写法L = []for x in range(1, 10): L.append(f(x))L[1, 4, 9, 16, 25, 36, 49, 64, 81] 1list(map(str, range(1, 10)))[&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;] reduce1234567# reducefrom functools import reducedef add(x, y): return x + yreduce(add, list(range(1, 10))[::2]) # [1, 3, 5, 7, 9]25 12345678# reduce 的应用：将字符串 str 转换为整数 intdef fn(x, y): return x * 10 + ydef char2num(ch): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ch]reduce(fn, map(char2num, '13579'))13579 123456789# 以上代码可以整理起来def s2i(s): def fn(x, y): return x * 10 + y def char2num(ch): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ch] return reduce(fn, map(char2num, s))s2i('24680')24680 组合应用利用 map() 函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]输出：[‘Adam’, ‘Lisa’, ‘Bart’]1234def formatStr(s): return s[0].upper() + s[1:].lower()list(map(formatStr, ['adam', 'LISA', 'barT']))[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 编写一个 prod() 函数，可以接受一个 list 并利用 reduce() 求积。（Python 提供的 sum() 函数可以接受一个 list 并求和）12345678from functools import reducedef prod(nums): def product(x, y): return x * y return reduce(product, nums)prod(list(range(1, 5)))24 编写一个 str2float() 函数，把字符串 ‘123.456’ 转换成浮点数 123.456。12345678910111213141516171819from functools import reducedef str2float(s): def char2num(ch): return &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;[ch] def toDecimal(s): def x10(x, y): return x * 10 + y return reduce(x10, map(char2num, s)) result = list(map(toDecimal, s.split('.'))) while result[1] &gt; 1: result[1] /= 10 return result[0] + result[1]str2float('123.456')123.456 filter1234def isOdd(n): return n % 2 == 1list(filter(isOdd, [1, 2, 4, 5, 6, 9, 10, 15]))[1, 5, 9, 15] 1234def notEmpty(s): return s and s.strip()list(filter(notEmpty, ['A', '', 'B', None, 'C', ' ']))[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] 用 filter 求素数123456789101112131415161718192021222324# 埃氏筛法：http://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E8%89%B2%E5%B0%BC%E7%AD%9B%E9%80%89%E6%B3%95def oddIter(): n = 1 while True: n = n + 2 yield ndef notDivisible(n): return lambda x: x % n &gt; 0def primes(): yield 2 it = oddIter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(notDivisible(n), it)for n in primes(): if n &lt; 100: print(n) else: break2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 回数是指从左向右读和从右向左读都是一样的数，例如12321，909。请利用filter()滤掉非回数：123456789def isPalindrome(n): ns = str(n) # ns -&gt; num_str while ns is not '': if ns[0] is not ns[-1]: return False ns = ns[1:-1] return Truelist(filter(isPalindrome, range(1, 1000)))[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999] sortd1sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 1sorted([36, 5, -12, 9, -21], key=abs) # 高阶函数，自定义排序[5, 9, -12, -21, 36] 1sorted(['bob', 'about', 'Zoo', 'Credit']) # 字典序[&apos;Credit&apos;, &apos;Zoo&apos;, &apos;about&apos;, &apos;bob&apos;] 1sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) # 忽略大小写[&apos;about&apos;, &apos;bob&apos;, &apos;Credit&apos;, &apos;Zoo&apos;] 1sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) # 倒序[&apos;Zoo&apos;, &apos;Credit&apos;, &apos;bob&apos;, &apos;about&apos;] 假设我们用一组 tuple 表示学生名字和成绩：请用 sorted() 对其分别按名字排序：123456L = [('Bob', 75), ('Adam', 92), ('Bart', 66), ('Lisa', 88)]def byName(t): return t[0]sorted(L, key=byName)[(&apos;Adam&apos;, 92), (&apos;Bart&apos;, 66), (&apos;Bob&apos;, 75), (&apos;Lisa&apos;, 88)] 再按成绩从高到低排序：1234def byScore(t): return t[1]sorted(L, key=byScore, reverse=True)[(&apos;Adam&apos;, 92), (&apos;Lisa&apos;, 88), (&apos;Bob&apos;, 75), (&apos;Bart&apos;, 66)] 函数式编程（其它）函数作为返回值12345678910def lazySum(*args): def sum(): ax = 0 for n in args: ax += n return ax return sumf = lazySum(1, 3, 5, 7, 9)f&lt;function __main__.lazySum.&lt;locals&gt;.sum&gt; 1f()25 1234f1 = lazySum(1, 3, 5, 7, 9)f2 = lazySum(1, 3, 5, 7, 9)f1 == f2False 闭包123456789101112# 错误示范def count(): fs = [] for i in range(1, 4): def f(): return i * i fs.append(f) return fsf1, f2, f3 = count()f1()9 1f2()9 1f3()9 1234567891011121314151617# 正确用法def count(): def f(j): def g(): return j * j return g fs = [] for i in range(1, 4): fs.append(f(i)) return fs# 返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。如果一定要引用循环变量怎么办？# 方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。f1, f2, f3 = count()f1()1 1f2()4 1f3()9 1234567891011121314# 正确用法def count(): def f(j): def g(): return j * j return g fs = [] for i in range(1, 4): fs.append(f(i)) return fsf1, f2, f3 = count()f1()1 匿名函数1list(map(lambda x: x * x, range(1, 10)))[1, 4, 9, 16, 25, 36, 49, 64, 81] 123456def f(x): return x * x# 等价于lambda x: x * x&lt;function __main__.&lt;lambda&gt;&gt; 装饰器12345def now(): print('2017-04-22')f = nowf()2017-04-22 12# 获取函数的名字now.__name__&apos;now&apos; 1f.__name__&apos;now&apos; 增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator1234567891011def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2017-04-22')now()call now(): 2017-04-22 以上包装器的写法，等价于以下代码1now = log(now)12345678910111213def log(text): def decorator(func): def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log('execute')def now(): print('2017-04-22')now()execute now(): 2017-04-22 以上包装器的写法，等价于以下代码1now = log('execute')(now)但是以上的写法有个缺点1now.__name__ # 函数名字就成了 wrapper，而不是原来的 now&apos;wrapper&apos; 123456789101112131415# 用 functools.wraps(func) 来修正import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper@logdef now(): print('2017-04-22')now()call now(): 2017-04-22 偏函数1int('12345')12345 1int('12345', base=8) # 8 进制转 10 进制5349 1int('AE', 16) # 16 进制转 10 进制174 1234def int2(x, base=2): return int(x, base)int2('1000000')64 1int2('1010101')85 以上 int2() 声明的代码与一下代码等价123int2 = functools.partial(int, base=2)int2('10010')18 又相当于12kw = &#123;'base': 2&#125;int('10010', **kw)18 123max2 = functools.partial(max, 10)max2(5, 6, 7)10 以上代码相当于12args = (10, 5, 6, 7)max(*args)10 模块12345678910111213import sysdef test(): args = sys.argv if len(args) == 1: print('Hello, world!') elif len(args) == 2: print('Hello, %s!' % args[1]) else: print('Too many arguments!') print(args)test()Too many arguments! [&apos;/usr/local/lib/python3.6/site-packages/ipykernel/__main__.py&apos;, &apos;-f&apos;, &apos;/Users/IceHe/Library/Jupyter/runtime/kernel-f9ae0017-3106-4f62-8484-4df0beb75b9d.json&apos;] 1__name__&apos;__main__&apos; 1__doc__&apos;Automatically created module for IPython interactive environment&apos; 最后参考《廖学峰的 Python 教程》直接访问原教程，学习后续的部分 《使用模块》]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 春]]></title>
    <url>%2Fthink%2F2017_spring%2F</url>
    <content type="text"><![CDATA[颜狗碰到那些公开自称是「颜狗」的人，我也不知道该持怎样的态度，不敢说「你真坦率」，我只能说「人艰不拆」。即使只是偶然听到他人对这方面的八卦议论，我也会感到无比尴尬。（你猜我是不是颜狗？）想像一个发好人卡的场景「你是个好男生，可是我太漂亮了，你配不上。」我觉得这话挺阴暗的。人一般为了避免冲突（日后好相见），都会说「你是个好人」，但并不说穿真实的理由（当然这个理由不一定就是这里说到的那些略显阴暗的理由）。本段文字仅仅讨论「颜狗」这一主题，完全忽略「看脸」之外的其它因素的影响。放弃为了潜在的恋爱对象维持正面形象的努力，即是自我放弃了。我已经自我放弃很久了，我想试试重拾自己的形象？笑。自私跟一个刚分手的朋友吃饭聊天，联想到了一些东西。我自己是一个挺「自私」的人，承认自己没有「肉包子打狗」（舍得、不吝啬）的气派，也不想把妹，你猜是不是因为酸葡萄心理？浅尝辄止、三不主义的做法，把不到妹很正常。也可能是还没有碰到一个所谓的能让人豁出去的「真爱」？工作、休闲、财货勉强略有盈余，过好自己就很不错了，再多一个人就难说了。如果要为了不再一个人牺牲太多去勉强凑合，宁可就此作罢。没有多少人愿意忍受生活质量下降太多（虽然其实人能够适应），我会想：要是两个人一起生活没有变得更好，还在一起干嘛呢？当然这是心态问题，一旦恋过，可能那就变成了生活必需品，单着的人反而能够一直单下去。爱的等价交换学生时代，觉得付出一份爱，才会得到一份爱，但是不愿意付出太多。后来才发现，付出很多爱，才能得到一些爱的回报，甚至只有一点点。可惜我现在依然那么自私。我讨厌别人“那样”对待自己，却偶然发现自己也会以类似的方式对待他人，这何其残忍。人平常会高看自己，直到看到了自己的阴暗、自私、愚蠢的行径，才发现自己如此不堪。就好像现实中的努力，说是一分耕耘一分收获，但是对于一般人来说，更通常的情况是十分耕耘，才一两分收获。没有天赋异能，没有家底、才华、外貌、身段，没有成就、影响力，只能靠「搬砖」勉力生存。我真的不敢告诉你「我喜欢你」。女神还是活在心中好了，不能得到才能称之为女神。碎碎念吃多少才够从小形成「不浪费食物」的习惯，得到的食物无论多少，我都会下意识地尽量吃完。绝大多数情况下，我都能吃完，可是我现在越发搞不清楚自己合适的进食量是多少了，甚是忧心。以前运动量大还好，可以消耗掉多余的热量，现在运动量小了，还吃那么多就不行了！今天我试着吃少点，当时我也确实能感觉自己饱了，但判断不了饱腹感能持续多久，能不能撑到下一餐。我觉得自己还能继续吃，然而理智让我少吃点，情感和理智在打架……最近也终于把所有剩余的速溶咖啡和零食都消耗完了。这几个月来，已经比过去增重6斤…… 春节已经过去这么久了，体重也没有恢复的迹象，真是玩大了。少吃多动，真是至理名言。强迫症混乱是必然的，自然的总体趋向是「熵增」。想要整洁，少不了「做功」，过度整理的投入通常非常不值。大多数的待办事项、书单、文章，它们都毫无意义…… 它们通常会一直沉睡在哪里，直到堆积如山，然后你终于意识到自己不曾读完过甚至不曾打开过它们。我有一点点不一样，会花很多时间去读完这些收藏的文章、资料，然后它们的结局还是「被删掉」。时间太少，我只能囫囵吞枣地读完就算了。这中事情永远不可能有尽头，只是觉得文章有趣、有用，头脑一热，就收藏了；后来发觉它们的价值并没有想像中那么大，我竟然还不及时地放弃沉没成本，而是去把它们看完了，看完，完…… 收集癖、强迫症不可取。谁叫我蠢啊我承认自己确实是一个不怎么聪明的人（宛如智障），没什么不好意思的，毕竟这是事实。像个机器一样，重复着暂时 AI 还做不了却着实无趣的工作，所以这被程序员们戏称为“搬砖”。我也已经很久没有好好动过脑了，业余生活继续放任自流，都快不记得思考的乐趣是怎样的了。今天（2017-04-16）偶然碰上一道（不难的）编程题，竟然突然回想起了当年高三备考时刷题的感觉，专注、充实而愉悦，这种「心流」的感觉真是久违了。一些知识领域，只要抓住要点去做，循序渐进（避免过度的挫折），能够不断获得智识上的乐趣。重新发现思考的乐趣，起码不用总是像个废宅那样等着动画番剧更新，不用总是像个信息焦虑症患者那样不停地刷着朋友圈、微博、Facebook 和 Twitter，用无尽的 Feed（信息流）来消磨时间。Feed，英文释义是喂养、饲料，这个词用得真是妙，庸众被无穷无尽、价值低下的碎片信息（即饲料）所喂养着，然后成了砧板上待宰的羔羊，被各色以卖广告和用户隐私为生的媒体（特别是社交媒体）所撕扯分食。天上不会掉馅饼，如果不愿意花钱买知识，「嗟来之食」通常也只能是免费或廉价的垃圾信息。不主动，作死，不坚持不够主动。小学曾经参加过乐高机器人相关的比赛。到了初中，发现学校也有相关的活动室，但是愣是没有去找相关的老师问问，本来学生时代还能变得更有趣一点的……因为不够主动，错过了妹纸，人家当年可是喜欢我的。可惜过了这村就没这个店了，我醒悟太晚，当年的我又不是不喜欢她…… 肠子都悔青了。学生时代到现在依然经常作死抓脸（挤痘痘等），现在自己的颜值，也就只可远观。恨小学的自己省去了买牛奶的钱去黑网吧打游戏，好好买牛奶喝多好……不够坚持。小学毕业开始学跆拳道，初一稍微努力过一阵子，然后就荒废了。还有我高考之后的那段时间，如果能再稍微认真读 C 语言的入门书，或许暑假就能过得更有意义，然后可能会沉迷技术，不玩社团？一眼看到头的生活薪酬即使增加个几千一万（当然多多益善），会过得更开心吗？最大的可能还是高兴没多久，就恢复回原来的生活状态了，一切照旧。毕竟收入的增量还没有达到引至质变的程度。这时候，如果生活的连一个苟且的乐子都找不到，活着就很难受了。为什么怀缅过去？可能是现在碌碌无为。短跑冲刺式的目标发现现在自己的做事风格有严重的问题，目标不是设得太大就是太小。太小的目标没有什么用，而且还让时间更碎片化了，更加难以集中精力干大事了。太大的目标，没有分解为高效可行的步骤，反馈周期很长，很久才能获得一点点成果，久了人就很容易失去了做事的兴趣和激情，疲态尽显，效率每况愈下，即使最后完成了，也踟蹰了太长太长的时间。毕竟「一鼓作气，再而衰三而竭」。设立合适的「短跑冲刺」式的目标 —— 要稍微超出自己的舒适区，有点挑战性，能够考验智商（锻炼脑力）；即使目标再大，分解出的小目标必须要在短期内能够被完成，最好完成时长能在一天之内甚至两三个小时以内。举个例子，我需要许多时间写长博文，必然会有写得很不顺的时候，通常就会想「不如不写算了」。其实就是因为目标设得太大了，博文牵涉的话题和内容太广了。我又非要执拗地把内容写得面面俱到，于是篇幅更长了，在漫长的写作过程中精神饱受摧残，写作效率不敢恭维。当发现难以按照原来计划完成任务时，就应该及时调整目标，缩小关注的面，以期一鼓作气集中解决掉一个规模合适的问题。这样才能有不断的反馈，以催促自己不断前进，推进完成更大的目标。工作以来，不少时间都处于麻木不仁、浑浑噩噩、无精打采的状态。现在终于想起自己也曾有过风风火火、雷厉风行的时期，不过已经是很久以前的事了。大概保持那个状态，就能一往无前地做成很多事情吧。突然我又产生了一种「我终于回来了」的感觉。这毫无疑问是老掉牙、说烂了的道理，可惜啊，只有自己得出的道理，才是能算是真正的道理。所以人啊，总要重复犯错。鸡汤通常都是对的许多被错误定义为『鸡汤』的东西都是对的，它们之所以被这样定义，正是因为许多人做不到。当然「鸡汤」不一定都是对的，好的「鸡汤」也难免有特定的适用场景。我并不想详细讨论上面这句话的对或错，能从中得到一点启示和感想就够了。有人这么描述「鸡汤」的原罪 —— 给汤，不给勺。我觉得这并不是什么大问题，本来「喂鸡汤」就跟「技术分享」一样，不可能短时间内让你学到许多技术干货，不可能一下子改变人的性格、习惯、天赋。鸡汤的效用被过度期待，然后又被过度贬损，只不过是人们在自欺欺人之后发泄对「自己无能」的愤怒，罪不在鸡汤。「技术分享」通常是为了引起你对某种技术的兴趣，让你在分享之后自己去找时间去深入探究；「喂鸡汤」也是类似的作用，它振奋了你的精神，提醒你继续努力。命运有再多随机性，也还是有能够把握的部分。如果花半小时看完一篇鸡汤文，能换来庸人的半天奋进，花两三个小时看完一本鸡汤书，能换来三天的努力向上，难道还不够吗？起码比整天刷剧、打游戏强那么一点点。生活本来就很麻烦且令人沮丧，到底是什么让人产生「只要努力，生活就会变得美好」的错觉？可能就是所谓的「鸡汤」和「正能量」。即使付出了不少努力，还是离鸡汤里描绘的未来图景差个十万八千里，可能会觉得「生活欺骗了你」，可是那只能算是无用的抱怨。现实生活里的成长，其实比那些虚耗时间的烂游戏的经验槽涨得还要慢，那「人生」是「烂游戏」吗？那又何妨，只要生活里还有那么一星半点、贫瘠的乐趣和美好可以去向往和期待，就已经足够支撑我继续活下去。（大敌不过是「贪心不足蛇吞象」）。只要鸡汤还能振奋我的精神，我就还会毫不犹豫地把灌下去。鸡汤虽然不是绝对有益，但也不能算是「饮鸩止渴」，它还是利大于弊的。来壮士，干了这碗鸡汤。重大抉择人通常很少有机会拥有作出「重大的抉择」的机会。生活实际上是由各种具体而琐碎的选择组成的 —— 午晚饭，吃饭堂、外卖还是出门下馆子？上下班通勤，骑行还是乘车？洗澡时，听听歌还是播客？睡前，看看书还是动漫，玩会游戏还是更新博客？认真完成这件工作任务，还是随便糊弄过去然后自学？正是这些看似细小的一个个选择，才组成了「重大的抉择」。所谓高考志愿、出国、择业、婚嫁、生育等等的抉择，你手上的明面或潜在的选项，都是路径依赖的结果，正是以前一个个无足轻重的小选择，把你带到了今天这个并不理想的地位。不要做让自己后悔的选择，哪怕这个选择看起来再怎么无足轻重，只浪费你几分钟还是几小时。反脆弱一切通过自身少数经验加读过的文字得出的「生活方法论」，都是难以自证的。在任何能够构成有效因果关系的证据出现之前，这些理论都不过是臆测。更别说还有随机性的扰动，会让人越发认定命运是无可把握的。人都有「反脆弱」的特性，只要面临的不是毁灭性的打击，任何适当的危机和压力，都不能算是阻碍和弯路，它们会让人更快、更好地成长。「反脆弱」这个概念真的让思想僵化的我醍醐灌顶。早已对「舒适区、学习区、恐慌区」的概念感到麻木了。知道自己一直处于舒适区，但就是贪图安逸，走不出来。果然，我还是太小看人的适应能力（小看自己），即是「反脆弱性」。没什么大不了的事，一切「糟糕和美好」都总会过去的。不失去，就不知道现在的美好；失去了，也没什么，花些时间，你总能适应，不用太纠结；搞不好，你还能更强大。我以前也失去过我珍视的东西，花了五六年才看开。即使是缺胳膊少腿这种严重的事故，时间长了人也能够接受现实，然后恢复平静。人是健忘的动物，是坏处也是好处呢。所以「多去承担那些并不致命的风险」是一种值得尝试的生活方式。人艰不拆？明明知道了许多残酷的真相，但就是习惯下意识去回避、逃避…… 拖着不去直面现实并不能解决问题，拖得越久越是被逼在墙角，失去自救能能力，再没退路，然后悲惨地度过余生。成长有时需要一种恨，有时是因为碰到自己看不惯的人，竟然过得比自己好：这个混蛋竟然也能考上xx大学，我却不能？！复读一年、两年，我也要考上！就是要这种恨（志气）。这里我说残酷现实真相的其中一种 —— 这个世界看脸。我虽然颜还勉强，但是矮啊，略等于三级残废，毕竟妹子看男生更看整体形象，说得就是能不能带出门逛街涨脸，有没底气带去「给姊妹过过眼」。显然我就非常吃亏，毕竟有些东西是天生的，几乎没有回旋的余地。可怕的是，我当然也会喜欢漂亮、聪明的女生，所以恋爱方面基本常常处于非常被动的境地。差得看不上，标准降不下，我认识的好妹子许多也是这样。大家心照不宣，都不敢轻举妄动，这样还能继续做朋友，静候机会，或许哪天备胎能成事。当然大多人都秉持着「人艰不拆」的态度，力图让人际关系和谐，世界仿佛一片祥和美好。还是举颜值方面的例子 —— 一旦聊起颜值的话题，你会发现自己的一些看起来还挺友善的朋友，竟然会非常「毒舌」（说难听点就是恶毒）地评价别人的外貌，甚至当事人在附近，也敢毫不忌讳谈论下去。（还好我的核心朋友圈不会这样）一些条件差，就得靠其它条件的优越来补了。所以人要非常努力，才能赢得一点点真正的选择权。都是丛林法则，不强大就是没人权！比如择偶，人丑就是没人权！人矮就是没人权！人穷就是没人权！为什么不去努力争取！不去恨呢！废宅的做法，就是去享受各种安娱，麻痹野性，苟且过活。这么废，为什么不去死呢？举个不恰当的例子，在当今这个时代，霓虹x军x国x主x义者即使想要打 World War III 恐怕也打不起来，因为现在的日本年轻人已经不再是昔日的「昭和男儿」，而是「平成废宅」。要恨为什么自己当年怎么这么窝囊只读得上华工软件，连中大信科都考不上？考试只得中游偏上，比不过我的同学？为什么折戟美团、腾讯三面，只能当不咋地的北漂？工作的绩效不高，比不过我的同僚？要有志气，要有恨，要竞争，要斗争。（虽然我在这里这么说，对于比我更差的人来说，听到这一番话，会觉得不太舒服；可是我这一层的人，听到那些患有「浙大病」症候群那帮人的言论，何尝不会产生同样的一种感觉呢？）有太多亲朋好友，很容易就能得到安慰，并不见得是好事。慰藉太多、安娱太多、小确幸太多，以至于整个人丧失了独处的力量，失去了哀伤的力量，失去了恨的力量，恐怕会没有什么出息，不在沉默中爆发，就在沉默中中死亡。功利主义、实用主义对年轻人来说未尝是一件坏事（也有正面作用），树活一张皮，人争一口气。年纪轻轻就一副死气沉沉、行将就木、郁郁不得志、埋怨「都是这个体制的错、世界的错」的样子。我实在受够了！补刀还是再搬出这一篇《Loser 应该知道的6个残酷人生事实》好了。自个看吧，虽然它很像是标题党，可是他说得棒极了，我简直不能同意更多，比起他，我已经算是说得很客气了。“好人？关我屁事！慈父？去你妈的！回你的家和你孩子玩去！如果你想在这里工作，给我敲定手上的单子！”…“我不歧视女人，不歧视种族，不贪婪，不肤浅，也不虐待人！我和那些diao不垃几的男人不一样。”很抱歉，如果你所能做的事情，只不过是没有一堆缺点，就特么的给我从伤者身边滚出去！我们有的是风趣、英俊、事业成功的男人来帮助你的女神。但你不要去抱怨，为什么女神就喜欢找你口中的坏男人。她们吃这套是因为那些diao不拉几的男人，有其他东西可以满足她。“但我是一个聆听者！”是吗？你可以坐在女神身边几个小时听她念叨？你猜怎么着？角落里还有另一个男人可以这样做，他还是吉他高手！你如果不停地说你是一个好人，就像一个餐厅说他们的卖点是他们的食物不会让你拉肚子一样，就像一部电影的标题是“This Movie is in English”。这就是为什么你可以做一个好人，但仍然觉得自己是loser的原因。…“所以你的意思是要我去买一本教我如何把妹的书么？”当然不是，除非那本书的第一章是，“让自己变成女孩子愿意接近的人”。因为这一步总是容易被忽略——人们总是问“我怎么能找到工作？”而不是，“我如何成为雇主愿意雇用的人？”人们总是问“怎么让女孩喜欢我？”而不是“我怎么成为女孩喜欢的人？”对吧？因为后者往往要求你放弃自己喜欢的爱好，注重外表，天知道还要做其他什么牺牲。你甚至还可能要改变你的天性。“但是为什么我不能就去找一个喜欢原本的我的人呢？”答案很简单：人是有需求的。别忘记我们的例子：伤者在流血，而你所做的只是抱怨找不到会自动愈合的伤口？…但，所有人都应该知道，所有人却都不能接受的事实是：“没有最后的果实，你就什么都不是。”错觉不知道什么时候开始，我给了别人一种家里还有点钱的错觉，然而我自己也乐在其中，于是将错就错，也不去否定这样的说法。实际上我家只是做五金的小个体户。从初中开始到我学生时代结束前的差不多十年间，家里的年景都还可以，不过仍然只能算是小康之家。某次沪市从五千点附近暴跌，家里损失惨重，现在爸妈也退休了，除了退休金也没有太多别的经济来源，还好我也要开始工作了（当社畜）。澄清完了，说点别的。果然，我还是更想说实话。我真是太多哀怨了，有时真的见不得别人好，特别是曾经的同窗，ta 们现在混得那么好，前途一片光明，我自己怎么就这副衰样呢？仅仅依靠家里富足的家底，有些人也能混到国外留学，然后顺理成章地在国外工作。虽然过得不一定比国内更幸福（？），但至少在我看来比我更幸福（滑稽脸），能体验到更迥异多彩的人生。这个世界从来就是不公平的，又不是第一天知道这个道理，可为什么还要继续喋喋不休地哀怨呢？果然还是对自己无能的愤怒，不断找借口推卸自己的责任。活得不够充实、忘我，总是想些乱七八糟的玩意儿。虽然以后的生活杂文并不想把自己表现成一个现充、自信爆棚的人，但也不想再继续哀怨下去了。欢迎监督。看别人的博客，就是看别人的人生。逛到一个同好二次元的技术宅的博客，又从友链扯出一串同是程序猿的二刺蝝，每个人的人生道路都很不一样呢。参考他人的人生路径，又发现了许多以前没有想过的人生选择，反而更加茫然了。选项很多，然而只能择一从之。一旦做出了一个选择，其它选项便就此塌缩殆尽，徒增许多本来就不存在的遗憾。只能寄望幻想中美好的未来图景还能出现在梦里。然而无可奈何，毕竟人的一生只有皇皇数十载。作出选择，总能换回一些结果，无论好坏；不行动，更可能一无所获。其它的事错了，就要承受后果。事实证明，我有些东西果然选错了、做错了。无论怎么痛苦、恼怒和恨，结果已经摆在了眼前。错了就是错了，事情都过去了，虽然它们会继续影响到未来，但那我又能如何呢？已决然明白，我没有必要再纠结些什么了。希望自己能够长久记得此刻的煎熬，因为真的不想为同样的错误选择再后悔一次了。「不忘耻辱，不畏将来」。或许，这正是改变的开始？不想再自证孬种。难五一才努力学习没几天，就已经开始畏难贪晌。「正是因为难，才值得去做。」周末跟前辈吃饭聊天，解除了我心头的一部分疑惑。越来越发现因为当年的一点点实力和运气的差别，我竟然成了同业朋友的圈子里混得比较差的一个，不但是跟那帮变态的高中同学相比，跟大学同学相比也是这样。现状如此可悲，不得不更努力。公司环境好，部门气氛好，Boss 人很好，并这不能当饭吃。人生的旅途还有很长的路要走，这只是其中的一小段风景罢了，我还想看看别处的美景。并不怕这段被 Boss 和同事看到，如果他们关注我的博客的话。Power 锟的纸牌屋摘自 Power 錕的紙牌屋（Facebook），相应 Youtube 链接。哀傷的 Power《第二季第六集：哀傷的POWER》人类为什么哀伤？（先叉开主题）人类不要去避免哀伤，人类要 work it out（克服哀伤），而不是 wipe it out（消除哀伤）。只有你知道哀伤从哪里来，你才知道快乐何处去？这是一体两面。我们的 sorrows，就是因为 love 和 hate。因为我们恨，得不到爱，或者失去了爱。所以我们为了爱而悲伤，想要爱（快乐），但是前路却有障碍。（爱恨是一个矛盾、循环，交织在一起）sorrow 没有关系，sorrow 就是 happiness 的 beginning，所以快乐都是当初的哀伤得来的。你越哀伤，越克服这个哀伤的成就感，比你的 sorrow 更大。一点点的忧伤，得到的快乐也只有一点点大。(体验更哀伤的事，小哀伤就可以忘记。)假裝偉大的 Power《第二季第十五集：假裝偉大的POWER》pretension 假装，就是假装伟大（伟大这个词可以换成别的词）。即是「你的欲望，超过了你目前能用的资源」，说难听点就是「贪心」。pretension 那就是为了贪心，做出了自己能力做不到的事。「化妆、整形」就是假装漂亮。先不要说化妆好不好，应该看看那是怎样的一种心态 —— 那是一个有志气的人！因为她想要更好，她已经在玩政治了，已经开始加入 competition 竞争、面对冲突了！面对择偶的冲突（她们在上进）不是一般的禽兽的欲望（性欲），而是 Desire to Love！所以她们开始「偏激」！pretension 假装（pre- 准备）tension 紧张、压力intention 动机（然后开始角逐）contension 角逐（竞争、竞赛）extension 扩张！讲课的例子：（台湾）总是对 tension（紧张）进行回避忍让，intension（动机）很弱，对 contension（角逐）很害怕！所以，没有 extend（扩张）！害怕竞争怎么能发展！尾声对啊，人生并没有那么复杂，想做就去做。写一部小说就像在黑夜里开车。你只能看到车灯照亮的部分，但是你却可以走完整个旅程。E.L. Doctorow]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 效率指南]]></title>
    <url>%2Fmac%2Fefficiency%2F</url>
    <content type="text"><![CDATA[君子生非异也，善假于物也。荀子说明如何高效地使用 Mac？本文旨在简单阐述笔者个人对这个问题的拙见，仅供参考。本文会列举一些快捷键，只为引出想要说明的东西。默认都是 macOS 上使用的快捷键，除非有额外的说明。笔者一开始也是 Windows 用户，后来才用 macOS，所以本文会提及 Windows 和 macOS 之间的一些差异和对比。本文中 鼠标 意含 trackpad 触控板（Mac 通常使用后者）。相关博文《Tools 利器》列举了绝大多数笔者用的 Apps。《Mac Shortcuts 快捷键》列举了绝大多数笔者用的快捷键。因为以上两篇博文的部分内容与本文有交集，所以不打算重复赘述其中相同的内容，仅作进一步的细化和补充说明。好处原来不习惯使用快捷键的用户要开始尝试使用，用惯 Windows 后刚转到 macOS 的用户也要重新学习和适应新的快捷键。虽然可能一开始觉得困难，但是值得付出这些学习成本。因为 只要熟悉少数基本的快捷键，操作效率就能显著提升。对极端的键盘党说：对快捷键再熟悉，也必然会碰到键盘难以完成的操作。不要试图用键盘完全取代鼠标，因为暂时没有足够好的解决方案，而且也没有这样做的必要，毕竟存在必须使用鼠标的场合。鼠标操作更自由和精微，符合直觉，基本没有学习成本（对数字时代的原住民来说）。题外话：快捷键用上瘾之后，可能恨不得连触控板都不用了（走火入魔）。笔者就曾试图用键盘完全取代鼠标，感觉并不好。一些 Apps 凭借还算巧妙的方式（如，四象限法）让用户可以用键盘操作鼠标，但是基本都难以适应和熟练使用，通常还不如直接用鼠标操作。而且用完全用键盘取代鼠标操作，会导致手指的操作压力陡增，长时间敲键盘，手指手腕会疲劳疼痛。步骤首先熟悉常用的通用性强的系统快捷键。绝大多数第三方 Apps 都会遵循系统快捷键的设计逻辑和排布规律，复用其中大多数常用的类似或相关的快捷键，以降低学习新快捷键的成本，方便用户快速上手。然后熟悉常用 Apps 的常用快捷键。一般来说，日常高频使用的 Apps 没几个，根据二八法则，只学习最常用的 20% Apps 中的最常用的 20% 快捷键，就能以较低的学习成本大大提升操作效率。如果想要继续进阶，可以修改键盘的键位，使用更强大和专业的 Apps。修改（你认为）不合理的键盘键位。例如，笔者就认为「大写锁定」功能不值得占据 ⇪ 这个如此好按的键位。不但中文使用者不常输入大写字母，不太用不着 ⇪，连不少英文母语者也会去修改这个键位。可能你适应了新键位之后，用别人的电脑或者别人用你的 Mac 会产生不便。但你想一想，是不是正常情况下 98% 的时间你都在使用自己的设备，所以为了提升效率牺牲一些通用性是值得的！增强系统功能的 Apps，可以防止 Mac 睡眠、调整窗口布局、截图录屏、科学上网、隐藏菜单栏无用的图标等，总有一款能解决你的痛点。专业领域的 Apps 可以高效处理相关领域的问题。准备键位符号 Power⌘ Command ( Cmd ) = Window Windows⌥ Option = Alt Windows^ Control ( Ctrl )⇧ Shift ( Shf )⇪ CapsLock 大小写切换⇥ Tab⎋ Escape ( Esc )↩ Return ( Ret ) = Enter Windows 回车凵 Space 空格↑ ↓ ← → Up, Down, Left, Right 方向键⌫ Delete ( Del ) = Backspace Windows 删除/退格Num Digits: 0 ~ 9写法说明^ a = Ctrl + a⌘ a | ⌘ b = Command + a 或 Command + b⎋, b = 先按 ⎋ 再按 bmacOS参考 : Apple 官方文档《 Mac 键盘快捷键 》默认基本的 zxcv剪切、复制、粘贴、撤销、重做撤销、剪切、复制、粘贴：最高频的操作，对应 ⌘ z、⌘ x、⌘ c、⌘ v；Windows 上则是 ^ z、^ x、^ c、^ v。刚从 Windows 切换到 macOS 时会不适应。习惯之后就会发现 ⌘ 在空格旁边，离大拇指很近，| 相关的组合快捷键其实比 ^ 的敲起来舒服多了。重做：⌘ ⇧ Z 重做上一个被 ⌘ z 撤销的操作；Windows 上则是 ^ y。当快捷键用多了，会习惯猜测一个操作对应的快捷键组合额外加上 ⇧ 后，就能触发相反的操作。正如上文的 ⌘ ⇧ Z 之于 ⌘ z ，又如 ⌘ ⇧ ⇥ 之于 ⌘ ⇥（即「正向/反向切换 Apps」），所以这里 macOS「重做」快捷键的设置更合理。好设计：「相关快捷键之间有关联，它们的排布遵循一定的内在逻辑。」它能促进用户对「某一操作该对应哪个快捷键组合」产生一种直觉，用户可以籍此更容易猜出想要的快捷键在哪，大大减轻记忆快捷键的负担。比如，上述的「快捷键组合加 ⇧ 能触发反向操作」的规律。一个操作所用的快捷键组合，通常跟该操作的英语表述相关。快捷键组合所用的字母键，通常是该操作对应单词的其中一个字母，通常是首字母。比如，以上 ⌘ c 的 c 即 copy。有时操作的快捷键之间可能没有关联（只是因为相关的快捷键组合已经被其它更常用的操作占据了）。这时就需要则需要使用「联想」以便记忆快捷键了。比如， ⌘ x 的 x 像剪刀，也能跟 cut 扯上关系；⌘ v 的 v 跟 paste 就没有明显的关联，你仍然可以将 v 联想成插入内容的标识，或者说它代表 verbatim（逐字的、一字不差的）。为什么撤销、剪切、复制、粘贴的快捷键对应 zxcv 等键位？最显而易见的原因 是「zxv 离 c copy 很近，这些操作互有关联，适合放到一起」，而且也靠近 ⌘、^ 等功能键，这样的键位组合，敲起来更方便。文本编辑基本：⌘ b 加粗、⌘ i 斜体、⌘ u 下划线，⌘ = / ⌘ - 放大/缩小字体（或界面的显示）……进阶：选中：按住 ⇧ 不放，再按方向键 ↑、↓、← 或 → 可以选中一段文本。删除：Fn ⌫ 后向删除字符，跟 ⌫ 前向删除相反。⌥ ⌫ 前向删除一个（中英）单词（或字符串），当然也有对应的 Fn ⌥ ⌫ 后向操作。注意 macOS 对中文单词的判定并不总能合乎你的期待。Emacs：macOS 的文本编辑控件内置了一些 Emacs 快捷键。跳转：^ a = Windows 的 Home；^ e = End。删除：^ k 删除光标当前位置至行尾处的字符串。前后：^ b = ←，^ f = →。文件、目录移动、删除、预览、打开、向上、查看文件属性文件移动：在 Windows 先用 ^ x 剪切，再用 ^ v 粘贴；而 macOS 则先用 ⌘ c “复制”目标文件，再在目标目录下用 ⌘ ⌥ v “粘贴”，此时文件「移动」成功！如果你先养成了 Windows 的使用习惯，可能会不适应 macOS Finder（文件管理器）对「移动文件」操作的思路。解释：先用 ⌘ c 并非表示这一定是「复制」的操作，也可能是「移动」，具体是哪一种操作，取决于后续用哪个快捷键；如果用 ⌘ v 即是「复制、粘贴」，⌘ ⌥ v 则是「剪切、粘贴」即「移动」（你会发现这两个快捷键也是关联的，不难记）。剪切文本 还是使用 ⌘ x 进行剪切。剪贴板历史：剪切后用 ⌘ ⌥ v 会显示最近的剪切复制的文本历史，可以选择其中一个进行粘贴。删除：⌘ ⌫，只是进入废纸篓；完全删除需要 ⌘ ⇧ ⌫ 清空废纸篓。进阶：如需直接删除，可以用命令行执行 rm 删除命令。预览：选中文件，然后按空格键 凵 即可便捷地预览内容，这样一般情况下就用不着专门启动一个 App 来查看文件了，除非需要修改。配合 预览插件 效果更佳。打开：Windows 上用户会习惯用 ↩ 来打开文件、文件夹；然而 ↩ 在 macOS Finder 中用于文件、文件夹的重命名，⌘ ↓ 才是「打开」操作。向上：即跳转到上一层目录 ⌘ ↑。查看文件属性：⌘ i 打开「文件属性」的信息窗口，此时可以 修改这类文件默认使用什么 App 打开（即打开方式），修改或获取该 App 的图标等。不常用/非必需：文件复制：macOS 用 ⌘ d 即「制作副本」，等于在同一目录下先用 ⌘ c 再用 ⌘ v。制作「替身」：你可能会将一些文件复制多份，然后放在不同地方，可能是为了便于访问。但是除非为了备份，否则这么做会令你难以对其进行有效的「控制版本」。还不如用 ⌘ l 为其制作一个「alias 替身」，将其放到其它地方，例如桌面。「替身」用程序员的话来说，就是指向源文件的「指针」或者「软连接」。打开替身等于打开了原始文件，而删除「替身」不会影响到原始文件。其它常用设置：⌘ , 基本所有的 Apps 都用它来打开设置选项。窗口：⌘ ^ f 最大化，⌘ h 隐藏（相比之下 ⌘ m 最小化就显得鸡肋了），⌘ ⌥ h 隐藏当前窗口之外的所有窗口，很好用。浏览器：⌘ [ 前进、⌘ ] 后退。在 Finder 中也能使用。输入法：^ 凵 切换输入法；注意系统自带输入法是用方括号 [ 和 ] 进行候选字前后翻页的，而非通常的 , 逗号和 . 句号。关机：记住 ^  关机就够用了；还有 ^ ⇧  是屏幕睡眠、⌘ ⌥  则是（硬盘）睡眠。Spotlight：习惯使用 ⌘ 凵 进行系统全局搜索，就不用总是打开 Finder 和 LaunchPad 来找文件和 Apps 了。功能键：即键盘最顶上的一排按钮（2016 年底新款 MacBook Pro 取消这排实体按键），控制「屏幕亮度、音量、音乐播放」等按键较常用，「任务控制（F3 处）、LaunchPad（F4 处）」等可以由触摸板的手势「三指上划、拇指加另外三指内划」来代替（详见 系统设置 → 触摸板 处）。没想起来的快捷键，一般也都不太重要，在此略过。自定义在 系统设置 → 键盘 → 快捷键 中可以修改很多（不是全部）系统默认的快捷键。主要是将一些你觉得不合理的快捷键组合改得顺手，或者将用不上的快捷键去掉，以免误触。特别是对某些快捷键组合已经形成根深蒂固习惯的人，会记不住新的快捷键，以致经常按错。其中左侧候选栏中的 应用快捷键，可以用来重写全部应用或指定应用的某些快捷键。浏览器作为最最常用的 App，最值得熟练使用快捷键以提升效率。常用通用快捷键恢复（重新打开）最近关闭的标签页：⌘ ⇧ T，很有用的快捷键。特别是误关某些网页时，可以快速重新打开，不用去浏览历史找。页面刷新： ⌘ r；Windows 则是 F5；页面浏览： 凵 向下滚动一页，⇧ 凵 相反；↑ ↓ ← → 也可以小幅度滚动页面。访问历史：⌘ [ 前进，⌘ ] 后退，⌘ y 或 ⌘ ⇧ H 浏览详情。切换标签页（Tab）：^ ⇥ 下一个（右），^ ⇧ ⇥ 上一个（左）；⌘ 1~9 跳到第 1~9 个标签页，如果一共超过 9 个标签页，⌘ 9 则是跳转到最后一个标签页而非第 9 个。显示比例：⌘ = 放大，⌘ - 缩小，⌘ 0 恢复默认大小。收藏夹：⌘ d 添加到收藏夹，⌘ ⌥ b 管理收藏夹。其它：⌘ , 设置，⌘ ⇧ H 主页，略……进阶 Vim 式插件Firefox + VimFX配合 VimFX 拓展，可在浏览器内 全局使用 Vim 键位 浏览网页、操作浏览器！键盘党神器。只要入门其中常用的基本操作，就能感觉到效率的大大提升。能用一个指头按就不要用两个指头，指头在越靠近键盘中心区的地方按就越省力。VimFX 默认的键位排布跟 Vim 有一定关联（但不全都有）。熟悉 Vim 的话，用 VimFX 会很顺手；还在学习 Vim 的话，可以帮助你记忆 Vim 的键位。基本操作：f 在当前标签页打开链接，⇧ F 在新的标签页打开链接；x = ⌘ w 关闭标签页，⇧ X = ⌘ ⇧ T 重新打开最近关闭的一个标签页；j 下翻，k 上翻，⇧ H = ⌘ [ 前进，⇧ L = ⌘ ] 后退；⇧ J = ^ ⇧ ⇥ 上一个标签页，⇧ K = ^ ⇥ 下一个；其它从略，可以通过 ⇧ ? 显示、查询所有 VimFX 的快捷键。其中进阶的操作可以慢慢熟悉，可以通过插件设置来修改键位排布，以便用得更顺手。Chrome + Vimium | cVimChrome 也有类似 VimFX 的拓展，以实现同样的功能，但这些拓展无法在页面未加载完毕的情况下使用，不够极致。cVim 比 Vimium 更强大，功能更丰富，拥有更多的配置选项，但需要用类似 .vimrc 的文本编辑方式来进行配置，不太用户友好。Firefox 冷启动较慢，界面不如 Safari、Chrome 漂亮，也有一些 bug。可是工具是拿来用的，最重要的是高效，所以我还是倾向于使用 Firefox + VimFX。其它插件广告过滤器、网络代理（用于翻墙）、下载工具管理、1Password、印象笔记剪藏等……详见 我的浏览器插件实际需要用到的插件并不多，根据需求自行选择，够用、适合自己就行，尽量保持精简。安装运行太多用处不大、用得不多的插件，不但让浏览器变得更慢，而且还更容易崩溃，得不偿失。命令行程序员相关。工具链推荐：Zsh + Vim + tmux + iTerm 2Zsh可能在默认的配置下 Fish 使用起来比 Zsh 更好一点，但是它对 Bash 的兼容性不够好，Bash 的脚本或指令组合不一定能在 Fish 上跑，相反亦然，影响通用性。Zsh 在这方面则基本没有问题。综合各方面进行对比，我认为 Zsh 暂时是各种 Shell 中最好的选择。快速切换目录：最常用最便捷的功能直接输入目录的路径，毋需添加 cd 指令，即可切换到指定路径。输入不完整路径（或者指令）然后按 ⇥，自动补全目录（或指令），或者列出相似的候选项。输入 - 或 1 命令切换到上一个目录，1 ~ 9 用于回到之前第 n 个访问的目录。Shell 内置的 Emacs 式快捷键（keybindings）跳转：^ a 光标移至行首，^ e 移至行末。删除：^ u 删除光标当前位置至行首处的输入，^ k 相反，即删除至行末；^ w 删除前一个单词，^ h = ⌫ 删除前一个字符。移动光标：⎋, b 移动到上一个单词，⎋, f 移动到下一个（meta b / meta f for Bash）。命令行历史：↑ 上一条命令，↓ 下一条（^ p / ^ n 也可以）。确认：^ h = ↩ 确认指令。命令别名（Aliases）通常用来给常用命令指定一个「缩写」，一遍更便捷地输入长的命令组合。作为程序员，我的手速、输入准确率都一般，就特别喜欢输入缩写命令。例如，我让 gs = git status，gp = git push 等（见 Git Aliases 和我的 .zshrc 配置）。alias 命令，列出所有的 aliases。Zsh 还有许多好东西，在此暂略，可以根据自己的需求，自行查阅学习。可以简单参阅我的 .zshrc 配置。注意以上特性并不都是 Zsh 特有的，详看 各种 Shell 的对比。Vim（也可以选择 Neovim）首先，通用性有保证！服务器没有 GUI 界面，可能没有 Emacs，但是基本不可能没有 Vi*，学会 Vim 保证你在几乎任何服务器环境下都能无碍地编辑文本。其次，拓展广。很多 IDE 和编辑器都有 Vim 插件，不用记太多各个 Apps 专有的快捷键，学会 Vim 就可以在其中进行绝大多数常用的文本编辑操作，减轻记忆负担，提升效率。例如，Sublime Text 系列就自带 Vintage Mode 专门支持 Vim 键位的操作。各种 Shell（命令行）除了自带 Emacs 式的快捷键，其实也有 Vim 式的快捷键，可以尝试一下，看看自己习不习惯。tmux终端多路复用软件，即命令行中的「窗口管理」、「分屏工具」。允许一个用户在一个终端窗口或一个远程终端会话中，使用多个终端会话。tmux 是由 screen 发展而来的，其中许多命令都是共有的。screen 虽不如后来者 tmux 易用、强大、美观，但是更通用 —— 大多数服务器都有 screen 命令。iTerm2功能和可配置性，比系统自带的终端 Terminal 强大许多。对命令行的使用环境要求不高的话，用 Terminal 也没差，只要适合自己，够用就好。其它选择：VS Code 它内置的终端，就很不错。进阶Karabiner 改键从 macOS Sierra 10.12 这个系统版本开始，Karabiner 不可用了。新一代产品 Karabiner-Elements 在开发中。由于它能大大提升我的效率，我还是继续使用旧版本的系统 macOS EI Capitan。我将 ⇪ 改成 ^，这样的话，按下由 ^、⌘ 组合而成的快捷键会顺手很多。原来的 ^，用于一键触发 ^ 凵 以便一键切换输入法。用专用的单键 ^ 比用 ⇧ 或 ⇪ 来切换输入法，更不容易影响正常的操作。特别是用 Vim 输入中文时，因为 Vim 有太多跟 ⇧ 相关的操作。我用右手掌小鱼际（即靠近小指的部分手掌）去按原来的 ^ 键位，这样的话双手就基本不用远离键盘中心区了（参考盲打键盘的标准姿势）。我从键盘上完全移除了 ⇪ CapsLock 的大写锁定功能（不改其它键来实现该功能）。因为很少用到，Vim 党可以先以小写写完，再用 U 指令全部改写为大写，大不了全用 ⇧ 来输入大写字母。右 ⌘ 改成 ⎋。因为左小指挪到键盘左上角的 ⎋ 略远，这样的话，双手就基本不用远离键盘中心区了（参考盲打键盘的标准姿势）。而且这样就可以用强健的右大拇指去代替比较弱小的左小拇指去按 ⎋，减轻长时间敲击键盘的手指不适。AppleScript系统内置的可用于操作 macOS 以及 Apps 的脚本语言。能实现许多功能在此暂不赘述。其实一般情况下，用户都没必要折腾，你能想到需求通常都存在相关的 App 帮你解决。但如果你懂 AppleScript 的话，就可以便捷地实现许多简单实用的功能。例如，快速查询本机 IP 地址并保存到剪贴板；又如，将剪贴板的内容通过邮件或 iMessages 的方式快速发送给指定联系人，发给自己的话，就可以将需要的内容从 Mac 发到自己的 iPhone 了。因为许多软件都支持 AppleScript，可被其调用和操作，而且通常也不会缺少相关的说明文档（Dictionary 字典）。基础用法：用 AppleScript 写好脚本，然后保存为 Application，就可以用点击打开、Spotlight 搜索、快捷键等各种方式来便捷地调用它，以实现自己的功能。进阶用法：Keyboard Maestro、Alfred 等的许多效率类软件不但能被 AppleScript 调用和操作，他们也能调用 AppleScript。所以它作为一种胶水语言，可以与其它 Apps 甚至命令行的命令、脚本进行组合，产生进阶的功能，实现一些 Apps 原来并没有的新功能，以满足自身的需求。可以参考：《AppleScript Language Guide》官方文档《用 AppleScript 操作 Evernote / macOS》《AppleScript Quick Start 快速入门》Automator可谓 macOS 的「按键精灵」。有时候用 JS、Shell、Python、AppleScript 写脚本来实现某些功能并不方便，比如关于 GUI 的一些任务，不如直接手动做。这时需要的若只是重复性的简单鼠标键盘操作，就可以用 Automator 直接录制键盘、鼠标的操作来重复运行，以减少重复的人工劳动。接下来列举的一些其它 Apps，它们大大地提升我的效率，所以推荐您去了解和尝试。具体详见《Tools 利器》，其中列举了绝大多数笔者用的 Apps，包括简要的介绍和进一步的说明。选读《Mac Shortcuts 快捷键》列举了绝大多数笔者用的快捷键，仅供参考。因为以上两篇博文的部分内容与本文有交集，不打算重复赘述其中相同的内容，以下仅简单列举笔者推荐的 Apps 并附上一句话的介绍说明。Time Machine RequiredmacOS 自带的系统备份、恢复软件。要有忧患意识，不要等硬盘坏了、Mac 丢了，才追悔莫及。CheatSheet快捷键快速提醒。长按 Command 键，显示当前程序的快捷键列表，方便快速入门 Mac 各处的快捷键。（新手专用）Seil改键软件，是配合 Karabiner 使用的（macOS Sierra 中也不可用了）。Keyboard Maestro Best高度自定义的效率工具，难以一语道尽玄机。可以参考《Keyboard Maestro 入门指南》ClipMenu Great剪贴板管理。主要用于快速查询剪贴板的历史记录，并提取出需要的内容保存到当前的剪贴板中。Others : Paste 最好看！Copied（没用过）。Amphetamine防止 Mac 休眠。Mac 每次休眠后都会重启软件，导致软件丢失部分上下文，于是我无法在完全一样的环境下持续工作，一定程度上打断了工作，降低了效率。Bartender 2收起或彻底隐藏毋需过多关注的菜单栏 App 图标。HyperSwitch稳定切换同一 App 下各子窗口。ShowyEdge Great输入法状态提示。显示一条样式可定制的色带在屏幕顶部，以提示正在使用什么输入法。在全屏使用 App 时，也能轻易区分输入法状态！……后记（跟本博客的许多文章一样）本文会持续地更新，如果有新的体悟，我会补充进来。有新的好 App 可以推荐给我~ 欢迎讨论，期待您不一样的见解！]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 冬]]></title>
    <url>%2Fthink%2F2016_winter%2F</url>
    <content type="text"><![CDATA[写作近几个月专注于部门主项目的重构工作，其余时间沉迷于 ACGN（动画、漫画、游戏、轻小说）。不过还是想抽出些时间总结一下这段时间里的琐碎思考，毕竟好记性不如烂笔头。「多余」的文字能够三言两语说清楚的事情，何必连篇累牍。但是，文章不能只有结论没有论述，只有情感没有来由，不然就成了空中楼阁，没有学理上的说服力，也没有情感上的感染力。所以需要巧妙的引喻、学理上的论证、独特的视角还有精到的描写，才能令人赞叹、令人信服、引起共鸣。写作确实需要天赋，如果平庸的我能写出的文字能合乎逻辑、条理清晰，能说清楚自己想要表达的东西，就足够了。「简洁」的文风最近看了《Rework》（中译名《重来》），它「简洁、辛辣」的文风，我简直不能更喜欢。（《程序员的呐喊》也以辛辣、幽默的文风著称，我也很喜欢。）深刻精到的阐述，简洁有力、直指人心。正如言简意赅的文言短句，点到为止却意味深长，这是简洁文风的一大魅力。所以特别希望自己能像《Rework》一书作者那样拥有自己的真知灼见，然后籍此写出简洁精到的好文章。我看实体书，有个发现（疑问）：它们都至少有 200 页的正文内容。经常看到这样一些书 —— 它的主题明明可以用更少的篇幅恰到好处地论述清楚，可是感觉作者非要狗尾续貂，凑够 200 页。我查了一下资料，猜测：200 页是纸质书出版的底线和惯例。字数要是不够，就得用宽松的排版、配图、表格撑够 200 页。一般短篇书籍的正文大概有 200 页，加上前言、目录、附录等，页数估计一般不会超过 256 页。这可能跟制作书籍的纸材尺寸有关。如果是学术著作为了「论述的完整性」而扩充相关内容，我还能忍受冗长的内容。但是对于一般著作、文章来说，面面俱到的叙述，能让文章、书籍变得更精彩、深刻吗？「面面俱到」看似没有疏漏，但是并不精彩，像是在谨慎地编纂法律条文，直教人昏昏欲睡（记得高中时，我就是这么写文章的）。正如一部好电影，导演和剪辑师必须忍痛剪掉一些颇费心血的片段 —— 因为电影并不会因为多了某些鸡肋的片段而变得更好看，有舍才有得。例如最近的电影佳作《你的名字。》。（虽然很多人都看过，还是在这强烈安利！）例如，动画在高潮时，并没有描写三叶的父亲为什么听取了三叶的要求。虽然有些观众觉得这削弱了作品的合理性，显得“都合主义”，但新海监督认为在这里花费篇幅去描写三叶怎样说服父亲，并不会让动画变得更好看。《你的名字。》描写的是三叶和泷的情感。所以故事的时间轴也必须紧贴这一主题，不能离题太远。虽然新海监督在创作时也曾犹豫过，认为泷想要拯救的不仅仅是三叶，还有镇上的所有人，所以有必要在某一时间点让故事的主题转移到拯救小镇，但最终仍然放弃了这一做法。反正最后只要大家都得救就好了。泷当然也会去考虑三叶以外的人，但作品的核心始终是少年少女的恋心、想要了解对方而拼命地伸出手、终于就要触及之时对方却要消失……除此之外的动机，不应该混入作品。（来源：知乎。作者：AnimeTamashii。链接：https://zhuanlan.zhihu.com/p/24104030。著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。）紧凑、流畅的剧情或行文更能让受众产生共情，没多少人会喜欢冗长的絮叨。不会思考学生时代应付学校的课程和作业就疲于奔命了，只会偶尔思考一下人生。现代生活提供了纷繁又精彩的娱乐活动，可以选择一直消遣下去（娱乐至死？）。辛苦之后，通常更倾向于娱乐放松，而不是去学习、思考。高中时代的我就认为「生活只要充实就好，没时间去烦恼（思考）就很幸福。」然而现在更觉得「不好好思考，是对自己的不负责。」很多事我都没有好好想透过，虽然得出过一些想法，但是觉得肤浅就懒得记录总结了。一些重要的想法没记下来，等一波繁忙的工作学习过后，就全都不记得了。一些想法虽然幼稚，但只要肯记录，在记录反刍的过程中就能引发进一步的思考，日后慢慢打磨，总能生发出新的体悟。当然大多数的总结在写完之后就再也不会回顾了。现在才觉得偶然冒出某些想法不同于其它想法，它们可能反映了 —— 我实际上是怎样的人，喜欢什么、讨厌什么、擅长什么，事关我该如何生活，但我却忽略了这些心声。独立思考我并不擅长「独立思考」。阅读能获得很多知识。现在的各路知识服务商，为了迎合急功近利的受众，喜欢直接提供「干货」，不需要你深思、推导、实践、总结，只要直接吸收就好了。又不是婴儿，总是喝奶吃稀饭，消化系统是会退化的；平时不勤加思考，脑力可能会慢慢退化得只习惯盲目地吸收信息，难以进行有效的独立思考。比如说，学习了新知识，我运用得了吗？能用得好吗？能举一反三吗？……我没有足够的天赋，又没有掌握合适的方法，知识学得又慢又累。毕竟「求量」比「求质」更容易使人产生满足感，所以常常陷入广泛略读、贪多求全的怪圈。于是「输入」很多，却鲜有「输出」，肤浅的输入沦为谈资，稍微深刻点的见解又基本是二手得来的，当深入谈论这些二手见解的时候，我就会发现自己基本说不出个所以然来。重要的信息、知识，通常在别人探索、应用的过程中，就被榨干了价值 —— 先行者可以把它们注册成专利，以收取授权费或者作为竞争的壁垒，甚至可以藏起来作为不传之秘。当既得利益者无法凭借独吞这些知识高效获益的时候，这些知识才可能被允许广泛地传播给大众。这时即使大众还想凭借这些旧知识、旧手段获利，也已经太晚了，先行者占尽先机，后来者只能靠残羹剩饭糊口。即使大家同时拥有相同的知识和信息，也只有优秀的人能更快地看清本质，夺得先机。通过别人之口获取知识，只能追赶别人，难以超越。当然追赶是必要的，不站在巨人的肩膀上，谈何超越。自己没有独到的见解和一手知识，就不能产生独立的有价值的判断，就永远只能落在时代后头。可惜知易行难，所以现在也只能先追赶着，等着哪天榆木脑袋可能开窍。刻意学习「一万小时理论」可谓无人不知无人不晓，我也曾幻想过在某一领域里“糊弄”满一万小时，就能升职加薪、出任 CEO、迎娶白富美、走上人生巅峰…… 可惜现实哪有这么简单。这个理论的价值，不过是提醒大家：别老想着走捷径，路还得一步一步地走，而且路还远着呢。然而它现在却在一定程度上，变成了另一种形式的鸡汤。就好像游戏中的「经验槽」，似乎只要混满了就可以「升级」。（后来，我看了「一万小时」的出处《异类》，发现自己的理解有误，以讹传讹了…… 原来「一万小时」的意涵是，即使是天赋异禀，也得需要一万小时的锻炼，才能出类拔萃。原书篇幅不算长，值得一看。）近年，新进的「刻意学习理论」（终于广泛传播到国内了）对「一万小时理论」做了重要的补充，给只管汲取信息不动脑的人（比如我）稍微充值了一下欠费的智商。可以参考同人于野（万维钢）的科普文章《怎样练习一万小时》做简单的了解。竞技运动比起一般的知识学习领域，我对「刻意学习」应用在运动领域的感受更深。我从高一下学期开始，就一直迷恋「毽球」这项小众的竞技运动，前四年进步缓慢，直到第五年还是处于起球（一传二传）不稳、只能勉强踩球（杀球）的水平。就是因为沉溺于比赛式的「实战练习」而疏于进行「分解练习」。当时我觉得：「每周都能跟球友们一起愉快地踢毽球就够了。」训练不当，所以进步缓慢，而且还形成了许多坏习惯，动作费力还达不到效果。技艺高超的同校前辈们都离开了，这时如果我还想在校际比赛中取得成绩，就必须尽快成为毽球队的顶梁柱之一，哪怕只能多打一两局比赛，多争取一两分…… 面对强大的对手，个人英雄主义和胜负之心激发了我的求胜欲望。大二下学期末，我终于开始了比过去更有针对性的训练计划。大四下学期最刻苦的一个月，我穿行于市内各高校的毽球训练场地，平均每天训练 3 小时，最长的一天训练了 8 小时。这是大三以来我的一般训练流程：热身，先在体育馆内跑两圈；左右脚交替连续击毽，直到能连击 200 次为止，中途毽子不能落地；「带球快速跑动」、「一高一低地向前起高球并向前移动」各至少一圈；发球练习与接发球练习，各几十次；踩球（杀球）练习，压腿以增强柔韧性。按照比赛流程，进行实战练习。显然「分解练习」的时长比「实战练习」长得多。要知道，一些关于「刻意学习理论」的文章甚至会说：日常训练中的「分解练习」占比可高达 98%，剩下 2% 的时间才用于进行比赛式的「实战练习」，这时才能综合使用之前分解练习的各项技能。一般情况下，在大三大四期间，一周至少训练 3 次，每次训练的时长至少是 1.5 到 2 小时，其中只有 30 分钟用于实战练习。但是为了保证每次训练都能有至少有 1 到 2 小时 的充足「分解练习」量，所以不时会完全放弃「实战练习」。所以才有了后来长足的进步，总算获得了 一些成绩。刚开始上手一项运动，需要脑力「刻意」控制身体去完成动作；当形成相关的肌肉记忆之后，身体就会自动完成迅速的移动、迎击、进攻等动作。打羽毛球时，即使没有刻意思考，也会下意识把球打回去。如果肌肉记忆强大到成为「模块」，能被轻易调用、极少出错，就能大大地解放脑力，让人可以有余力在转瞬之间做出更多战术、战略上的思考选择，这样就能更从容地打败对手。只有碰到势均力敌的对手时，才会来不及多想，这时拼的就是谁的思维习惯、行动习惯、肌肉记忆更卓越了。思维习惯空间想像、心算、记忆力、逻辑都是有用的脑力「模块」。空间想像，可以突破现有工具的物理局限来思考事物；心算，可以快速得出中间结果，加速思考；记忆力好，等于电脑有了更多的内存、磁盘空间和读写速度，可以更高效地调用更多的线索和素材，以便进行更广泛、更深入的思考；逻辑，可以发现事物的矛盾和本质，更好地举一反三。思维习惯好（「智商」高），做事更讲究方法、更有效率，更容易达成好的结果。「君子善假于物」，可以用纸笔、工具来描绘空间，可以用计算器代替心算，可以用搜索引擎代替博闻强识 —— 靠工具就能轻易超越人脑的极限。好像人只需要知道如何思考、决断就行了。但是脑力不能太弱，否则连能不能做到「善用工具」都难说。经常觉得自己蠢。例如，某次查水表，我一时想不到办法判断两个没有标识的水表哪个是我住处的，实际上只要试着关上其中一个水表的阀门，看看住处的水龙头还能不能出水就行了。某次拿到外卖，塑料袋绑得太紧解不开，我下意识想要去用蛮力拉开胶袋，实际上横向用指甲撕开就容易。觉得这不只是「小聪明」，它体现了思维习惯够不够好。做事要习惯动脑，不能靠蛮力「大力出奇迹」。长大了反而觉得智商走回头路了。父母虽然从小关心我的学习，但是他们忙于工作，而且也没有足够的学力（这里没打错字），我基本处于放养状态，只能靠自己学习。老师毕竟精力有限，绝大多数时候都只能依靠高压的管束和「填鸭式教学」来灌输知识。终于我混到了大学，偶然被「打了鸡血」有了强烈的上进欲望。可惜早年（小学到高中）做事不够「讲究方法」，也学得不够刻苦，即使学到了一些好方法也没好好实践过，没能形成良好的思维习惯。于是，学的知识不够多，学习、运用知识的能力又有限，还太爱玩，易颓废，真是走了不少弯路。精简Grasp all, lose all. 欲尽得，必尽失。从 简历 上看，我似乎做了不少事，但却没能达成几个连贯相关的重大目标。懊恼啊，不然现在本可以活得更从容些的。因为我的兴趣面相较于我极其有限的才能来说，实在是过于广泛了，未能及时放弃那些不值得我去追寻的事物，贪婪又不自知，想面面俱到结果学艺不精…… 我接触「断舍离」的概念不算太晚，但是一直都做不好。我也许有作出「取舍」的决心，但却没有足以判断事物轻重缓急的思考深度（智慧）。随着今年公司总部搬家，踢毽球的场地离我的住处和公司都远了很多。所以继续坚持毽球运动的机会成本比较大，我只能被迫放弃这项运动。毕竟生活中还有其它更重要的事情，首先是工作。于是我现在选择了更便于参与而且兼具娱乐和锻炼两个效果的运动 —— 羽毛球。（题外话：最近我发现右大脚趾「嵌甲」，即是指甲快长到肉里了，穿合脚的球鞋跑动时会觉得疼，需要做个手术治疗一下。才刚请教练没几节课，又要告别羽毛球一段时间了，真是让人悲伤。）有一段时间我玩疯了，玩《Reigns》用了三、四天，玩《游戏王：决斗链接》用了快十天，看（堪称新世代「灌篮高手」的）《排球少年》用了两周，读《Overlord》和《幼女战记》这两部的漫画和轻小说又是两周。那段时间我几乎天天都在拼命压缩时间，不是在工作，就是在打游戏、看动画和轻小说，真是 Play Hard 到了极致；同时这也是我 2016 年工作产出较多的时候。所以那段时间睡眠和学习被我严重剥削，天天爆肝。我就是这个样子，要不就一直都不怎么娱乐，不然疯起来得一直玩到吐才能停得下来。自从放弃了毽球，很多以前看起来不可能放弃的事物都发生了变化。抠时间的边角余料疯玩，让我剔除了许多正常工作以外毫无意义的生活琐碎，简化了必要的内务 —— 交通、饮食、家务、睡觉。只要不是凛冬或雨天，我都会骑自行车上下班。只要每骑行一次就至少抵回一元的公交车搭乘费用；骑行不用在车站等车，通勤时间更稳定、可预估，不容易迟到（我起床太晚）；上下班，骑行比乘车（加步行）的方案更节省时间；而且骑行还能锻炼身体，真是一举多得。我喜欢美食，不过日常饮食能果腹就够了，所以我基本只去公司食堂吃饭，每周能吃顿好的就够了。虽然说中午外出吃饭能跟同事扯淡是一种乐趣，但是如果我想要 focus 到少数一两件重要的事情时，我更喜欢自己一个人吃饭。毕竟一个人吃饭更自在，不用顾忌琐碎的社交规范，省时又省心 —— 可以一边不徐不疾地用餐，一边听音乐或者播客来给大脑「充电」，毕竟聚餐的时候戴着耳塞显得很没礼貌。是否纠结日常的「穿着」，是个生活哲学上的选择。我喜欢穿深色不容易脏、容易打理的衣服鞋袜，而且就是来来去去那么几件。衣服袜子脏了就让洗衣机搞定，鞋子脏了用布沾水擦净，坏了就扔掉，然后买新的。除非哪天「讲究穿戴」成了我的生活乐趣，不然我还是这样简简单单地过下去好了。大家都知道，扎克伯格、乔布斯的衣服来来去去那么一两个款式 —— 他们说这是因为不想多费精力在选择每天的穿着上，而是花费在其它更值得推敲的「选择」上。我不需要一个太好的居住空间，不需要比邻地铁、公交、超市、食肆，不需要离繁华市区近以便玩乐；住处只要可以洗澡睡觉放东西，离公司不要太远，有一两路公交能往返公司，房租便宜一点，出入安全，就够了。我当然喜欢结交新朋友，但是真的不需要那么多朋友，少数的老朋友就足够了，所以我的社交活动也变少了。当年某大学师姐说得对，我是有点孤僻。（题外话：人是「情景动物」，并不是简单的「外向、内向」可以区分得了的，所谓性格，很可能是个人在各种情景下习惯的应对方式的集合 —— 某个人可能在一些场合习惯积极外向地交际，而在另外一些场合则不喜欢搭理他人，只想默默地做自己感兴趣的事。）我是个不折不扣的「工具控」，经常折腾工具过了头，忘记工具毕竟只是做成一件事的手段而已，重要的是把事做成。不过我的「工具控」属性已经开始「退烧」了。当年我还是「耳机控」，只是后来我越发觉得音质够用就好了，所以就慢慢退烧了。现在越来越认同苹果「开箱即用」的哲学。想要成为怎样的人？曾经很喜欢擅长会「装逼」的人 —— 喜欢宣扬、炫耀自己的成就而且还名副其实的那些人。后来更崇拜韬光养晦、文质彬彬、温润如玉的人，下意识对口出狂言、自大、过于外向、总是大声说话的人感到不适和不屑，当然假如他们真的是恃才放荡，那还情有可原。我现在很讨厌曾经自以为是又没才华的自己。说和做都坦坦荡荡，知礼知耻，不摆架子，没有假正经的道貌岸然、自命清高，充满个性、擅于自嘲 —— 这是现在道德方面，我理想中的自己。（一段黑历史。说「我想要成为『君子』/『男神』」这样的话，实在是太羞耻了，不过少男少女多少曾有过「杰克苏、玛丽苏」式的白日幻梦。高二的时候，我曾经用「我要做男神」几个字作为手机壁纸，一个同班的女生手贱拿起我手机来看 -_-，她当时就说了：「好想砸了你的手机。」我…… 还是太愚蠢了，根据墨菲定律，只要设成了壁纸，就肯定有被别人看到的那一天。本来这位女生高一就觉得我有点腹黑，这件事之后更是跟我结下了梁子，怎么都看我不顺眼，同学聚会还找我的碴。当然她对我印象不好，也是有一定原因的，例如当年的我会因为偶尔的好成绩而趾高气扬，成绩好人品好的人才不会这样。）春节过后又是跳槽季，当然我完全没有这个打算。一年多来身边离职的同事也不少了，看着清空的工位、床位，就会想到曾经熟识的面孔已经不在了，心头就会涌起一阵悲凉，不禁感慨「物是人非」。虽然我是个感性的人，但也早就习惯了，说是麻木也好，已经不会那么容易感慨了，大概是因为跟离职的人羁绊不够深吧。正如你葬礼上会来多少人、会留下怎样的评价那样，你的离职能唤起多少人的「物是人非」之感呢？或许这种标准才能客观判断自己能不能算是一个「好人」。我希望自己尽量不要纠结外在的东西，身体健康、会独立思考、品行良好才是最重要的，它们才是常伴吾身的至宝。我不敢确信自己的品行过关了，毕竟人有高估自己的倾向（以保持自尊）。希望：即使我的物件、积蓄、住房、亲友，一切都没了，我依然可以凭借自己的力量在这个世界上从头再来，自力更生，活得好好的。日常到底需要多少娱乐日常到底需要多少娱乐（动画、漫画、游戏、旅行、美食）？欲壑难填，永远都不会够的。我曾经想过这样度过一天：集中做一两件重要的事，其它时候就不虚耗意志力去做一些性价比低的学习了，而是尽可能恢复意志力 —— 好好运动、娱乐放松，也许能提升总体的产出。经过尝试，感觉这方法我用不了。娱乐多了我会上瘾，然后就停不下来了…… 有惯性，一旦脱离正轨，就很难扳回来。后来在「得到」App（罗辑思维出品）的一期音频节目 《意志力是情绪不是资源》 中，了解到一篇在《哈佛商业评论》发表的文章《The Way You Think About Willpower Is Hurting You》推翻了著名的「棉花糖实验」。大多数关于意志力的自助理论因此失去了理论基础，所以这个发现值得了解。基于上面这个研究，我决定以后还是尽可能自控算了，少去玩多做正事。虽然还是会间歇性颓废，但尽量一直坚持做正事，以便保持好的精神状态，凭借情绪上的惯性，多产出些价值。已经尝试过宽容地对待自己，期望自己能在轻快的环境中，争取到长足的进步，结果被自己打脸了。兜兜转转又走回「克己」的老路，因为这样从结果上看还稍微强一点。GTDGTD 的方法适合我吗？我以前迷恋的不是「Get Thing Done 把事做完」的成就感，而是那种整整有条的秩序感。因为我有强迫症，只要把事都安排好了就会产生满足感。但是提前得到满足感反而降低了「把事做完」的意愿，阻碍了待办事项的实际完成。这是在逃避，用「事务安排得当」的快感掩盖「事务无法完成」的耻辱，自欺欺人。每天都会产生新的待办事项，其中一些放在那之后就再也没有动过，它们好像值得做，也许某天会做，但却遥遥无期。待办事项一旦堆积起来就会对强迫症的我形成心理压力，达到某个临界点，就必须清理，只留下真正重要的事情。Later/Maybe never comes.文摘复述说不到点子上，还不如直接看原文。（推荐度自上而下递减）《驱离的世界：社会分层与阶级固化》《城堡的落成：上升通道即将关闭的中国社会》《被吞噬的中产阶级》《房地产、银行、贷款、政府、贫民、富民、泡沫、经济崩溃，他们之间是什么联系关系？》房地产问题。《JOIN创始人鸡汤》为什么你看了那么多商业案例，还是做不好一个小生意？《科技如何劫持人们的心智》 —— 来自一位魔术师和谷歌的设计伦理学家(Design Ethicist)《我与清华的差距在哪里？》《左耳朵耗子：不灌鸡汤，说真的年龄渐长，技术人的发展之路该怎么走？》《所谓的干货满满，所谓的勤学不辍》 我感觉自己脑子里塞了许多没卵用的「干货」……《你知道吗？每个时间管理方法都只适合解决某一类问题》「你是奴隶」我们郡有一位黑人法官，宣判时经典的一套说辞就是以“某某某，你是个奴隶”开头的，这段话经常被反复套用。比如对于屡次吸食毒品的被告，他会说“某某某，你就是个毒品的奴隶。每次你拿起那包粉末，你就是在对这个世界说，我不想当一个自由的人，我宁愿像个奴隶一样穿着橙色的囚服，被人关在笼子里呼来喝去。”有一次，一名黑人被告听了这句话就炸了，“你再说一遍？！你说我是个奴隶？” 语气非常有火药味。法官看了他，示意记录员不要这段话不要记，然后开口了“你被人叫过几次‘nigger”被告怔住了，nigger是一个非常具有种族歧视意味的禁忌词，本源上仅仅是一个中性词，但后来被暗指“黑奴”。“你可能没有数过，我也不知道，但我觉得我这辈子被叫nigger的次数比你多。在我长大的时候，很多人都随口叫我们’黑奴‘。当时我决定要努力证明自己不是一个奴隶，我身上没有一条枷锁。XX先生，我在你身上看到了很多枷锁，有酒精和毒品，有你每天鬼混在一起的人，有你的控制不了的愤怒，你是它们的奴隶，所以在这里，我要叫你一声nigger”“那么，你想要自由吗，nigger”《当法官说“不要记录”时，就可以默默掏出小本子了》「没有时间」TED演讲：如何掌控你的自由时间我们并不是通过节省时间创造想要的生活，而是先创造想要的生活，然后时间就自动节约下来了。例如，你通过录制电视节目、或者购买视频网站的会员，然后你就能跳过所有广告了，每半小时节省 6 分钟，每两小时那就是 24 分钟，然后这些节省出来的琐碎时间就可以用来锻炼身体了。然而真正正确的方法，则是不要去看电视（当然这很难做到，所以前者是关于放纵和进步的一种折中选择罢了）。时间的弹性是很强的，我们没有办法创造更多的时间，但时间会得到充分的利用，这取决于我们选择用时间来做什么。所以时间管理的关键就是对待重要的事情，就像对待坏掉的热水器一样！「听着，劳拉，我做的每件事，花的每一分钟，都是我的选择。」她没有说「我没有时间做甲乙丙丁」而是说「我没做甲乙丙丁，是因为那不是最重要的事」。「我没时间」通常意味着「这件事（对我）不重要」。各位想一想，这才是更准确的说法。如果说我没时间擦窗户，那其实并不是真的，如果你愿意给我一百万美元，我肯定立刻就去擦！所以，我们可以就此确定，这并不是时间不够的问题，隐藏在这之下的潜台词是「我不想去做」。这个说法能够提醒我们：Time is a choice.喜欢的异性能与他势均力敌，这点非常重要。其他很多答案说温柔有趣聪明善良，但我觉得那些都还不是最主要的。对于任何心智健全的男人来说，理想的爱情都应该是男女平等的。因为人与人的任何形式的交往，说白了都是人生路上的同行，想一起走下去，两个人要顺路，步调要一致，还要有不间断的相互吸引，以及很多共同话题来消磨漫长的旅途。设想一下，你与一个只能靠你搀扶着才能走路的伴侣蹒跚前行，可别的情侣手拉着手嬉笑着向前奔跑，你觉得你离失去对现任伴侣的好感需要多长时间?只有两个人前行的步调一致，才会衍生出接下来的，吸引力和共同点的问题。《女朋友的哪些优点最让男朋友喜欢？》意淫中，可惜我肯定没有自己想象的那么优秀。政治年少曾经对所谓政治问题很感兴趣，不过中二热血而已，只是把它们当做一种高逼格的谈资。后来，我觉得了解政治很没意思，还不如专注到工作学习上，政治这种东西草民知道了明白了又怎样，又不可能改变什么，还不如提高自己，多赚点钱，快快乐乐地生活。现在又觉得政治和历史对我有用了，人不但要靠自身努力，还要看历史的进程。人不能逆势而为，更别说自己只是一个无产阶级的草民，没有天资和家底。了解社会的变革趋势，虽不能常胜，但至少能立于不败之地（不败就行），以免沦为被国家牺牲、社会抛弃的那一部分人。行业发展、买房、投资、户籍、留学、移民…… 太多事情都跟政治息息相关，所以不得不重视政治。所以上面的推荐文章，有好几篇都跟政治有关。迷思“Enrich the life” or “Advance humankind (yourself)”?Learn from Apple’s mission statement.U r not alone.可能需要的不是「朋友」，而是一种「我不是一个人的感觉」。残酷觉得理想生活更应该是平衡的：细水长流、平稳踏实，偶尔（一天半天）疯一下，点到为止；而不是常常走极端，持续在 Play Hard、Work Hard 之间反复游走，毕竟过犹不及，心态乱了，就不能好好做事了。慢慢地觉得平淡而充实的日常生活中只要偶尔（每周或每月）有点可以期待的事情，比如想追的动漫、影视作品，我就可以继续活下去。可是我也觉得生活是一场战斗。快速成长，就需要不断挑战自己的极限，就好像长肌肉，就要不断冲击肌肉力量的极限，让肌肉纤维断裂后再恢复才能增长。然而人通常是好逸恶劳，如果有优渥的家底，一般更倾向于轻松愉快的人生道路，毕竟何苦自讨苦吃。那人为什么还要这么矛盾地去努力？大概因为危机感、竞争意识、妒忌心。单纯的好奇心、上进心是罕见的，如果有人能这样，大概是幸运，都是天纵英才，不是我等平庸之辈所能企及的起点。明显残酷的环境才能成长得快。我现在的工作再忙也好，还算宽松。这两年进步特别慢，做到的事情也不多。感觉大学的时候干成了不少事，但现在都觉得没有意义。可是现在干成的事倒是更少了……Overqualifed 过度胜任我认为在这个时代，人才越来越过剩了。很多坐上公司、政界高层的老一辈们，虽然在当年他们也是人群中的佼佼者，但如果要重新竞聘上岗，很可能竞争不过现在的年轻人，毕竟有的是高学历、见识广博、能力出众的年轻人。现在绝大多数岗位都是 overqualified（过度胜任）的，竞争太激烈，必须拥有比这个岗位实际要求高得多的能力，才能从岗位的竞聘中拔得头筹。所以才有那么多人感觉「怀才不遇」，觉得自己屈才了，做的工作沉闷、没有意义。这确实是态度没有摆正，这个社会不看绝对值，而是看相对值。现代拥有更优越的学习条件、优渥的生活，和平而繁荣，然后大家的起点都变高了，竞争还是一样激烈。贫富分化，让出生在有地位和财富的家庭的孩子起跑线远远领先于一般人，还有人生保底 —— 我们的玻璃天花板，可能只是他们的玻璃地板。人的适应能力很强，新的设定也能很快的接受。所谓成长，常常也是被恶劣环境逼迫下进行的，不然哪来那么多主观能动性！稀缺性薪酬跟稀缺性相关。即使你是天才，但是做的工作，替代性很强，多聘用些人就能做到，那么价值就有限了！为什么我现在才看重这个？悔之晚矣…… 我确实太保守了。价格（薪酬）基本根据需求供给曲线来，并不取决于绝对价值。审美趣味人生快乐的阈值的不断地上涨，而且也慢慢地形成了基本的审美情趣（兴趣），对于「什么东西能触碰到自己的 G 点」这个问题的答案越来越明晰。人生的许多「第一次」已经没有了。好像曾经很喜欢 KTV，但是玩坏了（麦霸很讨人厌，需要有人愿意给你鼓掌的人，不然很没意思）。密室逃脱、桌游、射箭、爬山、滑雪、旅行、美食，新鲜感一旦过去，还没有好友陪同，就压根不想参与了（「出去玩」的意义和乐趣，通常就是「和好友在一起」）。对于一般人来说，金钱、时间有限，不可能像富豪那样总能到陌生的地方，获得新奇的体验。日本失落的十年、二十年，成就了日剧的兴盛，因为这是很廉价的娱乐，性价比超高。我沉迷「ACGN」正是因为它的廉价，性价比高。一般的文化娱乐的水准，就是我人生乐趣的保底线啊！人生真是很麻烦呢，要是没有那点点乐趣，很难说能不能坚持得下来。若是感觉啥都没趣，非常无聊，那就再努力一把吧。人生真是烂游戏？！要保持适度的饥饿不但可以减肥，还可以保持知觉的灵敏，比如对食物的感受力。体重秤虽然很少用，但是却是不可或缺的东西，时刻提醒你保持克制。春节以来我也重了5斤，而且体重有不恢复原样的趋势，果然要步向中年了，是不是要慢慢发福了？吐槽吵闹和抖腿特别讨厌下午写代码，有时吵得跟菜市场似的。有必要总是说那么激动，声量足够沟通就够了，有没有必要声音那么大，甚至会觉得那是教养问题。发现那是他们的习惯，刻意地提醒一次、两次、三次…… 都是没什么用的。另外一个我特别讨厌的习惯是「抖腿」，它会让我对一个人的评价下降一个等级。虽然我觉得自己自控力不行，但大学期间我就愣是把自己的抖腿坏习惯给改了，因为我真的觉得这是个很没品的习惯。吐槽自己好活谁不会干啊，但是脏活就不一定了。业务代码都写不好，还能写好啥？眼高手低！我实在不想再当眼高手低的人了，我需要积累实际的工程编码能力，又快又好地写好业务代码。首先勇于直面脏代码！要多看代码，习惯看代码，看懂代码，而且要看得快，迅速理解要点，而不纠缠于琐碎的业务细节，看清本质。毕竟我是个强迫症、细节控，所以更加需要小心，不能「陷于细节」，一叶蔽目，不见泰山，大项目里这可是大忌。只要跟高速发展的业务相关的代码，就基本不会有干净的时候，其中包含许多你难以置信的低级错误，但却神奇地一直运行着…… 大公司就是这样，不需要太多技艺超凡卓越的人，不需要你代码写得多漂亮，只要写出来的代码可以按照要求运行，有 bug 就修修补补将就着过是完全没有问题的。后记这篇文章拖了很久…… 终于我不能忍了，下狠手删减了很多内容（读者：喂，你到底想写多长……），然后磕磕碰碰写完了。希望我自己和读者都能有所收获。（对本博客为数不多的读者表示：）谢谢您的阅读。Later never comes.]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 秋]]></title>
    <url>%2Fthink%2F2016_fall%2F</url>
    <content type="text"><![CDATA[秋清爽的九月，正好是北京最舒服的时候。只可惜北京的秋天太短，之后又是我讨厌的冬天。每日计划与反馈（后来终止）我的 微博 从最近开始，每天发布前一天的反馈和当天的计划。其实我私下一直有写反馈和计划，不过通常更简短。这些私人的东西不需要公开。那么，公开是为了展示自己有多能干么？不，恰恰相反，我是为了用“别人的目光”来逼迫自己多干一点“正事”。从目前的情况来看，我的执行力不怎么样。不然大学的时候，我早该拿到奖学金了。例如，关于早睡的「0000睡」几乎每天都出现在计划中，结果多少天了，我几乎没有哪一天能够做到，反馈的时候，就净写了各种“借口”… 只出一两次意外情况还说得过去，但是每一次都这样，我只能说：肯定是自己的毛病。无论别人到底关不关注我的微博，公开的「每日反馈与计划」都会让我我产生无形的压力。公开这些经常没有做到、久未完成的计划，让我不得不正视现实、感到羞赧，然后有内在动力去想方设法地一点一点改正自己的拖沓习惯。（想念高三时期的执行力）制定的目标，尽可能向「可度量」的标准靠拢。我在这个方面暂时还是没有做好。持续时间不长，我至今一直都如实反馈，以后也会坚持。毕竟自欺欺人没有意义，假装迟早会露馅。对「每日计划反馈」的结果感到自责也没有用，要的是立即开始实实在在地做些事。文字靠做自媒体（包括播客）直接挣钱不容易，不过它们还是有价值的。可以通过它们来展示自我、打造个人品牌、拓展影响力、给职业生涯“加码”。我自觉实力不济，只能在这个角落里写写个人博客，权当消遣，没耽搁正常的工作学习，就不错了。那些做得好（影响力大、能挣钱）的自媒体人，不仅靠「能写会说」，还靠个人成就背书，才能够吸引足够多的关注，才有足够多的受众把他们的文字当回事。泡社交网络、混圈子“很没意思”（收效甚微），别人还是看不起你。所以有「成果」才是最重要的，至少你能够比别人多干活。消费观尽力买最好的在可承受的范围内，买最好的东西（物品、服务）。这是大学以来，逐渐深深扎根到我脑中的一个观念。虽然我家只不过是一个大城市的小市民阶层家庭罢了，顶多算小康。但是家人舍得给我钱花，我也舍得「月光」给自己花钱，从我买来用的 物品和软件服务 就看得出来。除了其中一些太贵的软件，我基本都买了正版。在刚开始工作的半年，虽然我经历了退租换住处的风波，损失了不少钱，但是还能够攒到一些钱。但是从 2016 年开始，我开启了「买买买」模式“猖狂”地花钱，每一个月都有购买或多或少的贵价物品和服务。一月买新蓝牙键盘、触摸板和新羽球拍；二月有回家过年的各种花销；四月换了新居，之后开始按季交更贵的房租；五、六月买了电动牙刷、冲牙器，还开始陆续买更多的正版软件；七月去了冲绳旅游（团队建设）；八月买了山地车、羽球鞋和羽球衣，洗牙、补牙各一次；九月拔了两次智齿（两颗），买了新手机、千兆网线转接头；国庆各种聚会、采购…… 消费需求无穷无尽。例如，新浪新总部大楼的无线网络太差，需要使用物理网口来提高网速，以提升工作效率。大部分同事都用 MacBook Pro 办公，而它没有物理网口，所以需要购买网线转接头。大多数都勤俭持家地选择购买 ￥59 绿联的转接头；我则到苹果官网买了 ￥258 的 USB 3.0 千兆网转接头…… 然而其实其它人大多数挣得都得比我多。虽然我不愿意承认，但是实际上我已经是「月光族」了，慢慢理解了想要“剁手”的冲动。我开始怀疑自己的消费观是不是正确的：好像有点不理性，为了最好的体验超出自己的承受范围，我大概应该根据性价比来购买，节制消费。虽然觉得自己这一年该买的都买得差不多了，但还是很怕人性的贪婪 —— 接下来我将不可避免地发现更多的购置需求，加之已被玩坏了的消费观，会让我买得「根本停不下来」。之前买东西都会再三斟酌，买回来都得有大用。但若是真的很想买，最后还是会屈服于内心的欲求；过程的纠结，感觉只不过是为了酝酿一个“名正言顺的借口”罢了。题外话我的收入水平和消费水平之间存在落差，于是认知失调了。我目前不敢交女朋友的一大忧虑 —— 自己追求使用最好的物品和服务，又怎么能亏待自己的女朋友呢？我为了活好自己，都有点力不从心了；同等消费水平又能够与之独立平等交往的妹子又看得上我么？我好像并没有那么大的魅力。是因为我比较“理性”、“自私”（甚至说“没有爱的能力”？），只想自己活得好，不愿意为妹子付出更多？或者是因为那个我愿意为之不计成本、付出更多的那个人还没出现？可能因为过去的我觉得自己高攀不起那些曾经仰慕的人，所以慢慢变得更关注自己，想着有一天我能够成长到有底气去追求她们。结果我是慢慢变成了只关注自己、不愿意为他人付出太多的人了吗？断舍离数数看，我买了不少多余的东西：耳机 ATH SQ505：压耳朵，戴久了疼。Topumbrella 的超轻伞：伞面太小，不实用。Magic Keyboard 和 Magic Trackpad 2：即使我觉得它们真的很好用，比 MacBook Pro 机身自带的更好，但是它们毕竟还是多余的（非必需品）。还好近期忍住了没有再购买机械键盘。Kindle Paperwhite + 亚马逊官方皮套：虽然它不伤眼，但是 6 寸的屏幕大小，看技术书籍不够用，页面加载不够快。有了 iPad Air 之后，我就不想再使用它了。（最近卖给了亲友）iPad Air + Red Smart Case + 真皮套：最纠结的鸡肋，食之无味，弃之可惜；有了 iPhone Plus 后，除了偶尔使用它来观看电影、阅读，鲜能派上用场。「断舍离」真是一个需要不断提醒自己并付诸实践的概念。最近被《生活杂谈－物的理念，兼断舍离》提醒了：我不想再被不想要的东西牵绊！从大学开始就应该多购物，钱不多买不起一手的，就买二手、三手的。然后从低成本的试错中，知道自己喜欢什么东西，需要什么东西，适合什么东西，知道怎么购买划算、省心，建立正确的消费观。不要学我，刚工作才攒到一点小钱，就开始铺张浪费。后话最近刚到手的手机，我竟然想过退货，或者卖掉旧手机。反正，我竟然开始陆陆续续把一些闲置的东西到「闲鱼」上开卖，最后卖出了两件，其它的就算了。想到我竟然为那几千块钱纠结，真是惭愧至极…… 卖东西是一件比较麻烦的事，有时间讨价还价，我还不如去学习呢。这次持续超过两周的纠结，算是对我的消费观的又一次考验。恶习虚荣我经常在获得了一点微小的虚荣之后，就满足了，没有进一步的行动，真是没有出息。感觉我大学时期的学习、社团、实习，没有做到个人的极致（最好），有部分原因就是虚荣，当然首要原因是懒（还有习惯不好、方法不对）。好像自己过得还行，可是不敢看某些旧日同窗的朋友圈、Facebook。因为看着 ta 们的生活，就觉得自己处于“水深火热”之中：ta 们的前途一片光明，而我的则「前路茫茫未可知」。没有家底，资历尚浅，混得不好，可以滚粗。恶习循环「历史总是惊人地相似」，好像是一种循环，换了一批又一批的演员，重演了一遍又一遍。顽劣的恶习也是，销声匿迹了一段时间之后，又再复发，从一个极端走到另一个极端，又再回到原点。我经常会意识到自己在文章重复着某些牢骚：恶习又复发了，所以又应该开始反省了，于是又换了一套说法去重新总结某个道理…… 只奢望「重蹈的『覆辙』，每次都能再浅一点。」物质循环挣钱购买更好的工具和服务提高效率舒心地享受打磨工具、磨炼技艺（学习）致力生产（工作、成就）挣到更多的钱（或提升地位）南国之夏闷热的空气，狠毒的蚊子，反复地提醒你已经回到了南国。国庆放空，许多时间花在交通和逛街上，像平时那样一直听播客吸收信息，但是时间太长太累人，耳朵也受不了。所以摘下耳机，不断思考，用手机及时记录各种随时迸发的零碎想法。碎碎念逛街心里装着想做的事，就不会去做那些乱七八糟的事了。现在我就觉得，逛街也算是件乱七八糟的事。逛街，更多的是逛回忆，回头来每次逛的都是那些地方。偶尔想尝试逛逛没去过的地方，总是浅尝辄止。这次想逛东山口只走了没几步路，这段尝试就无疾而终，因为走得有点累了。广州地铁进展迅速方便，基本不用怎么安检，虽然还是有人拿着手持安检器来扫背包行李，但是也只是扫一扫就行了，没有大碍。朋友圈讨厌别人不搭理你，却又不删掉这些微信好友，又爱又恨，就是别人有价值，可能他日有求于人！赤裸裸的功利主义！？更多是碍于情面，怕破坏本来就萍水相逢的脆弱关系。可是人还是需要关注，只要有关注，人还是觉得需要好友关怀。播客 TED 演讲中文朗读版 的《是什么造就幸福人生？哈佛75年追踪研究告诉你答案》（What makes a good life? Lessons from the longest study on happiness. By Robert Waldinger）它说：对于幸福来说，比起成功，人际关系更重要。对于总是汲汲于「功利」的我，还是比较不习惯接受这个设定。但是你临死的时候会去想想：“我还能不能再多工作一会吗？” 感觉怪怪的，甚至有点荒谬。谁会在乎这辈子上班是不是上得太少了，工作得还不够多？毕竟工作通常只是为了赚更多的钱，然后更好地享受。即使真的在乎工作，大概也是因为在工作中能获得乐趣、成就感：工作只是手段，人生还有更重要的东西要追求。贪婪想了解人有多不自知和贪婪，来看看大家怎么吃自助餐就知道了。有时明明食物是充足的，完全没有必要这么贪婪，那些丑态真是太可笑了。无论是三流的 KTV，还是新浪的自助餐厅（不过吃相更文明点罢了）。读书与游戏打游戏，给予源源不断的即时反馈，让人欲罢不能。只不过我用刷微博、刷博客、看杂志、读书，代替了打游戏的习惯罢了，本质还是一样的即时反馈。漫无目的的阅读也没有意义，我还是读对当前的我「有用」的书好了，好好做笔记、总结，应用于实践、生产。没有实际的生产，阅读没有价值（现在暂时是这么想的）。佐仔志实话说，这个我觉得不算优秀的博客。刷了他几年来的博客，感觉博主长进不大（原谅我任性的评价），至少不如我自己想像的那样，博主飞速成长，走上人生巅峰。只是简单成家立室，一点点地收入增长，慢慢地改善了生活，好像“境界”上升不快。突然间，我想到了什么，不由得怅然若失：我以后会不会大概也只能做到这种程度呢？有点不甘心。和壕吃饭节俭 &gt; 奢侈和真正的“壕”师兄吃饭聊天，他说我换 iPhone7 太奢侈，这样下去攒不到钱。我何尝不知道呢。这并不是相悖的观念，我两的做法，深层次都一样，只是处境不同。壕不缺房子，但是也开始希望靠自己攒钱买房子，而不是仍然靠爸妈。壕富极而俭，他也享受过，留过学，游玩过祖国的大好河山，甚至周游世界。我看起来暴发户，但是我觉得比起昂贵的工具，自己的时间值钱。我需要更高的效率去节省出更多一点的时间，所以用最新最快最好的工具。而我只能纠结些工具、方法论，不时想想有没有更优解可以更快出人头地。可能还有地区文化差异的问题。北京的新浪里绝大部分都用iPhone，我组里十几个，没剩几个不用苹果的。但是在务实的广州，我壕师兄在网易的某个 iOS 的开发组都不好意思拿 6 Plus 来用，因为其他人竟然基本都不用苹果，要不是用测试机开发，就是用虚拟机，顶多借其它同事的手机，真是太低调务实了……壕可以过几年做回小生意，我则没有资源和机会，还见识狭隘，难。做选择最近练习「做选择」。一件小事都列出考量标准、各方的优劣及其影响程度，麻烦至极。不过比起在空想、纠结中做选择，可能反而更省时间？这样有理有据，虽然感觉这个过程很浪费时间，但是只要将重要的判断依据、理论记录下来，就能有利于以后做选择。决定了之后，忘记了当初的理由也可以再回顾，更不容易反悔决定，为日后的决断积累经验（需要时间检验）。选择困难最近换了手机小屏的 iPhone 7 裤袋进出自如（怕贼啊），顺手。单手操作，不怕滑手了，单手输入更顺手了（可以换成系统自带的10键中文键盘，很好用啊，3D touch 吃），响应快如闪电，特别是解锁、开启应用，而且终于用上了 3D Touch，记录零碎的想法很方便。从用 Evernote 记录想法，变成了用 Wunderlist。iPhone 大屏 or 小屏？iPhone 7 plus优点：电量大，续航长！可以少带充电宝（我有电量恐惧症）大屏幕的视觉感受好，能容纳更多信息，适合影视、玩手游、阅读…拍摄效果更好，毕竟双摄像头（我不爱好摄影，这个可有可无）更习惯，毕竟用惯了 6 plus缺点：放裤袋难受，特别骑车、挤公交时，需要掏出手机或者放回手机时尤甚单手操作效率不高，右划返回的手势就用不了，站着坐车手拿不稳…iPhone 7优点：单手操作效率高！缺点：电量相对不足，续航相对短用惯大屏手机，视觉上不适应（毕竟平时挤公交不多，安稳地坐着工作的时候更多！）纠结了很久，最后买了 7。虽然后悔，但是已经适应。现在我轻描淡写，其实我这个强迫症在这个选择的过程中痛苦万分。iOS 输入法对比我用小屏手机之后，终于不需要再用输入法的单手模式了。可是选输入法比选手机更令我纠结。最大感受：纠结正是因为各有优劣，当前没有一个相对完美的选择。最后决定：主要使用「讯飞」，辅助实用「搜狗」！考量标准：实用（核心、常用功能）&gt; 功能多、齐全 &gt; 颜值（下文括号内的内容为个人的考量）列举：排除所有全屏输入法，因为经过我个人长期的使用验证（个人感受），小屏手机还是九键（拇指键盘）输入的效率最高。iOS 10键输入法：优点：3D Touch 移动光标很灵活（有点费力）滑动按键输入相应字母！可以精准输入拼音，甚至英文（用不惯，毕竟习惯了点按，只有输入符号数字才会滑动）系统自带比较稳定、启动迅速（次要）语音输入缺点：字词、表情的候选列表铺满屏幕，不方便选择！不能点划输入数字百度输入法：用习惯了。无明显短板，也没有杀手级应用，只是没有 OCR、语音输入等功能。工具栏可定制。有用于滑动移动光标的按钮。用久了，个人词库较丰富。触宝输入法：优点：键盘皮肤的颜值超高！（所有输入法中最高的！）缺点：没有便捷移动光标的功能！搜狗输入法：优点：滑动键盘移动光标，在文字输入时时也可以用，立即调整！（还不错）滑动输入汉字（可有可无，毕竟还是点按便捷快速，准确率高（试过，但是个人习惯很难改））云输入（个人感受）匹配词语、句子最准的输入法！（不过用得多了，各输入法的效率不会差太远）粘贴版快捷输入！复制文字后，输入法候选列表直接出现剪贴板的内容（真好用）输入法中，只有它有 OCR 功能！识别图片进行文字输入（杀手级应用）语音输入缺点：英文键盘的 ⇧ 等同 Caps 不利于输入单个大写字母！（反人类！其它输入法的 ⇧ 都是分三档的（小写/单次大写/大写）。不过可以用系统英文键盘规避这个问题，但是系统英文键盘不能滑动输入符号）入数字 0 的按钮布局位置不合理（很不适应，有点难忍）不能定制工具栏的常驻按钮，没法将「分享」按钮替换为更常用的「快捷短语」讯飞输入法：优点：公认业界第一的语音识别输入能力。准确率高，支持方言（我已经越来越多地使用语音进行日常的文字输入了）在非手写的键盘，竟然也可以滑动手写输入文字！支持 3D Touch 移动光标。工具栏可定制。缺点：没有明显缺点，只能说比别人缺了点功能（搜狗差点在我心目中胜出）其它补充说明：尝试「滑动输入」，搜狗拇指键盘和全键盘均支持（届时滑动键盘移动光标的功能不可用），百度的拇指键盘不支持。其输入速度在习惯后提升，容错性不如点按，毕竟滑动输入错了就得回退重滑一遍，毕竟点按输错一两个字母即可回退。又试了一次「触宝输入法」（键盘皮肤颜值太高），还是因为没有光标移动功能而不想用，小幅移动要靠系统的长按光标所在处再挪动实在太慢了，我不想让拇指离开键盘区（屏幕下半部）。真的很想用系统自带的拼音10键键盘，可是展开字词、符号的候选区时，选项铺开到全屏幕，最频繁使用的几个非常用字符却在最顶部，真是反人类。你看出我强迫症有多严重了吗？文摘大观你看起来很厉害，所以一事无成考70分的人是永远没有考90分的人厉害的，无关谁付出了多大努力。付出30%努力做到50%的人只能收获内心虚幻的成就感，那些付出了200%只收获了80%的人却能得到这个世界的奖励。年少，时光悠长得仿佛没有尽头，产生了流毒，现在时间很宝贵了，但是纠结完美、浪费时间的习惯很难一时间改回来了。发现自己越发地贪婪，还有不可满足。原来的人生主题是不可能实现的。所以我改变了我的人生主题。长日无痕（三）Work-life balance? 有舍才有得。他最头疼的事情是让美国员工多些狼性，少些 work-life balance。如果你去美国的同类公司看看（Cisco 没去过，但 Juniper 亲身经历），你会发现除华人工程师外，一个工程师典型的工作时间一天不超过六小时。极端的例子是早上近11点晃荡过来，在 Pantry 读读 USA today，然后午餐，餐后再来个半小时的散步，踱回来后开开会，写写代码，四点多晃荡走去接娃回家，晚上和周末找不到人影。你说这打了折的 40 小时怎么竞争？月饼与价值观这篇“李菊福”（理据服），道出了程序员的心里话。再引用 和菜头 的 微博：在互联网世界里，程序员就是巫师，大众就是麻瓜。巫师的事情和大众根本说不清楚，因为做大众太容易，懂得道德判断就可以了。所以，程序员宁愿去网站Github写程序交基友，也懒得和大众啰B嗦。而程序员组建起来的技术公司，也天然地压制各种麻瓜，推崇巫师文化。没有什么扁平化管理，不过是厌恶麻瓜罢了剖析楼市真相与趋势摘自时寒冰的微信公众号。实业家的愤懑做实业老老实实养活几千号工人，创造就业，生产产品，为社会做贡献，然而努力了十几年，却不如人家一幢楼赚得多。这算得上是不健康的经济现象吧？我对未来感到悲观。破灭买不起房子，更别说北京的房子了；也没钱移民，所以难以肉身翻墙逃离这个地方。我还没好好见识过欧美的花花世界，不确定自己会不会更喜欢那个地方，不过我猜自己大概还是更爱这里。可是房价上涨何时是个尽头？我相信我国之后的几十年还会变得更繁荣，但是我还是觉得一定能够在有生之年看到我国房地产泡沫的破灭，或许就在不远的将来。如果我能够活到 70 岁，那么离我离开这个世界的那一天还有 46 年 —— 我不希望泡沫破得太晚，以致人生后半段随着崩溃的经济，一直走下坡路。比起国家为保房地产「饮鸩止渴」，我更希望房价早日回归它的真实价值。「长痛不如短痛」，或许代价很大，但是继续维持现状不怕日后「站得更高摔得更惨」吗？我国的经济会触底，但是还是有很大可能慢慢地恢复过来，然后更健康地增长，生活随之又慢慢地变好 —— 我更喜欢「先抑后扬」的人生图景。看不透不是精英，不是权贵，看不透这荒诞的现实。房价疯狂，手上的钱不断贬值，挣的钱又不多…… 我能做什么呢？还是有一些事可以做的：买不起房子，但是租得起；没钱移民，但是有钱学英语。注意健康，买好商业保险（意外、重大疾病），保证病得起。留足“过冬的粮食”（应急的储蓄），将就着过日子，成本不会高。舍得投资自己，磨练秉性、才能。有学习的能力、挣钱的本领，无论什么世道，至少能挣口饭吃。Coding代码的 3C 标准摘录自 ruanyf 的 微博：代码（code）的 3C 标准：可理解 Comprehensible、正确 Correct、可复用 Composable。null 的处理摘录自 王垠的博客 文章《编程的智慧》：函数作者：明确声明不接受 null 参数，当参数是 null 时立即崩溃。不要试图对 null 进行“容错”，不要让程序继续往下执行。如果调用者使用了 null 作为参数，邧么调用者（而不是函数作者）应该对程序的崩溃负全责。上面的例子之所以成为问题，就在于人们对于 null 的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅地处理 null”，其结果是让调用者更加肆无忌惮的传递 null 给你的函数。到后来，你的代码里出现一堆堆 nonsense 的情况，null 可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了 null 是什么意思，该做什么，所有人都把 null 踢给其他人。最后这 null 像瘟疫一样蔓延开来，到处都是，成为一场噩梦。正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是 null，如果你给我 null，程序崩溃了该你自己负责。至于调用者代码里有 null 怎么办，他自己该知道怎么处理(参考以上几条)，不应该由函数作者来操心。真知灼见值得复习。电影Limitless 永无止境一部爽片。做一个高智商的人是怎样的感觉？白日梦想家《The Secret Life of Walter Mitty》我就是一个经常做白日梦的人。愿：让梦境照进现实。Whiplash 爆裂鼓手不疯魔不成活？长者曾经教导：「一个人的命运啊，当然要靠自我奋斗，但也要考虑到历史的行程。」所以时刻告诉自己，我是个平凡的人，可以接受各种失败。但我却不平庸，所以不能接受没有尽力抗争后的失败。众人和我我也很有天赋，但是并没有活得很好。只是因为我没有去努力而已，如果我「疯魔」起来，也能「to be one of the greats!」为什么我没有去努力？只是因为这不是我追求的生活罢了。这样可以回避努力的痛苦，同时保有高自尊。除了自己，天知道这是不是借口？尾声博客更像我公开的「笔记本」—— 我不一定会发布新文章，我经常会强迫症似地不断更新、完善旧文章。虽然痴心妄想，但是我还是希望这是本博客的最后一篇“扯淡”文章，以后“扯淡”都到微博去。你没有看错，目前的我还处于人生的初级阶段：感觉自己仍然还是一个没有执行力、令人讨厌的“鸡血男”。Winterwinter is coming.北方的冬天来得特别早，我讨厌的凛冬将至。我真的觉得自己活的太仔细了，我应该活得糙一点。我就是个强迫症，细节控，洁癖（整洁癖）……我太执着于一些无关紧要、没有意义的事了，整天瞎忙在这些事上，沉浸于塑造网络空间上那个虚拟的自己，实在太可笑了。其实网络空间的我，就是现实生活中的我的投射。如果现实生活中混得不好，那么在网络空间混的好的可能性，也不会高到哪去。自从我（被迫）弃了 QQ 空间这个坑之后，我也对技术博客心生退意了，折腾得够了，受够了。早前的我还想着那些人怎么那么没有耐力，这么容易就放弃写博客了，真是弱鸡。我突然更能理解这种做法了。现实生活中，有太多重要的事要去处理。即使给我配司机、保姆、秘书，我依然忙不完想做的事，不仅仅是有钱就能解决的，更何况我缺钱（穷）。学生时代仿佛无穷无尽的悠长时光，给了我深深的错觉，可以为一些鸡毛蒜皮的小事，只要我在意、乐意，就能蹉跎很久很久。现在哪里有那么多时间、精力去纠结、折腾，不能任由强迫症、“逃避”和“慵懒”肆虐我的青春了。要更专注于工作和现实生活。只有现实中活出一个更好的自己，网络空间里的那个虚拟的我才有存在的价值。我还是会继续更新技术相关的文章，不过尽量不写得那么“强迫症”（面面俱到、絮絮叨叨）了，过度追求那所谓的秩序、整洁、完美…… 没什么意义。现实中我还有太多太多的缺点要去改正。要把我的坏习惯都一点一点一个一个扭转过来，这就已经需要很多的很多的努力了，需要投入无数的时间和精力，还有长久不断的思考和实践。One at a time.]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活指南]]></title>
    <url>%2Fthink%2Flife_manual%2F</url>
    <content type="text"><![CDATA[纸上得来终觉浅，绝知此事要躬行。《冬夜读书示子聿》陆游听过读过的道理太多，只觉得不过尔尔。只有亲自 经历、实践 之后，才能对一些事有切身体会。当我（可能）想“明白”了这些事时，我才会总结、积累到这里，不时回顾。生活总结目标人生主题：专注选中两三件事，一生沉浸其中，专注使人快乐。选择可以因时而变，但是同时只能专注两三件事事业：服务端乐趣：博客其次：羽毛球、动漫、美食情感：友情人生目标：没想清楚但是希望自己想清楚的时候，能够有能力做到。所以要 努力 培养更强的能力，日后拥有更多的选择。努力（的理由、动力）问：“为什么要坚持努力？”努力才有可能！不努力，什么都不可能。（《钢炼》）努力也永远比不上“别人”，但你（的境况）会变得更好！虽然相对值追不上，但绝对值会上升。小心攀比，它可能会摧毁你的自信，让你丧失前进的动力。核心核心原则简短易记。带着脑袋做事慎取舍二八法则实用主义讲方法（论）多做事三思而后行自助清单原则细化。带着脑袋做事慎取舍二八法则以终为始，要事第一做事 &gt;&gt; 阅读结果 &gt; 过程健康 &gt; 进步睡眠 &gt;&gt; 饮食 &gt; 运动技术 (&amp;博客) &gt; 工作 &gt; 英语实用主义实用 &gt; 好看不囿于物：工具就是买来用的取用便捷 &gt; 杂乱 &gt; 极简必要就买 &gt; 节俭 &gt; 奢侈讲方法（论）不怕犯错，反省、改正就行朝着抵抗力最大的路径前进五分钟快速启动一时一事不苛完美，不责已悔取消许可，牢记理由颓废也要坚持做事刻意练习养成习惯远离诱惑多做事雷厉风行记时理财详述慎取舍二八法则以终为始，要事第一做最重要的事，不重要的琐事自然会找上门，不必特意费心处理琐事。装满瓶子首先把石头装进瓶子，再装沙子，再灌水，最后还能放盐。但是装的顺序一反，石头就再也放不进去了。如果不是每天只谨慎地专注一两个核心任务，而是粗暴地填补时间空隙，只会南辕北辙、劳而无功。一天 只能计划完成 一两件主要事务（或目标）设置一两件候补事务：放松或无法做主要事务的时候可以做的事务。计划好日程，进行时间分配并落实的时候，竟然还在纠结于做什么！？还是决心不足，没能坚定地去做更重要的事。还是没能够想像得到日后惨痛的后果。做事还是阅读？做 &gt;&gt; 学 &gt;&gt; 读（ &gt;&gt; 想 &gt; 玩 ）实践（学习的知识应用于实践）&gt;&gt; 学习（阅读并做笔记）&gt;&gt; 阅读 &gt; 空想 &gt; 玩乐多做事！少阅读阅读简单，做事很难，所以我经常用阅读来逃避做事。只有做事才能产生价值；阅读却不做笔记，不过是徒增谈资罢了。应该根据当前的实际情况，阅读、学习需要的知识，并且应用于实践。如果做事的意愿强烈、状态饱满，即使使用手机做事的效率较低，也要坚持在公交、高铁等场所做事！结果 &gt;&gt; 过程虽然过程很重要，但是结果更重要！结果导向，不过分纠结于过程中的细枝末节。例如「准确而完美的时间统计记录」并不代表「事情做得完满」。健康 &gt; 进步健康：睡眠 &gt;&gt; 饮食 &gt; 运动早睡早起，清淡、节制（七分饱），恢复精力。进步：技术 (&amp;博客) &gt; 工作 &gt; 英语根基，专注服务端，自我推销，职业精神。实用主义实用 &gt; 好看例如，买了一把极轻伞，后来发现伞面太小不实用，所以不该买。例如，贴膜保护手机，日后出手时更保值，但是这样很难用手势进行右滑返回的操作，影响效率，所以不贴膜。不囿于物：工具就是买来用的取用便捷 &gt; 杂乱 &gt; 极简例如，整理工位、房间：便捷就好，效率第一（省下精力做要事）&gt; 强迫症：费力整理虽悦己，但这快感太奢侈（机会成本大），还不如由它杂乱。必要就买 &gt; 节俭 &gt; 奢靡果断购买显著提 高效率、让生活更 省心 的工具 &gt; 设法用时间、精力来省钱（机会成本太大）&gt; 喜欢就买，奢靡浪费。讲方法简化人脑一时间只能记住很有限的东西，所以本文自顶向下逐步细化原则，便于：在状态不佳的时候，也能够把握住顶层的几条核心原则。无力深思熟虑的时候，也能够直接根据这里总结的经验来行动，简化思考。带着脑袋做事慎取舍，讲方法。我打算暴力拉开外卖胶袋时，一个北大牛人则选择巧妙撕开。想不到方法区分没有标志的两个水表哪个属于我家，其实只要关掉其中一个阀门就行了。我思维习惯的问题：懒得动脑子。（以上均为真实的故事）不怕犯错，反省、改正就行错过了，改正，以后不再犯 —— 这是神话。重复犯错是难免的，毕竟人非圣贤，不要背着太大的心理负担。朝着抵抗力最大的路径前进问：“不想做最重要的事，怎么办？”以前总是先做简单的事来「逃避」困难且重要的事。还不如缩短每天做事的时间，但是必须先做「困难且重要的事情」！打精英怪 同等时间获得更多经验。允许使用更多的时间放松来恢复精力。虽然降低了时间统计记录中的「名义时间利用率」，但是提高了「实际时间利用率」。五分钟快速启动问：“决定了要做什么事，但是没动力开始，怎么办？”万事开头难。可以靠「惯性」前进，但是也需要「初速度」。当你真的想做一件事（要事），其它日常流程都是阻碍和屁事：忘了做时间记录，就大致记录就好（过后不要强迫症似地求证），甚至用标准的一天记录替代也行！最后的结果好，时间记录就改好看些就行，否则就改差。一时一事问：“做事容易分神，导致精力涣散、效率低下，怎么办？”专注，一段时间只做一件事；做完一件事，再做另一件事。一旦开始做一件事，在做完之前碰到想到其它“要做、想做”的事，通通都用 Wunderlist 记下来，做完再说！虽然死板，但是只能这样。不然，思绪会越走越远，会逐渐忘了最初的目的，做了许多无关的事，浪费时间和精力。反面例子：打开微博 App 发表一个见解，刚好瞥见某条微博很有趣，于是就点击查看，还看了热门的转发评论，然后开始刷微博…… 过了好一会才想起发微博的事！即使做一件事，也要分步骤：写代码在加新逻辑，就先别顺手格式化代码。专时专用：针对各类任务，分出固定的时间段来处理（以便形成习惯）。狠招：甚至只盯着一块屏幕工作 —— 手机屏幕。使用「勿扰模式」甚至「飞行模式」。不苛完美，不责已悔问：“总是觉得自己做事做得不够好（事实上也是），导致自责懊恼，情绪不佳，难以继续高效做事，怎么办？”悦纳，接受一切负面情绪，接纳愚蠢可笑的自己。自责，于事无补，还不如立即行动！Done is better than perfect.例如，不要妄想做得完美，而幻想凑出一整段时间来集中做好一件事，这只会导致「温水煮青蛙」拖延进度而已。取消许可，牢记理由问：“觉得自己做事做得还行或者已经没有动力了，想要放松、放弃、放纵，怎么办？”想要放弃的时候，不要总是想着过去曾经做出的努力，以致过分放松，随意 “犒劳” 自己。例如，吃顿好的，庆祝减肥成功！而是去回想让你坚持做出那么多努力的理由，这样可以让你能够坚持得更久。颓废也要坚持做事问：“很颓废，什么都不想做，只想（过度）休息、放松、玩乐，怎么办？”更要坚持做事！只有这样才能改变现状。颓废不会因为过度的休息放松而消失；积极向上反而更有可能改善状态，至少还能获得有一些做事的成果。刻意练习只在「学习区」练习舒适区 –&gt; 学习区 –&gt; 恐慌区（暂时无法掌握的技能）错误：练习早已掌握的动作、技巧。正确：练习的精髓，不是达到指定的练习量、时长（一万小时），而是 持续不断地做自己做不好的事。分块「针对性」、「大量重复」基础训练分块的基础训练：分块：把一个技能，分成很多小块，分别进行 针对性的练习。基础训练：竞技运动的运动员，绝大多数时间（80%↑）用于基础训练，只有小部分时间才用于队内比赛。练习过程中，持续获得有效的「反馈」老师和教练的作用就是提供即时的反馈，随时及时地指出错误，建立对错误的极度敏感，一直练习到改正为止。练习时，精神必须高度「集中」「寓教于乐」不过是童话。苦练：专注做有难度的事，才算是在学习区练习。养成习惯问：“意志力不够用，每天有效（足够强度）的工作学习坚持不了多久，我弱爆了，怎么办？”意志力是有限的，像血糖，用完它，人就没有力气了。例如，肌肉锻炼了，它就会断裂然后恢复并长得更健壮。（该观点符合直觉，但是最近的 研究 推翻了「棉花糖实验」，让它丧失了理论基础。可参阅 《意志力是情绪不是资源》 ）形成习惯的事，几乎不消耗自控力。例如：刷牙、吃饭、上洗手间等，都能够由大脑自动进行，甚至已经产生了肌肉记忆，不需要额外的思考。内化：要 刻意练习 成身体的自然反应、下意识的选择，才不会纠结（费力反复思考）。养成/替换 习惯习惯回路触机：触发条件。时间、地点、人或物、事件（看、听、做）行为：惯常的反应、行为。奖赏：愉悦、解脱、感动。替换方法想改变习惯，先分析出其触机与奖赏。用另一种能获得同样或类似奖赏的新行为，来替换旧行为，从而形成新的习惯回路。循序渐进，慢慢替换为更好的新行为，直到替换为最终的目标行为。远离诱惑问：“经常被游戏、影视剧、聚会吸引，浪费了很多时间，怎么办？”除了「远离」，没有更好的方法，不要试图考验自身羸弱的自控力。我做不到“悬梁刺股”，即使做到了，也透支了自控力，难以持之以恒。在学习区以合适的程度努力，来养成可以持之以恒的习惯更高明。辅助：远离（诱惑）不良的工作学习环境，创造安静、少干扰的环境。番茄工作法。闹钟响起那一刻会让你抽离出来，重获对自己的省察力。保持良好的精神、身体状态，让自控力处于充足状态。补充动疾心静问：“不知不觉就做了很多蠢事，例如看朋友打游戏太久，即使知道自己本来应该要做什么，在那一刻也忘了，怎么办？”那些时候，你已经失去对自己的省察心（失神状态），根本没有意识到自己在干什么，所以也意识不到自己该干什么。清醒。知道自己此刻在干嘛，不偏离方向。（TODO：暂未想到直接、具体的解决方法。）欲求其上，必求其上上问：“总是达不到既定的目标，怎么办？”志存高远。目标要定得高，即使完成不了，也能督促你走得更远。所以可以定一个比原来的目标更高的目标，但是不能定得太过分，避免导致直接放弃努力。多做事执行力。目标：省时间，省精力（省心），高效，进步（做正事）。雷厉风行问：“优柔寡断，不知道该做什么，怎么办？”这时状态应该不太好，纠结太久状态会更差。应该果断：想到当前该做什么，就立即去做，打破坏状态。记时自省，提高效率。15 分钟为时间统计单位，划分出六种类型的事务，来对自己进行 时间使用情况的统计。写好 脚本 定期统计每周、每月、每年的时间使用情况，并会定期发布到 Life Logs。记法便捷：记录不要过于详细、复杂，否则会太费时费力，反而会影响做事。及时记录，减轻记忆负担，避免遗忘以致记录错误；但要容忍一定程度的记录错误，完满的执行远比完美的统计记录重要！理财便捷，适度消费，保值/增值，分担风险。支付：便捷微信 &gt; Apple Pay &gt;&gt; 刷卡 &gt; … &gt;&gt; 现金（避免取钱）支付账户：App 余额 &gt; 信用卡 &gt; 储蓄便于记账：记账默认支出账户是信用卡。（小心，使用信用卡确实会提高消费……）便于结算：只用每月为信用卡还一次款就行了，避免经常提现。记账：适度消费 —— 了解开支，控制开支记法简便：记账不在于分类和统计的翔实准确，只要达到足以「指导适度消费」的程度即可。复杂的财务工作会浪费太多时间精力，难以坚持。精简记账类型：分类过细、频率过低、没有统计意义的账目类型，要删掉或合并。别写备注：（除了大笔收支、借出、收欠等情况）别违背简便记账的目的：省时间、精力。抓大放小：只记每次公交卡、饭卡的 充值 用了多少钱，而非建立一个饭卡账户、一个公交卡账户，去单独记每次坐车吃饭的钱…投资：保值/增值一般消费：日用品、饮食是必须的，在承受范围内，购买较优质、健康的。财务：微信（支付宝）、房金所、金蛋理财（、平安金管家、U+优财？）智识：工具、知识、人际关系。在收入能承受的情况下，即使月光，也没必要恐慌。工具、知识：有必要（能够提升效率）就买。人际关系：尽量公平，别吝啬，要大方。保险：分担风险重大疾病、事故意外，是承受不起的风险，必须防范！参考：如何用保险保障自己的一生？（一开始会觉得有点麻烦，甚至昂贵，但是习惯就好。）情境不同于「原则」的简短，「情境」覆盖全面。避免重复思考：我尽可能根据本文总结的原则、经验来解决问题；遇到新的问题，在想“清楚”了答案之后，总结、记录到本博客。可能情景会慢慢变多，庞杂得令人困惑、恐惧。但是当前我对此的判断是：我要习惯这种复杂性，这里是速查手册，需要全面记录我的困惑和最后想出的“最优”选择。情境症状目标做法细则（部分条目不遵循本格式）保持统一一致的做事原则这样降低判断成本。制定一个合理长久稳定的做事原则，就不用总是要去思考“这一次”该怎么做（那就不用设置这么多场景）。要诚实、简单地对待自己（自欺欺人没有意义），可以免除许多烦恼。思考犯错症状：重复犯错，懊恼自责。目标：进步，少犯错。做法：犯错后，反省、总结，并记录到本文。想到改善的方法就去尝试，效果不好/无效，再优化/尝试，「不断试错，适时调整」，再总结更新到本博客。纠结症状：反复思考，以致浪费时间、分神（注意力涣散）。目标：果断，减少时间浪费，专注（集中注意力）。做法：针对更具体的情况做处理。选择困难：症状：「布里丹的毛驴」面对两堆一样称心如意且可吃到的干草时，驴却会因思考如何决定而饿死。目标：尽量迅速、果断地作出选择！做法：限定时间：限定在一个有限的时间段内，得出一个相对（局部）最优的选择，然后坚决地执行。理性类：用 一票否决制了解自身的核心需求，可能只有某个选项的核心优势能满足该需求，此时不能满足该需求的选项全部淘汰，剩下的选项基本所剩无几。列出需要考虑的方面，给剩余的选项给出各方面的分析评价，并列出各个选项的优劣。如果还在纠结，先接受现实，把心安定下来：给自己足够的时间，去继续耐心考虑、分别 深入尝试，自然会慢慢得出答案。感性类：难以用理性判断的事物，通常用直觉、情感做决定。非此即彼类：抛硬币例如，去还是不去，做还是不做？抛硬币，通常抛出的那一刻你就知道内心的答案了。如果对抛出的结果满意，就照做；如果还想再抛一遍，就选择另一个选项。诸多选项类：不能用抛硬币的方法逐个淘汰的话，就先用理性类的方法，剩下两个选项时再用抛硬币的方法。依然纠结？一、选择「最省力」的选项，一般就是：搁置不理（闲置事物、不做或随便做某事）。二、做别的要事，转移注意力。三、但是，你可能每次再碰到相关事物（todo、物品），都会唤起纠结的心情，想要再次做出选择，还不如：事务：狠心删除 todo 以及有关记录，或咬咬牙把它做完了。物品：卖了、扔了！三、绝招：「做一个满意而非完美的选择。」所谓另一条路，只是大脑虚构的别处。左右为难，就是因为它们各有利弊。要的不是反复的比较，而是要想一想：「如果你只有一个选择，它让你满意吗？」忍耐，习惯，接受。踌躇不前：哪怕成果再不堪，也要 尽快出第一版，再不断改进！症状：考虑得太多了，想要「力求完美，一次做好」，只会永远都做不完。目标：先「做完」，再考虑「做好」。Done is better than perfect.要加速做事的方法：第一步、第二步先随便做，没必要先准备好完备的工具、条件、外部环境！只要开始了，然后定期总结、回顾，慢慢就能找到适合自己的方法（完美的工具、条件、外部环境）并且坚持下去。自我怀疑症状：动摇的时候，我不时会怀疑我总结这里的见解、观念，开始纠结（反复思考），首先浪费时间，然后分神导致效率下降。例如：最近花钱很厉害，突然觉得自己日后挣钱的能力可能很有限，现在的行为很不理智，开始想方设法省钱，转卖东西。还不如好好工作、学习，提升自己挣钱的能力。待办事项or GTDTodo 要 精简「Less」不能多，待办事项一旦堆积，只是看着它们的存在，焦虑情绪就会日渐增长。心理压力大，效率低下，进度缓慢，什么都做不完，心理压力更大，恶性循环。只是「可能做」的事务，就 别记 下来了。可能 == 永远不会做。不要换个地方囤积 todo（包括其它信息）！放在奇妙清单、印象笔记或是博客，都没有本质区别。因为即使你压缩、筛选、转移过它们，也改变不了你没空做的现实。而且整理它们反而浪费了更多时间，更加没空做。Todo 要有 明确的短期限「Short Deadline」不能长，尽量是短期「一周内」可完成的目标，中期不超过「一个月」。长期目标（战略）禁止添加到 Todo List，应该记录到文章等博客页面中。比较久之后才到来 的事件（甚至期限比较长的事）记录到 Calendar 中，而非 Wunderlist。Todo 要有 可度量的结果「Measurable」做完，或达到某种明确的效果。「大而无当」的待办事项，极易导致拖延，然后永远都不会去做的。大而无当：没有明确定义边界 —— 怎么算是完成了。例如，“学 Docker”这一项。如果目的是提醒自己去学它，大可不必这么做。真正重要的事你会一直心心念念地想着，不必如此提醒，甚至会经常跳出来“提醒”你，总会有机会再碰上。做事强迫症症状：囿于细节，重复劳动（做无用功）–&gt; 浪费时间希望：少做无用功，节省时间、精力。做法：接受现实不要追求完美。这是不可能的！强迫自己接受现实。Done is better than perfect.事不过三折腾超过三次，即使手痒了，也要等第二天再继续！例如：反复阅读、背诵、检查确认、修改等。转移注意力假如做事的时候已经麻木得无法思考，就得换别的事做以恢复精力，避免继续做无用功。练习强行抽离，干别的事去，以转移注意力，用时间缓解强迫症。工作、学习营造有利于专注的环境。安静：佩戴消噪耳机，如果还不够安静，低音量播放白噪声或音乐，足够覆盖外部干扰。少打扰：在公司找其它地方办公，小的玻璃会议室、茶水区、公共休息、接待区等。手机、电脑开启「勿扰模式」（同事还是可以用 QQ、电话联系上）。写作、写代码专注，减少犯错。创造 和 规整 不可能同时做到。写作：叙述成文 和 咬文嚼字 不可能同时做到。写代码：编写逻辑/流程/算法，跟 格式化/重构 不可能同时做到。具体过程（待完善）写文章：先把所有的文字按照所想，一次性顺畅地全部表达出来，不要考虑文笔（遣词造句）、格式、逻辑。零散的摘录或个人的见解全部写出来。–&gt; 根据相关性，分类。–&gt; 感觉逻辑性，排序。–&gt; 每个片段，补充完整的细节、感受。–&gt; 考虑清楚段落、字句的意义（想要传达的东西，是否合适传播），剪掉无用的枝节。–&gt; 推敲遣词造句。–&gt; 通读检查、修订。写代码：先把整体框架和逻辑按照所想，一次性顺畅地写完，不要考虑变量命名、代码风格等问题，甚至先忽略具体实现，用注释说明来代替。大概思路：可能解决问题的方法，一次性表达清楚。–&gt; 核心流程：一次性成功处理的流程，不考虑失败的情况，用 伪代码/简单的注释 表示。–&gt; 逻辑流程：补充逻辑分支/边界，不考虑具体实现，用简单的注释代替具体的实现。–&gt; 大体实现：可以达到效果即可，不考虑性能、可读性、可复用性。–&gt; 细化实现：逻辑分支、优化性能、可读性、复用性。–&gt; 格式化：检查拼写、逻辑错误（条件分支的逻辑严密性）等，优化变量名、函数名、代码顺序、代码风格（或需重构）。工具使用工具症状：不舍得买贵且真正高效的工具和服务；太爱惜工具而妨碍正常使用；工具和方法设置太繁多、复杂。希望：真正做到高效。做法：去心魔：「君子善假于物也」，不囿于物，毕竟工具就是买来用的！用 尽可能少（且合适、称手）的工具，去做尽可能多的事。工具太复杂，使用起来会打乱思路和做事的节奏，使时间碎片化，做事低效。不过工具而已，用得舒心就好，不必纠结，重要是要用工具把事做成。把反复做的事情，自动化 —— 写脚本、买工具。手机高效的辅助工具iPhone软件和硬件都稳定、省心；习惯了 iOS 再切换到 Android，时间成本高。用小屏 iPhone，不用大屏（Plus）方便单手操作，提高任何情况下的操作效率；容易装进口袋。旧款大屏留作备用机取代 iPad，看视频、阅读；不用带充电宝，带两台手机就行了。实际体验后发现带两台手机太麻烦了，设备间信息同步不方便。大屏手机还挤占衣裤袋的空间，成了累赘，不能轻身出行（不带包），还不如带一个手机外加一个小的充电宝更让人省心。Apps效率、实用 &gt; 整洁、好看图标排列：使用频率越高，放在越靠前的屏，放在越顺手的位置。而非强迫症似地按照颜色排列。要用到 Apps 全下载好 &gt; 只留最常用的。如果想要用某个 App 到的时候，却没有安装，还要去下载，这样太麻烦了。反正手机闪存容量充足，没必要为了强迫症似的极简而牺牲便捷性。电脑电脑是高频使用的工具，要将其使用效率最大化！98% 以上的时间都在使用自己的工具，所以将它们改造得尽可能贴合自身习惯是值得的！当不适应其它人正常的电脑设置时候，请坦然面对：反正已经用自己的工具省了很多时间，用别人的电脑效率低点也无所谓。双重备份，有备无患：移动硬盘 + iCloud。微信将其限于实用，不要过度用于消遣。退掉无用的群。只删掉再也不用的对话，其它都别动！删掉的对话如果不久之后又会回来，追求视线清净没有意义。对话太多或没有，其结果都是要到联系人那一栏去找人。每天最多只刷两次朋友圈，看完就关闭朋友圈，下次看再去开启。QQ群、讨论组、联系人：不用管没有动静的，删掉又烦又没用还不熟的。其实没必要过于整洁，适当的凌乱更高效。因为过度的强迫症，会让人需要浪费时间整理，实际上这点程度的凌乱并不碍事，只是因为过度关注而变得神经过敏了，反而影响到注意力的集中。微博用于偶尔消遣，不要过度。每天最多只刷两次，看完就切换帐号，下次看再切换回去。内务穿衣简单，减少选择。可以参考乔布斯、扎克伯格，每天都穿一样的衣服。省出作出这些选择所需的时间和精力，去做更有意义的事。交通、内务利用碎片时间公交、地铁学英语 &gt; 读书 &gt; 看动漫、影视，玩游戏（放松）骑行、奔走、洗澡、内务思考问题、反省 &gt; 听英语 &gt; 听播客 &gt; 好友电话聊天（排解烦闷）听音乐、播客保护听力。音量不要太大：播客听清就可以了。音乐也别听太久：耳塞插久了，特别入耳式，可能导致耳部炎症。不打扰其他人的情况下，尽可能使用外放设备（例如蓝牙音箱）。睡觉避免打扰，提高睡眠质量。至少睡满 7 小时：恢复精力早睡早起：保持生物钟稳定、内分泌平衡佩戴耳塞：保持安静佩戴眼罩：保持黑暗保健预防疾病。感冒：平时多喝温水，合理穿衣，不洗冷水澡！没胃口：少垃圾食品饮料。住处强调：效率 &gt;&gt; 好看。便捷，方便生活，压缩内务所需时间。不用每周打扫，保持整洁就好，脏了再打扫。工位强调：效率 &gt; 好看。便捷，方便工作。不用每天擦桌子，保持整洁就好，脏了再擦。注意财物安全：临走把电脑锁起来，因为丢不起！承受不起的风险，必须防范！（一开始会觉得麻烦，不过习惯就好。）其它社交减少无用社交。勿交损友如果ta没有比我更优秀的地方，我就不交这个朋友。（三人行必有我师）忍耐寂寞，独处精进微博、朋友圈：每天只能午饭、晚临睡的时候，刷。不看其它社交网络（Facebook 等）。形象留下好印象。外貌：整洁。颜值也是生产力：做事时能获得一定的优势（大家或多或少都是颜控）。言行：谨慎，小声，谦逊。禁止：抓脸，捋发，翘腿，秽言。应该：抬头，挺胸，闭嘴。谈话慎言、学习（暂时「推销自己」是次要的）。（尽量）不说话，少说话。引导别人多说，从中学习。照顾别人感受。基于事实，别想当然，别自以为是。发表言论在微博、博客、朋友圈里，什么值得发表？（写什么更有价值（有用））Share &gt; Show off!展示成果：对别人有用！技术：解决问题的思路、过程。言论：转发文章，阐述观念。言论还是技术更有用？都会过时。好像言语比较隽永，技术比较快过时，最终都只会成为你努力过的证据而已。不过至少还有点用！摆姿态：意义不大…有上进心、有爱心，关心时事、民生疾苦，悲悯？不如韬光养晦做事。物质炫耀：尽量避免！消费了就可以秀的东西没有价值！只会显得low和穷。晒优越：奖项、名誉等，获得的频率本来就很低，随意发表就好。说了没有什么益处，还没什么人评论、点赞（感情联络、社交价值）就删掉吧。摄入信息（TODO）什么值得学习/做！？终止刷博客的习惯：博客从头扫到尾，生怕错过精彩文章书从头看到尾，否则不读，只吸收部分不行吗？这是一种强迫症吧？别人的错误理性。用别人的错误惩罚自己：糟蹋自己，报复别人，愚不可及！自学能力很重要，我以前太依赖老师和学校了。老师对你不好，就不好好学那一科，这是自我惩罚，太蠢了。本文的意义Life Exp 并不能直接解决现实生活中的问题，只是对我自己有指导作用。只有「做事」，才能把事做完。经常会因为拖延和强迫症，工作进度落下了，生怕同事、上司会责难我。虽然事实上不会真的当面道不是，但还是会内疚自责，慢慢地心理压力变大，感到痛苦，变得更容易拖延。其实只要把正事做好，就不会有痛苦了，才有安全感做自己的事。痛苦不是来自重大的事，而是来自于生活的那些琐碎烦恼。一天的流程（部分）做事前：要想像好接下来要做的事、步骤和注意事项。待养成习惯。早上：起床别看手机，先做完内务：提前醒来：摘眼罩、耳塞，待清醒。到时间：立即起床，梳头、戴头箍；拿毛巾、牙刷。喝水，小解/内务；刷牙、洗眼镜、洗脸；搽保湿（防晒？）、挂毛巾。收拾背包、换衣，穿鞋袜。夏骑行：冰袖、头盔、耳机、鞋、手套。冬骑行：面罩、耳机、头套、鞋、手套。上午：迅速做完杂务后，立即开始工作：到公司：小解、整理仪容；早餐/无。先到洗手间：洗手、洗眼镜/无。卸装、擦工位（1 次/周）、开机；盛水、喝水；内务/无；反馈计划、记时。工作：要事第一（先做工作）！五分钟快速启动！一时一事。雷厉风行。晚上：卸装：换拖鞋，卸背包、皮带、换衣服、放东西、喝牛奶。早洗澡：拿毛巾、牙刷、衣服、音箱、手机。洗头、涂护发素、洗身、刷牙、洗护发素、洗脸。搽保湿、挂毛巾、洗衣服。晚上再饿，也别吃零食；晾衣服、收拾背包。今晚不可能做完，第二天起床也可以做，所以赶紧睡了！我性格（曾经）懒于思考，不会思考战术上勤奋，战略上懒惰 –&gt; 净做无用功药方：做事，然后思考，不断总结。Todo：深入问到元问题。强迫症（细节控）囿于细节，重复劳动 –&gt; 浪费时间药方：见 上文Done is better than perfect.工具控囿于工具 –&gt; 本末倒置、南辕北辙假如你的工作是杀手，你为了提高效率，时常磨刀刃、买更好的刀……慢慢地你却变成了刀具收藏家、鉴赏家，刀刃都快磨没了，却没好好地干过几票。—— 梗来自于播客节目《内核恐慌》药方：实用主义。适可而止，尝试公认最好的几项就够了。穷尽 的坏习惯 to deal with看一本书，一旦开了头就要看完，除非内容太烂。偶然发现一个好博客，不但会看完，连它的友链也会一个个扫荡过去。那岂不是会无止境地浪费时间？那么我如何跳脱出这个恶性循环？要不只有当太忙的时候，我只能停下来，然后一段时间之后，自然无感了，不再耗下去。要不我刷得太累，刷到无感，才能停下了。唉，浪费时间。我在删除收藏的文章的时候，都会有点舍不得，恋恋不舍地打开一下，再看看里面还有什么值得看的。真是无可救药。纠结根据我自己对许多工具和方法的掌握程度，集中时间做一件事，好像效率应该挺高的。但是，大多时间省出的时间都用来考虑和纠结了。因为没有稳定统一一致的原则、价值取向。需要将其内化成身体和思维的习惯，达到“下意识就能作出正确决定，进行正确的行动”的地步。药方：眼不见为净。看不到就是不存在，至少先释放心理压力。陷于细节，南辕北辙习惯自底向上地做事，做一些微小的工作是很快有反馈，好像能比较快积累成就感，但很快会陷于细节，做着做着就远离原来的目的了…… 结果进展慢，还没做到多少有意义的事。如果你不能专注到核心任务，而是专注于填空时间空隙，结果只能是南辕北辙。反面例子：打开微博 App 发表一个见解，刚好瞥见某条微博很有趣，于是就点击查看，还看了热门的转发评论，然后开始刷微博…… 过了好一会才想起发微博的事！瞎忙，拖延，逃避愿望美好，执行不力 –&gt; 靡不有初，鲜克有终（虎头蛇尾）。症状：做简单的事，逃避困难。修订文章、代码的格式好看很重要（因为我是颜控、强迫症、洁癖），但是内容更重要。先有内容，好看才有意义。我还会费力维持整洁的工位、房间、物品放置等各种秩序，不过是为了回避做重要的事，而全做简单的事。药方：底线是 至少完成任务！这是职业精神。贪婪我一定是从来都没有明白，什么叫断舍离，什么叫精简…旧的人生主题：尝试尝试经历一切不同的人和事，让自己的生命尽可能的有趣、快乐。前提：足够的物质基础 –&gt; 挣钱 –&gt; 进步（现阶段）（“尝试”这个想法太“贪婪”，日渐膨胀的欲求难以满足，痛苦又难以自拔，所以废止。）我以为自己经掌握了当今的先进方法，其实还停留在上古的时间管理时代而不自知：妄想更少的时间做更多的事。因为做小事的即时反馈很足，读书经常能让你看不久就能收获一个新的道理，产生新的想法、灵感，感觉兴奋。所以对我来说，读书和打游戏一样，有着同样的即时反馈，容易令人兴奋得停不下来！而实际收获寥寥。讨好不当“老好人”，别太“乐于助人”，以致刻意讨好他人。学会表达不满/诉求，学会拒绝，关注自身需求（我就是想做自己的事，不想去吃大餐）。现象待整理、提炼。痛苦，就有解决问题的源动力。随时记录想法：有灵感无论如何先记下来其实想法很多，但是很容易忘记。只要你记下来，你会惊讶于你竟然有那么多想法和灵感，可惜以前都没有归纳总结。当然也会发现，你有很多冗余的想法，甚至一些垃圾想法。可是只有过一段时间，你才能甄别出这些智障的想法，真令人羞耻。想要去做正确的事，但是又有强烈的欲望驱使着要做其它爽的事。你通常会选择后者，这是人性吗？越理性就越感性：越是努力分析优劣，真正的渴望反而越是强烈，真理越辩越明，欲望越擦拭越昭彰。知道完美是不可能的，但是仍然不断有不切实际的追求。需要真正地「接受现实」：你不会为 1 + 1 = 2 而纠结，因为你已经接受了 1 + 1 = 2。难以割舍有趣的内容，总是想存起来，以备无聊时的不时之需！？不应该存起来。无聊时再去找有趣的东西，不必要存储！找不到就算了，可以放空休息，恢复精力。「标准答案」的思维惯性应试教育深植我脑内的一大信念便是：一定有“标准答案”，即使有多个答案，也应该有“最优解”，至少有“参考答案”。所以我总是习惯先去找最优解，而非应用实用、现实的做法：先暂时忍耐、适应现状，迅速行动解决问题，有空闲再不断去尝试，优化得出最优解。我经常花了许多时间纠结，却没有多去实际地行动，没有产出更多实质性的成果。看不到参考答案就恐慌，以致容易纠结，不愿意主动思考去自己费力答案。]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 春夏]]></title>
    <url>%2Fthink%2F2016_summer%2F</url>
    <content type="text"><![CDATA[图志毽球亚军天津星五洲杯毽球邀请赛 亚军在广东的时候，我的水平（中等）只能算战五渣。结果来到这种没有奖金的比赛（虽然也强但没那么多高手），凭着我们队年轻的体力优势（其它基本都是 30+、40+，甚至有 50+），在小组第二出线的情况下（真正技术不够强），逆转获得亚军（2/16）。运气太好，大概这是最后一次能拿到这么好的成绩了吧（虽然艰难，还是觉得有点水份）。冠军京津冀天津毽球邀请赛 冠军然而，万万没想到，仅仅两个月后的这又一次天津之行，还是同样的队员，发生了同样的剧情，小组第二出线，然而结局却是我们拿到了冠军了！还是因为年轻体力好啊。天津真乃福地。在这些高手相对没那么多的小比赛里，获得了以前不敢想的成绩。可惜只是看起来厉害而已，曾经有过唬人的冠亚头衔，就很高兴了。无论曾经多么热爱一项运动，只要工作、生活的条件不允许，在现实的压迫和时间的消磨下，热情总会一点点褪去。趁还一点空间和时间，偶尔坚持一下好了。怕是以后再也不能碰上这样好的光景了。新羽球拍旧拍多次断线胜利突击鬼斩几乎每周至少五天在打羽毛球，运动方面的注意力和爱好，已经几乎全转移到这上面了。自从 1 月旧球拍多次断线，勉强能和羽毛球老手能对上几球之后，终于考虑并买回一个好拍了。微博头条新工位（虽然只用了一小段时间）虽然临时被借调到别的部门的项目去，工作上有了许多新的麻烦需求。但也还是会有清闲的时候，也认识了些新朋友，日趋平淡的生活也泛起了一点新的波澜。雨访慕田峪（长城）不到长城非好汉。祝羊同学，日后大展宏图。意外生活充满意外。新居没错，很宽敞，因为我睡厅。而且只需￥1050。雨后某日下班，适逢雨后互联网职人的流动很快。或许为了多挣点，或许为了长远发展，或许新鲜感消失，对平淡或麻烦不断的工作心生厌倦，或许是为了家庭、妻儿而迁居…… 「聚散有时」。或许知道人事变动后的某一刻，或许是吃离职饭时，或许是回头看到那个收拾得干干净净的工位时，可能会怅然若失，发出那往事不可追的一声慨叹，即使离开的人啊可能与你并不熟悉。然后，你很快就会淡忘，然后习惯。2016 夏冲绳水族馆居酒屋部门团队建设。即使公司几乎不报销多少经费，自己多些花钱，也还是想要出去走走，积累宝贵的出国旅行经验。玩得开心，虽然海岛很闷热啊。骑行美利达公爵 300，入门级山地车，24速 + 油碟（液控刹车）本想着以后弃毽球，转行打羽毛球锻炼身体，由于现在交通不便、场地紧缺，每周又顶多只能打两场球了。更别说要结伙去踢毽球的场地有多么的路途遥远了。现在每天骑车上下班通勤，单程骑行时间 20 分钟，能顺便锻炼身体。只是太阳有点大，我怕晒黑，只能准备一打防晒霜了，还有袖套。冬天寒风凛冽，能不能保持一年四季都骑行呢？我希望我可以。新浪总部落成入驻新工位~网上有许多新总部大楼的美图，懒得贴了。反正我对新总部很满意，虽然饭堂伙食还是差点意思。住处离新公司总部更近，骑行通勤后，更是没有了错过公交末班车的烦恼，更喜欢赖在公司里了。文选如何毁掉你的室友如果你的室友是一位成绩优异的三好学生，而你又恰巧是一个毫无底线的心机婊，本文会告诉你，如何利用3个月的时间，毁掉室友的人生。明天，一切都不会好起来的明天，一切都不会好起来的。烦扰照旧、岁月蹉跎。直到你不再逃避下去。我每天都为自己打满鸡血「努力」是一件政治正确的事。可是人们「努力」的动机不同，「努力」的效果和在「努力」中的感受也会不同。……年轻的老罗不仅很努力，而且很需要「自己很努力」的感觉。而后一段经历中，老罗不会再关心自己努力不努力了，估计他也不想让粉丝用「乃们不要黑他，乃们知道他有多努力吗」这样的说辞为他辩护。他只想把事做成。……「虽然我还不清楚创富的道路在哪里，但头悬梁锥刺股这事我会啊！」……因为这种努力给他这样的感觉：「我正接近成功，努力会带我完成人生的逆袭。」没错，我正处于上文最后一句所述的状态。《大趋势》只推观点，不推书。我们被信息淹没，但是却渴求知识。时事新闻、有趣的文章，少读一篇，又如何？确实能触及到一些知识，却没有 Vision 视野和远见，没有甄选精华、祛除糟粕的能力，吸收信息反而是有害的。其实少看些，甚至不看也无关紧要，只要要靠谱的朋友圈，重要的信息是不会遗漏的。「弱水三千，只取一瓢。」吾生有涯，不可胜收。不要太贪心。已经看得太多了，得多干实事。学生时期，时间悠长得仿佛没有尽头，可以做完所有感兴趣的事情，包括浏览完所有感兴趣的资讯，唯独没有培养出足够好的习惯、思维、自学能力。程序员经常用谷歌好不好Do Experienced Programmers Use Google Frequently?“Never memorize something that you can look up.” - Albert Einstein不能被检索的知识，毫无意义。只囤积不能吸收的资料，或只阅读，却不做笔记、不内化成（思维、生活）习惯，那么你所做的不过是囤积信息垃圾罢了。感想微博头条被临时借调到「微博头条」项目组，交到了许多新朋友，这是意外之喜。那段时间工作更繁忙，但算充实，过得挺开心的，处理某些比较恶心难缠的 bug 的时候除外。虽然工作有点忙乱，但是反倒向心力更足，我真是有点后悔不留在那了。再看吧。我还是不够爱惜身体，太过晚睡晚起了。抱怨（经验）互坑一个开发，假设技术再好，还是可能碰上业务坑，部门协作信息不对称的坑。程序员或 PM 难免不小心就会坑到别人，程序员的代码实现做得不好还有 bug，或者说 PM 没把需求想得很不合理还经常变更。既然难免互坑，那么就本着「吃一堑长一智」的精神，互相促进成长，工作总会越做越到位。这次可能别人坑了你，说不好哪次你又把别人给坑了，所以大家工作沟通都该尽可能谦恭，毕竟都希望和和气气，不搞出幺蛾子，然后尽快解决问题。当然也会有心情莫名不好的时候，检讨…… 所以状态好的时候，更得多填坑，多攒人品。急躁毕竟一般没谁故意要跟谁过不去，如果程序员技术就是渣，做得慢了，做得还不够好，对他急躁和质疑也是没有帮助的。毕竟目的是解决问题，解决之后再去提醒，过后再去“撕”、反省、总结才是正确顺序。在问题没解决的当口上发脾气，可能自己一时释放了压力，但是负面情绪扩散开来，其他人又向何处排解呢？败坏了心情，还得勉强继续工作，降低了效率。可能自己不承认，说自己没生气，认为自己没有对别人有不当的情绪投射。但这不是自己说了能算的，一个人「是否生气了」，取决于其他人对此产生的主观感受。自己是怎么样的人（包括职场中），很大程度上不是你认为的样子，而是别人认为的样子。我也不时莫名奇妙地说出一些自己也不敢相信这是自己会说出的话、会做出的不当反应，感觉完全没有经过大脑，都是嘴巴的胡作非为，还有手贱……有时恨我不是自己想像的那样好。羞耻技术也是有羞耻心的（不谈没有羞耻心的非正常人），拿出数据、现象指出可能存在的问题，当他看出是自己造成的问题时，也会脸红，自然会默默搞定存在的问题。质疑一开口就是质疑的口气，双方都还没来得及分析清楚给出的事实，只是一方觉得看起来好像不对而已，另一方该露出怎样的表情呢？被质疑的一方懵了或者怒了，不说话可能只是因为不敢确认自己百分之百没有纰漏，在怒目和不满之下，做事很难不夹杂负面情绪，然后就很难再正常地快速思考问题、自省了。能不能先好好看清楚再讨论？脾气不好的早就掀桌了。如果后来轮到质疑的一方犯错了，能不能再劈头盖脸地再狠狠喷回去呢？盲目乐观我认为，太多问题都是心情（情绪）问题。要是心情足够好，绝大多数情况下，大家都能和和气气、不急躁地沟通。那为什么心情会比较差了，我认为很大的一个原因就是「盲目的乐观主义」。常常觉得顺利是理所应当的，从小到大，家长、学校、社会为仍出学生时代的我们，把很多问题都简化了，包办了我们大多数的脏活累活。我们只用做作业、学习就行了，不用洗衣服、做饭、交水电费、挣钱，不用掰扯这些柴米油盐茶的琐事。当我们步入社会，开始工作，来到“真实的成人世界”，才体会到许多以前从未经历辛苦劳累，初期难免诸多不顺。很多事情没有唯一答案，「是与非」常常并不显而易见，有些事情很依赖经验、阅历的判断，但不客观仔细地反省，依然还是容易得出荒谬的结果。常常过于高估自己的能力，技术能力、沟通能力、时间管理能力；还经常把自己的问题推到别人、环境、社会身上，自己看不到自己的问题。总以为工作、生活都是理所应当地平顺，或者说，顺利应该是才是正常，不顺是反常。理性当然也是这么认为的，但是潜意识里这种思维倾向还是很难改的。不经历足够地挫败，很难纠正这个认知，习惯、接受真实的生活。没有转变过来的话，可能在不顺的时候，会认为都是别人的锅，都是环境、社会的问题，实则常常是对自己无力改变现实的愤怒。其实没必要愤怒，即使再来一遍，个中困难未必能够平顺地避免大多数问题。我们太容易低估那些看似简单的现实问题的复杂性，撞上了，才知道那只是冰山一角。只是总是不死心，每次都自以为是地做比较乐观的预期。「知错就改：错过一次，就吸取教训别再犯了」这话简直说的是童话。人性弱点摆在那呢，你总能扳得过自己那多年形成的尿性了？某个同事时常劝告我，应该 Take it easy 长命功夫长命做；尽量用简单的方式做，我的做法复杂了。一时半会做不完，没必要过度透支精力，本来人生是长跑（废话略过）……很推荐 《悲观主义的益处》阿兰德波顿的演讲，不保证治愈「顺利妄想症」，起码能改善急躁的心情。Todo List 的苦恼小事这些年把自己变成纠结细节（小事）、尽量把时间都尽量填满的人，却感觉精力总被小事涣散：时间统计还好，记账对账果然还是蛮费事（有钱多好）… Todo List、GTD 是确实让我很少忘事了。可是我就开始用不困难的小事消磨时间了，耽误了更重要的事。就好像瓶子放进了石头还能塞沙子，甚至还能再灌些水，但放的顺序一错，石头就再也放不进去了。或许我更可能当个事务员，而不是干一件大事的人。取舍经常质疑自己对「事情的重要性，该做到什么程度」的判断，为此感到绝望，因为自己什么都放不下。比如这样一个情景：写一篇文章，反反复复地字斟句酌，还是不见得写得好，令人苦恼。而且还隔三差五，翻看博客里的旧文章，会忽然觉得很多地方写得不好，又改了起来。这算好的了，还有更多类似的鸡毛蒜皮的事，我会去处理，然后注意力又被夺走了，我都不乐意提这些事……这样反反复复浪费时间，大概就是强迫症吧。还有更多值得做的事，我应该放下这些破事的，果然还是手贱。大概我得忙得焦头烂额，只把选择权让渡给更明智的人，我才能走在正确的道路上吧。混乱还有，从高考结束那个暑假参加某小公司的实习之后，就开始就把工作和生活混得太过了。原来，混着过就是想着能有更多时间保持平缓的节奏一直做事。要是状态一直好还行，不然极端起来可能工作日打酱油，周末公司没人（清静）才把所有都补上，真的工作了这节奏就很不好。毕竟要和别人协作，得工作节律一致。还是得工作时间尽量把活都干完才行。还是回到专时专用的状态吧。这就是写那篇 《生活指北》的原因。抱怨路怒以前我一直不想学车，是一个从小深植脑中的想法，后来再没细想修正过的想法。这个想法就是根据我自己的观察和阅读得出的。我总觉得在国内的道路状况下，人很容易得路怒症。所以为了尽量避免自己生气，我一直不想学车。特别是从小就习惯长距离走路通勤，觉得走路加公交就足够了。有一次，我乘一个朋友的车。路上，他问我为什么不学车，于是我说了我的缘由。他也道出了自己的观点：「路怒与车无关，关键是人，是开车把这个人的本性激发出来罢了。」这个说法有点道理。脾气我并不觉得自己真的脾气很好，当小时的性情被激发出来时，自己也有点失望，因为会再度发现自己不如自己想像的那样好。后来让自己尽量变得更有耐心，但性情还是很难改变。分歧我才发现自由旅行真的很容易产生分歧。大概以前跟团旅行的时候，可以当甩手掌柜，什么都安排妥当；即使不满意，都会宽容地认为这些问题都很难避免，所以反倒不甚介意。或者独自旅行，想做什么、想去哪里都能由着自己的性子和爱好来，自己对自己负责，没有什么不满意的。希望多些人一起旅行，这样就可以拼单下馆子了，可以多试试不同的菜品，可以平摊租车、搭的士等的交通费，还有旅伴可以聊天。尝试去冲绳旅行的几天，还是约了三三两两的同伴一同出行。然而人的需求是不同的。当“甩手掌柜”的类型的同伴，把选择交给了其它同伴安排，可能是其中一两个仔细研究攻略者。然而第一次到陌生的地方，研究再多攻略也是不足的。制定得再严密的攻略，也不过只是计划，执行的过程中总是会有意料之外的变化。而且可能平时一起工作的各位同事都不一定足够了解各自的旅行喜好，特别是各自可能还带来了家属。需求是不同的。有些人不差钱，随性地打车、饮食，毫不在意；就不会喜欢费力徒步。有些人就是不在意步行，甚至喜欢多走走；当然也可能是仅仅因为穷，心疼打车费用，省钱换乘巴士。有些人经常旅行，不差这次游玩，就不会喜欢太紧凑的行程。有些人就是喜欢闲适的旅行节奏，并不打算疯狂买买买，或者暴走到各旅行景点进行“打卡”。不是人人都是吃货，有些人就是对吃的不太在意，或者不饿，没胃口。有些人只要与另一个人同行就好。即使统一行动了，还是可能点菜口味不一样、想去的景点不一样；去了同一个景点，也可能赏玩的点也不一样；不可能完全步调一致。所以，难免摩擦。我也不是没少听说过旅行闹掰的。行程是根据攻略者自己的喜好定的，假如其它同伴临时决定跟随攻略者，难免不能完全满足其它同伴的需求。如果同伴托付了自己的行程给攻略者，毕竟是一种信任，攻略者接受了跟随，是该认真调整好行程的。如果其它同伴不能满意行程，或者攻略者在谨慎考虑后依然希望能够坚持自己喜好的行程时，应该果断拒绝。不然，后面不能互相迁就，难免产生小摩擦，以致不快。比如你来看地图导航，难免碰到同伴质疑走错路了的情况。而且你不玩 Pokemon Go，其它人都在玩。攻略者自己导航，可能会觉得其它人拖慢自己原定的行程。当然他可能并不在意，毕竟随性而为，这也是自由旅行的乐趣。当在思考怎么安排后续行程，可能能力不足以应对而手忙脚乱、没有余力顾及其它事情的时候，是希望他人能够理解自己有地方做得不好，希望他人帮忙处理一些其它琐事。这时被质疑不靠谱，倍感无奈和委屈。难到指责方总是要当甩手掌柜，指责别人不靠谱，却不出手相助？难到不能犯错吗？在国内，当让别人正面说出你不靠谱的时候，你肯定有什么地方搞错了，而且积累的问题一般都不止一两个。海外旅游经验不足，外语水平、理解能力、应变能力都不够。抽离已经很久没有好好旅行过了，出行前很期待这次冲绳之旅。我更希望这段旅程可以给自己近两个月来持续恶化的颓唐状态画上休止符。然而旅行过后，日子还是一样地过。但在一个陌生又新奇的地方，身心放松了，更容易释放自己的本性。这种短暂地从日常生活抽离出来的体验，让人有了更多反躬自省的机会。我再度发现了自己的「不靠谱」。达到自己心目中的「靠谱」很容易，毕竟人都是倾向于高估自己。但是要达到别人心中的「靠谱」绝非易事，比如我最想做的事：给绝大多数人留下好的印象。为了达成以上的目标，常常需要多牺牲自己的利益去配合他人：若不予人以利益，别人会愿意长久地帮助你吗？我认识到了自己的平凡、无力。其中一个原因就是在旅行时发现自己挣的钱不够，不足以任性玩乐，不足以拥有更多更好的选择。想要赚更多的钱，想要变得强大，想要变得值得敬仰。我想早睡早起、健康饮食（身体健康）；我想每天花些时间好好学英语（出国看世界）；我想做事有条理（做事有方法）、高效率（重要的是有努力的意愿）；我想成为xxxx（屏蔽）；我想勤俭节约。……说了「我就是太贪心」无数次了，依然不懂取舍。拥有一些东西，就得舍弃其它，要专一。当然我还是觉得「人性」是好逸恶劳。我一直尝试努力让自己沉醉于努力的快感当中，希望形成苦行僧似的习惯。自己不足以一朝顿悟，于是尝试循序渐进。但现在即使现在强度不大，还是常常把自己弄得身心疲敝。还是承压能力不足，职业精神还不到位，感觉欠加班呗。还是走得太慢了……24岁，身体健康，不过常常在没有必要的情况下透支身体；一个人很自由，只用活好自己就行了，但隐隐感受到日后的生存压力，买房子好像是迟早的事；开始感觉到时间和生活在不断磨灭斗志：精气神不如当年，不能连续作战、高效不拖延地一下子做好一件事情，各种分心、颓废。再说就没意思了。改变现实，说到底还是靠行动。不是所谓想明白一些事情、思想变得更深刻了，打打嘴砲，生活就变得更好。不过憋得慌，还是说出来舒服。这些想法在想到那一刻感触还是蛮深的，稍微过一阵子再看，就不值一提了，阳光下并无新鲜的道理，只是换了种说法，变成另一个故事，被另一个人再讲了一遍罢了。无题身边朋友的平均水平，很大程度上，代表了你在哪个段位上。弯路那些曾经的弯路，并不如想象中那么有意义。实际上，它们确实浪费了我许多时间和精力，其实本可以做更重要的事情。不过没必要为了缓解劳苦无功的懊恼，而给它们强行附上意义。那些意义不过是为了合理化过度投入的沉没成本、缓解认知失调而生的说辞罢了。想法很零碎，还需沉淀。Never memorize something that you can look up.Albert Einsteinarticle img.fix_width{width:32em;height:auto}img.fix_height{height:28em;width:auto}]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆]]></title>
    <url>%2Fmoments%2F</url>
    <content type="text"><![CDATA[执信那是我高一的时候。Gold Voice 初赛，我在台上唱《亲爱的那并不是爱情》，排几个我的同学朋友带动起其它场内的人晃起了双手，那确实成了我心中最难忘的时刻。她们虽然并不算真正熟识的朋友，现在也都在国外了，难免勾起对人事变迁的感慨。真是 往事如昨。在那之前，经历了一次很严重的感冒，毁嗓了。说实话，多年之后我才想通，即使没有那场意外，也顶多徒有不过如是的嗓子，唱歌水平也是远远不行的（实话），如不是情商垫底，早该发现了。毁嗓的事我一直耿耿于怀了好几年，直到生活重心完全不同之后，才走出了想唱却再也唱不好的失落。毕竟已经习惯了安静工作学习，很少再有三心两意边唱边做作业的时候了。实习大学入学前在 GLR 的这段实习时光，大大开拓了我的眼界，却也让我变得很浮躁。不过也算让我更早地进入和度过自己最浮躁的阶段。GLR 「过来人」后改名为「优职英才」，创业是残酷的，那几位创始人终究没能大获成功，这家公司现在成了他们的副业。大概他们又回去搞投行、咨询了，其实挺希望他们最后能做成这家公司，或者做成其它事业。华工毽球高中就开始热衷的小众运动。曾努力练习，可是一直不得法，不过还是一直坚持到现在。有幸拥有一帮强大的队友，这些年获得了 一些小成绩，重要的是玩得开心。太多事想要做，现在只能偶尔玩玩了。电工微电子工艺实习课程里的一个自由发挥的手工作业。突然想到可以做个左轮手枪~社团早期玩社团留了许多照片，后来即使拍了也忘记要了，只留下很少。职业体验协会的师兄毕业时的合照。多看多看阅历看起来挺多，其实其中许多都不长。感觉做了很多无效的阅读，其实可以省下时间去看更有营养的书、做更重要的事。宿舍经常用整理宿舍来拖延回避困难、不想做的事，比如考试复习。新浪曾经在泰鹏大厦时的工位。新浪总部大楼的新工位~毽球亚军在广东的时候，我的水平（中等）只能算战五渣。结果来到这种没有奖金的比赛（虽然也强但没那么多高手），凭着我们队年轻的体力优势（其它基本都是 30+、40+，甚至有 50+），在小组第二出线的情况下（真正技术不够强），逆转获得亚军（2/16）。运气太好，大概这是最后一次能拿到这么好的成绩了吧（虽然艰难，还是觉得有点水份）。冠军然而，万万没想到，仅仅两个月后的这又一次天津之行，还是同样的队员，发生了同样的剧情，小组第二出线，然而结局却是我们拿到了冠军了！还是因为年轻体力好啊。天津真乃福地。家书桌。久违的家。文字还有许多没被相片记录的时刻，如果都记录了下来那该多好。我旅行得不多，算是孤陋寡闻，没见过世面，大学期间去过不多2012 上海 GCC 之行2013 珠海、中山办生存挑战营2013 四川、重庆旅行2014 潮汕杯毽球比赛之行2014 云南大理、丽江旅行基本都是跟好朋友一起成行的，之后2015 算是来了北京只身闯荡2016 天津的两趟毽球比赛2016 冲绳之旅但是转念又觉得这些缺失也没什么太值得遗憾的。人真是矛盾。仔细想想，不过是自恋情结罢了。小学三年级开始去黑网吧、游戏机室。曾自诩游戏打得好，学习又好…参加过乐高机器人的比赛得了两个三等奖。非常喜欢傻笑，还算幽默，很会讲笑话。初中玩游戏、看动漫最多的时期。开始在意女生，过分注重外貌，无心向学，性格变得沉静。初一入门卡牌游戏「游戏王」；初三为了中考，戒掉了。某次班级出游，前往游乐园却路遇暴雨，学校安排大家转战 KTV。那是我第一次去 KTV，突然发现自己唱女歌不错。初二长痘甚多，异常失落，遂得外号：郁闷。这三年，在这「井底」轻易获得「还不错」的成绩，于是不够努力，把学习热情、脑力、思维、习惯落下了。执信入学前新生 QQ 群 KTV 聚会，还记得我用一曲张韶涵的《亲爱的那并不是爱情》技惊四座，于是那时有人被吐槽我的颜很外星人（快军训，剪了短发），但唱起歌来印象反差很大，给了大家很强烈的印象。入学一个月，音乐社入社面试，还是《亲爱的那并不是爱情》。成了某个唱歌很好的同学的“偶像”，被两个隔壁班同学（同在音乐社美女）称为 Vitas（不过恭维，只是表达了当时她们“哇槽”的心情）。当然，后来社长们看出我音准不稳定，还有在毁嗓后做的各种蠢事，我慢慢就淡出了。一开始我就没能参加音乐社的宣传视频拍摄，就显出了边缘化的端倪，我当时不以为意；于是自己还在继续参加、帮忙办各种活动，后来后知后觉，感觉还是挺难受的。高一青春痘褪去，依然过于在意外貌，浪费了许多学习时间。戒掉游戏，开始参加丰富的学生社团生活，难免成绩平平；开始用 QQ空间 记录精彩快意的校园生活（开始矫情）。开始迷上毽球这项小众运动，一直坚持了下来。重感冒没打吊针，吃中药久治不愈，毁嗓致不再善唱女歌…高二遇到现挚友之一，带动我学习，成绩好转；但高中生活自此从波折转平淡。高三真是飞快、充实又平淡的一年，其实内心仍是充满波澜，比如比较喜欢这种文字「路灯输烟花一段灿烂，烟花输路灯一时安稳」。后来意识到高一的朋友没有维持下去，高二开始也没好好深交朋友，是高中最大的遗憾。如果中大不行，最后华工都录取不上，高中的后两年就真的太失败了。华工高考后的暑假，偶遇校园牛人Jacky，惊奇，想模仿其成长路；实习于他所在的过来人公司，接触了许多牛人，视野大大拓展；重新开始大量阅读，但成了鸡血男，开始浮躁。大一加入了不少社团，花费大量精力亲身筹划举办学生社团活动。还想同时搞好学习，总之什么都想做好……早年虚度致脑力积累不足，与思维、习惯的不良，难免让大一上学期的学业失利、精神溃败，大一下颓废过活（高中阶段也不过是学校的师资帮我度过了高考关，自学能力还是没好好培养起来）。大二成为一个运动类和一个职业类社团的会长，依然坚持实习。虽然还是没抓住生活重心，但还算是快乐、充实，不过自信得虚妄。仍处未来人生方向的探索期，尝试一切可能性，尝试好好学技术，但自大学以来，对技术的学习至今仍不得法。大三决定更专注技术，进入学院的某实验室做软件项目，也潜心提高毽球运动的水平，参加比赛，亦至今不得法，很后来终于决定将“程序员”作为毕业的工作，但以后会不会成为我终生的职业呢？大四悲喜交加的求职季，难免失意。遇到一个大四前几乎一直虚度而今奋发的同学，没想到是他激励了我，而非那些被当作假想敌的牛人。My Good Old Days ( Old memory I wrote )新浪2014 年冬来北京新浪实习，北漂的生活还挺自由的。2015 年夏 7 月正式入职。至 2016 年冬，工作生活安逸闲适，长进缓慢。2016 年春至夏，临时调到「微博头条」项目组帮忙，据说做得还不错。年中黯然。2016 年夏，回到原部门。至 2017 年春，重构部门主项目。2017 年春，工作依然是重构。再一次深入思考自己想要怎样的生活和人生。定位平凡得不能再平凡。曾经以为自己能够成为自己生活中的「英雄」，后来发现自己只是个「孬种」。家底薄，没钱买房，要给二老养老。看脸，勉强；看身高，三级残废。资质平庸，贪图安逸，只会嘴炮。想要看我过去的丑态，请探寻我的 QQ 空间；后来发生的无聊故事，见本博客的 Think 系列文章，以及我的 微博 和朋友圈（IceHooo）。以后长进太慢，不知不觉，人生已经过去了三分之一。过去的都过去了，要往前看。一路远行，往事越发模糊，不知为何，却看得更清楚了。Bye, my good old days : )Ice Hearticle .article-content h2{font-weight:700;font-size:1.8em}article img.fix_width{width:32em;height:auto}img.fix_height{width:auto;height:32em}]]></content>
      <categories>
        <category>whoami</category>
      </categories>
      <tags>
        <tag>whoami</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文字阅读收藏]]></title>
    <url>%2Fread%2F</url>
    <content type="text"><![CDATA[Never memorize something that you can look up.Albert Einstein上标The item with Best&nbsp; implies it is one of the best.The item with Note&nbsp; implies it is a link to my related note.The item with todo&nbsp; implies it has not been read-through.The item with temp&nbsp; implies it might be removed one day.叹息过去囫囵吞枣，糟蹋了许多好文章；如今我要一一记下，细细咀嚼回味。后记好内容很多，但人生太有限，不可尽揽。本来我还想着给碰到的每一篇好文章写下笔记呢……生活本来就是一团乱麻，「完美」只是镜花水月，盲目接近它和追求它，均是徒劳，甚至可以说是一出悲剧，就如西西弗斯的滚石。追求整洁、秩序、完满，还不如由它杂乱不堪来得省心。我就是一个典型的「强迫症、细节控」，可是不想再继续这样下去了。人生太短暂了，何不及时行乐去享受乐趣，或是好好做事追寻人生的意义。不过，我还是想留下这个博客 —— 这一片隐秘天地，让我自己一个人，能够静静地跟自己说说话。文章中文文案排版指北（ EN ）写给大家看的中文排版指南人生若一辈子没有赚大钱，当大官，和自己爱的人在一起（哪怕一次），活着能算有意义吗？- 灯塔 Best / Note眼前的苟且，也正是诗和远方 - 迷茫 Best / Note为什么长大以后反而不容易快乐？- You are not special. Best / Note《 幸福课 》动机在杭州 的知乎专栏 - 平常心 Best / Note风尘棋客 Best / Note「年轻的时候，我一直觉得世界上最酷的事情，莫过于无忧无虑地四处环游；可就在刚才，看到许银川在比以前更胖了的赵大胖面前推枰认负的那一刻，忽然觉得，能十年如一日地把一件看似简单的事情做到极致，或许更酷一点。」我与清华的差距在哪里？ - 从一开始就……《 论悲观主义的益处 》阿兰·德·波顿 Best / Note「如果你拒绝让你的悲伤压在身上，哪怕只有一个钟点的时光；假如你总是汲汲营营地试图提前避免或者推迟一切可能的伤痛；假如你认为痛苦是邪恶的，是可憎的，是理应消灭的，是异常变态的存在，那么你的心中显然窃据着舒适的宗教。对幸福的理解是多么浅薄啊，你这个贪图舒适且渺小的家伙！幸福与不幸乃双生姐妹，要么一起成长，要么一起萎缩，就像你的处境一样。」Loser 应该知道的 6 个残酷人生事实 Best / Note「这个世界只关心你能给予什么。」英语原文：6 Harsh Truths That Will Make You a Better Person你曾经的老师说过的哪句话印象最为深刻，对你影响较大甚至在十多年或更久之后都记在心里？ Note「我们用『我能做到什么』来判断和定位自己，而别人用『你已经做过什么』来判断和定位你。」论底层青年如何逆袭到中上阶层：什么是命？如何革你的命？ Note家世的积累，才是你的起点。70 后和 80 后对于刚刚踏入社会的 90 后毕业生有什么建议？ Note「如果不能先学着适应环境，就不要妄想改变环境。」精致的利己主义者和常青藤的绵羊 - 中西 Note《 感谢你给我机会上场 》方励的一席演讲 - 循着乐趣前行 Best《 潜台词 》李松蔚 的知乎专栏 - 洞悉人心苦难有什么价值？- 无谓的苦难你有什么道理后悔没有早点知道？我们这一代人的困惑 - 大部分人的梦想永远都实现不了。马云的缺陷是什么？ - 当年阿里巴巴的「十八罗汉」甘愿跟着马云，并不只是因为马云能打鸡血、“忽悠”…… 一点点启示。方法How to Study: A Brief Guide - 方法论 Best / NoteStop Telling Students to Study for ExamsHow Tests Make Us SmarterSorry, You Can’t Speed Read你的自控能力强么？｜研究：不快乐的人自控力更差 Note吃好，睡好，保持好心情与好状态，做发自内心想做的事情自控力极差的人如何自救？Marc Andreessen 的个人效率指南 - 简单易行，有所启发你知道吗？每个时间管理方法都只适合解决某一类问题刘未鹏 | Mind Hacks -「思维改变生活」逃出你的肖申克（七）：改变的科学和科学的改变…关系本分和情分 -「别人帮你，那是情分，不帮你，那是本分。容不容得下是你的气度，能不能让你容下是我的本事。」圈子不同，不必强融 -「怎么样才可以真正地做到不计较呢？强大到让别人计较你。」Best孤独让人成瘾（下）：依赖真实的关系 Best「交一个真正的朋友是一件很累人的事，但是人生那么长，不累一累，那又该干嘛呢？」为什么人越长大越孤单？- 自我定型后，想要寻找与我们真正相似的人谢谢你曾拒绝我｜被排斥会给一个人留下怎样的影响？- 低自尊大学里究竟是学习重要还是人际关系重要？- 相比于学习，人际关系一点都不重要。不让不够格的“朋友”牵绊前进的脚步 - 勿交损友如何看待把妹知识？- 成为优秀而真实的自己男女交往最忌讳什么？- 月亮你要，六便士你还嫌少在大学里有哪些不错的恋爱建议？- 不强求为什么你的爱情会输给日常琐碎？｜相爱容易相处难伤不起的盖茨比——那些年，我们没逆袭到的女神女性年纪大了就不好嫁人了吗？如果你自己一个人的时候都搞不定你自己，如果你单身的时候都不能把自己搞的美美的，让你自己过得开心，你觉得你能搞定一个家庭么？你觉得婚姻就会是你的避风港湾了么？《 不想靠谱 》 知乎专栏 - 两性关系为什么很多优质女生找不到男朋友？认为「 只有我完美了，别人才会喜欢我 」的想法有什么错误，该怎么解决？- 吾生有涯女生选择和一个男生交往的第一个条件是不是看脸？ - 整体形象送礼的秘诀是什么？- 「送者心安，受者心欢。」中国的劝酒文化背后的逻辑是什么？- 服从性 &amp; 诚意测试父母真的只是为了孩子吗？- 为了“自己”思维想要提高效率，就得不公平 - 极简 Best「衣着无比整洁，东西摆放井井有条，对什么事情都有记录存档，这样的作风并不值得学习，这种人设定了错误的优先级。达到这样的状态要花费很多时间去整理生活，这些时间完全可以用来做些更有意思的事。」如何用3个月毁掉你的室友？（大学生版） - 写照 Best智商高低是因为思维习惯不同造成的吗？- 思考能力 Best如何从思维上彻底改变学习模式？- 实用主义 VS 完美主义哪些素质很重要，却是读书学不来的？- 纸上得来终觉浅，绝知此事要躬行科技如何劫持人们的心智——来自一位魔术师和谷歌的设计伦理学家(Design Ethicist) Best人类为什么会有「 雄心壮志 」？为何有人「 小富即安 」，有人有「 鸿鹄之志 」？- 成就动机 Achievement、亲和动机 Affiliation、影响力动机 Power普通人怎么让自己更努力？(3)- 发掘内心的真实想法…年轻人如何在独居时有效地保持自律？ - 普通人的方法Larry Smith：你为何不会成就伟业 - 庸人的借口 Best别让工作拖垮你，最实用的 25 条时间管理 TIPS - 时间管理的目的是为了提高效率，去做更多的工作？男生有钱到底有多重要？- 「有时候不在于它能带给你什么，而在于它能让你不失去什么」。自立，自尊什么是「 富人思维 」？- 自我投资，善假于物什么是「 穷人思维 」？- 短视：金钱 VS 时间成本有什么知识，你知道后你的世界马上就不一样了？- 不要看对方说了什么，而是思考他为什么说这个有什么知识，你知道后你的世界马上就不一样了？- 学好逻辑很有用！todo还有什么比揭人伤疤、往伤口撒盐更刺激的事呢？- 异见有情调没情怀、有趣味没人情味的知乎社区一部《 欢乐颂 》，一场中产阶级的自我意淫面对未知，如何能够免于恐惧？- 比起不确定的答案，我们宁可要一个坏答案。要悦纳不确定。学术方面该如何评价哈耶克？- 公正的游戏规则有哪些优秀的沟通思路？学而时嘻之 - 博客「用理工科思维理解世界」政治Power 錕的紙牌屋（Youtube Link）驱离的世界：社会分层与阶级固化 - 现实 批判学习From: 微信公众号「大浪淘沙」城堡的落成：上升通道即将关闭的中国社会 BestFrom: 微信公众号「肥肥猫的小酒馆」被吞噬的中产阶级 - 中产？无产我们，新时代的“新穷人” - 连剥削的价值也没有房地产、银行、贷款、政府、贫民、富民、泡沫、经济崩溃，他们之间是什么联系关系？ - 房地产问题 Best让你信上帝未必肯，让你发财干不干？ - 宗教的逻辑？健康生命真的在于运动么？没有锻炼基础的人，如何增肌与减脂？- 汇总什么样的有氧才真让你瘦？- 高强度间歇有氧，在短时间内将高强度与低强度训练结合练腹肌？你这是在练水桶腰！22:00-6:00睡觉真的比2:00-10:00更有利健康吗？- 早睡早起跑步（运动）后，到底该不该吃东西？- 运动完，吃更好哪些公认的健康食品其实并非那么健康？为什么？- 沙拉，果汁…你的早餐吃对了吗？我们这次要追根究底 - 暂无定论，少吃高碳水食物长期用耳塞听歌会导致听力下降吗？- 注意音量！如何正确地刷牙？ Best Note电动牙刷刷牙相比手动刷牙有什么优缺点？洗牙到底安全不安全？- 有益，不贵午餐后如何洁齿护牙清理口腔，尤其上班族？- 饭后刷牙！怎样纠正成年人驼背、耸肩的体态？- 挺拔办公室员工的职业健康 - 香港政府指南正确坐姿 - 腰椎、颈椎自慰的真正危害有哪些？- 无碍日常生活中有哪些所谓的性知识是错误的？- 常识英语汉语对现代文明的贡献有多大？- Why you need to learn English !?程序员英语学习指引 todo「除非你阅读原版书籍和中文书籍一样顺畅，或者翻译书籍信息损失量太大，否则不需要刻意阅读原版。」单词全认识却看不懂句子怎么办？- 一词多义、语境、词组、语法、文化背景 todo每天坚持英语学习为什么还是学不好？- 水滴石穿 VS 拼命猛进翻译真是一条永远走不完的长路啊 - 知乎收藏夹如何让自己的英语写作达到英语母语者的水平？ todo temp有哪些高级的英语表达技巧，让人一听就感觉很地道？ todo temp美剧字幕组长讲述她如何练听力 - 方法 todo tempBBC 英式英语发音视频教程 - Elegant todo temp怎么练好英语口语？ todo tempEssayForum - Free Writing, Editing, and Research Help for Students todo temp39 Incorrectly Used Words That Can Make You Look Bad todo temp理财商业分析能力是怎样炼成的？Best如何用保险保障自己的一生？- 安稳人生 Best普通人如何合理的理财投资，有哪些书可以学习阅读？- 必修 todo《 天上不会掉馅饼 》知乎专栏 - 金融投资诈骗真相与投资方面的常识 Best大学生应该持一种怎样的存钱/花钱态度？- 投资自己如何看待「 钱不是省出来的 」这句话？「该花的钱一定要花，不该花的钱一定要省。」 然后，要有智慧分辨两者的不同为什么跳槽加薪会比内部调薪要高？- 瞬时市场定价傻瓜才炒股家如何对孩子的无理要求说「不」？为什么不从小就向孩子还原社会的残酷？刚做爸爸，觉得自己的时间都被孩子剥夺，该怎么调整心态？有哪些价格不贵逼格又高的家装家居？家居中有哪些设计不合理的地方？买100 元以下有什么好伞？ - 伞控？（南方多雨）有哪些不为外行所知的好产品或好品牌？一个人旅行有哪些必备神器？- 实用有哪些尚未普及却非常好用的东西？- 生活质量耳机选购大全：不败家！不白瞎！够用就好？- 实用，极简（好用，便携，高性价比）食食べ物 Best北京有哪些深藏不露的餐馆？去香港一定不能错过哪些美食？乐如何系统地练字？- 手写的乐趣怎样欣赏交响乐、歌剧、古典和美声这类音乐？广州有什么「鲜为人知但很有意思」的景点？我知道你看过不少神剧，但许多都「抄袭」它法律《Legal High》呈现的是怎样的三观？- 法律至高 BestKTV 不允许带酒水和零食违法不违法？- 合法权益杂音乐的秘密 - 梁欢制作的纪录片电影。向不为人知的幕后音乐人致敬 Best如何防止鞋带松掉？- 绑鞋带扇贝英语 - 一整套学习英语的系列 App 服务网易公开课 - 国内最好的公开课平台，包含 TED、Coursera、可汗学院的翻译视频 todo经济越发展，越难「寒门出贵子」吗？书国史大纲 - 钱穆，通史。论语新解 - 钱穆，儒。中国哲学简史 - 冯友兰，哲学。社会心理学 Best - Social Psychology _- 经典教材。思考快与慢 - Thinking Fast and Slow - 心理学经典。怪诞行为学 Best - 心理弱点。Predictably Irrational: The Hidden Forces That Shape Our DecisionsThe Upside of Irrationality: The Unexpected Benefits of Defying Logic at Work and at Home经济学原理 - Principles of Economics - 曼昆。高效能人士的7个习惯 - The Seven Habits of Highly Effective People - 个人成长。国王，武士，祭司，诗人 Best - King, Warrior, Magician, Lover - 男人。万万没想到：用理工科思维理解世界 - 理性。知日断舍离 - 极简。奇特的一生 - 手帐。番茄工作法 - Pomodoro Technique Illustrated: The Easy Way to Do More in Less Time - 专注当下。浪潮之巅 - IT 史。信息简史 - The Information: A History, A Theory, A Flood程序员的呐喊 - A Programmer’s RantingsSteve Yegge 以幽默、辛辣的口吻，表达了作为一个资深程序员的独到见解。重来 - 《Rework》DHH 简洁有力的文字，独到辛辣的见解，直指人心。异类 - 成功的随机性，与家世的积累。反脆弱 - 脆弱性、坚韧性与 反脆弱性！承受小的风险和挫折，会让我们更强大。警惕毁灭性的危险。重构 - Refactoring : Improving the Design of Existing Code代码大全2 - Code Complete : A Practical Handbook of Software Construction设计模式 - Design PatternC++ Primer汇编语言算法竞赛经典入门蔡志忠的漫画读过的书 - 用豆瓣记录所有看过的书意义不大还麻烦，以后只在博客此处做记录。播客尽量使用 Podcasts 等泛用型播客客户端订阅为佳。一天世界 Great「用整体性的视角，观察当代社会的技术、文化以及商业风景，对抗消费主义导向的论述，强调对技术、艺术的敏锐的感受力，以及精神和肉体上的强健。」一个小众播客。IT 公论 Great建议不要从第一期开始听，前期的节目我觉得真的不行，中期才算渐入佳境。好节目不常有，我常把它作为平时步行、骑行、闲暇时的背景音，时有收获。（已停播，「一天世界」就是它的续集。）太医来了 Best主打健康、饮食、身体、医疗等常识的科普，收益颇丰。（IPN 旗下播客节目）@Podcasts仅从男性角度收藏节目，忽略了部分期关于女性问题的好节目。15. 蛋白粉、阿胶、鱼翅、燕窝、虫草……我们不吃！都不吃！ - 补品、营养品23. 包皮 GO!26. 有志青年独具慧眼，刚烈女子荡气回肠 —— 肛肠38.「有的牙医就是享受手动刷牙的快感。」 Note44. 减肥？减脂？减重？你到底要哪样？46. 听了那么多道理，还是睡不好这一觉 - 误区52. 花间一壶酒 - 饮酒54. 减肥怎么吃？59. 关于蛀牙，我们过去想得太简单了62. 膳食指南背后的故事 - 健康饮食63. 脱发考66. 膝盖考67. 补钙是个技术活68. 从牙套妹到女神的进化之路74. 拯救你的颈椎，从选购枕头开始76. 体检的问题，医生们有时候也会纠结81. 一张过期保单带来的自杀事件 - 商业保险意识！87. 激光手术治疗近视，眼科医生怎么看？90. 刷牙出血，你别不当回事儿内核恐慌 GreatKernel Panic ，讨论关于软件开发各类话题的谈话节目。（IPN 旗下播客节目）@Podcasts2. 键盘恐慌3. 静态网站生成器4. 编辑器巡礼5. 编程字体7. 软件包管理8.「集装箱化」与运维管理9. 程序员的理想工作环境12. 数学与编程15. 数据可视化与交互设计20. 设计模式28. In the Beginning was the Command Line29. Terminal Emulators31. 覃超专访（之一）32. 覃超专访（之二）罗辑思维 Best&nbsp; - 知识与观点。 @喜马拉雅FM总体质量高，内容精彩的期数很多，只对近期的节目印象较深。可以一期期听，略听之后不感兴趣，再跳过就好。180. 黄执中：你如何听懂我说的话？174. 联盟：雇主与员工的新型关系173. 魔鬼经济学·下172. 魔鬼经济学·上170. 杜月笙的代价充电时间帮助主流经营者提升高价值信息内容获取效率，通过收听习惯保持知识结构与世界趋势吻合。（Loud News 旗下的系列节目） @喜马拉雅FM各子频道：专栏精粹 Best 、TMT创业者、电商治愈系、文化媒体人、资深管理人、进击的PM、左脑时刻、营销方法论、销售行为学、知乎哲野。锵锵三人行 - 独行时也可以听到高质量的谈话，了解他人的人生与生活见解。 @凤凰FM南都之声 -「有温度的城市生活。」 @凤凰FM三联听周刊 -「三联生活周刊，一本杂志和他倡导的生活。」 @喜马拉雅FM凤凰周刊有声故事 -「传递影响时代的声音」政治、经济、外交、民生。 @凤凰FM许川知乎时间 - 听知乎（偏人生“鸡汤”类）。 @企鹅FM冬吴相对论（已停播 - 谈论时事热点、经济现象，梁冬与21世纪商业评论主编吴伯凡的谈话节目。英语类 - 在 iOS 的 Podcasts 中，订阅排名靠前的英语学习类播客基本都不错。微信公众号鹅厂网事聊聊架构道哥的黑板报 - 商业、创业、技术、管理，杂谈。程序人生 temp - 服务端技术实践与感悟，以及杂谈。 @陈天幸福课 Best - 心理学。作者：动机在杭州（陈海贤），知乎专栏 同步更新。李松蔚 Best - 洞悉人心。知乎专栏《潜台词》 同步更新。有点自卑 - 两性情感。爱迪生商业实验室 Best - 商业独见。《JOIN创始人鸡汤》为什么你看了那么多商业案例，还是做不好一个小生意？TOMsInsight temp - 互联网数据深度分析报告。吃惑 - 健康饮食、正确健身。大浪淘沙 - 政治、历史的一些有启发的见解（可供参考，请批判）。穷是因为懒、被骗因为笨、女生被性侵因为穿的少——这些“奇葩”思想的根源在哪里？君临 - 富有价值的商业洞见！肥肥猫的小酒馆 - 知乎高赞答主。额外最喜欢的 电影最喜欢的 电视剧最喜欢的 动画最喜欢的 游戏最喜欢的 歌手笔记你的自控能力强么？｜研究：不快乐的人自控力更差若一辈子没有赚大钱，当大官，和自己爱的人在一起（哪怕一次），活着能算有意义吗？ Best眼前的苟且，也正是诗和远方 Best为什么长大以后反而不容易快乐？《 幸福课 》动机在杭州 的知乎专栏风尘棋客《 论悲观主义的益处 》阿兰·德·波顿Loser 应该知道的 6 个残酷人生事实 Best你曾经的老师说过的哪句话印象最为深刻，对你影响较大甚至在十多年或更久之后都记在心里？论底层青年如何逆袭到中上阶层：什么是命？如何革你的命？70 后和 80 后对于刚刚踏入社会的 90 后毕业生有什么建议？精致的利己主义者和常青藤的绵羊How to Study: A Brief Guide牙齿保健 - 刷牙、蛀牙、智齿 BestNot Mentioned Above.做事的方法减肥每天需要摄入多少卡路里《The Power of Less》书摘]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术阅读收藏]]></title>
    <url>%2Ftech%2F</url>
    <content type="text"><![CDATA[Never memorize something that you can look up.Albert Einstein好内容很多，但人生太有限，不可尽揽。本来我还想着给碰到的每一篇好文章写下笔记呢……生活本来就是一团乱麻，「完美」只是镜花水月，盲目接近它和追求它，均是徒劳，甚至可以说是一出悲剧，就如西西弗斯的滚石。追求整洁、秩序、完满，还不如由它杂乱不堪来得省心。我就是一个典型的「强迫症、细节控」，可是不想再继续这样下去了。人生太短暂了，何不及时行乐去享受乐趣，或是好好做事追寻人生的意义。不过，我还是想留下这个博客 —— 这一片隐秘天地，让我自己一个人，能够静静地跟自己说说话。WebBeJson - JSON 格式校验、格式化，及网络、前端、编码、转换等相关工具OSChina Online Tools - 常用 Web 开发辅助工具、相关知识的简明手册HTTP Status Codes - 状态码TCP &amp; UDP Port Numbers - 端口号文档最好的习惯：查阅官方网站的文档。My Git NoteVim Cheat Sheet - Vim 键位操作总结图PHP The Right Way todoPHP Type Comparisons - PHP 变量比较结果参考Mac Developer Library -&gt; AppleScript Language GuideObject Oriented Design ( Cheat Sheet )算法Advanced Data Structures todoVisual Algo - Visualising data structures and algorithms through animation. todoConsistent Hashing 五分钟理解一致性哈希算法尾递归调用随机问题 - 洗牌算法结构之法 算法之道 todo代码技巧编程的智慧 - 编码习惯！一些软件设计的原则变量命名指南编程命名中的7+1个提示你要避免的软件开发模式 - 歧途从面向对象的设计模式看软件设计PHP PSR - 代码规范Google Style Guides - 代码风格 todo防卫性编程 - 小心多余的错误检查与处理技术管理者的创业工具箱编译器的工作过程 - ./configure, make, make installWhat are the main differences between Vim and Emacs? - Vim VS Emacs!有哪些老鸟程序员知道而新手不知道的小技巧？为什么文件名要小写？阅读GitBook todoHow to be a Programmer todoThe Ultimate Question of Programming, Refactoring, and Every todoFree Programming Books todo程序员必读书单 1.0 todo面向对象编程的弊端是什么？Best程序员博客墙 - 优秀程序员的个人博客索引王垠的博客 - 一个很有争议的人物，但是读他的文章还是让人很有启发开源许可证都有什么区别，一般开源项目用什么许可证？History of G_F-W - 功夫网与番羽_土啬 BestChina’s Great Cannon“字节序”是什么？- 大端与小端，深入浅出十分钟搞清字符集和字符编码中文编码杂谈WebNginx 教程 todoHTTPS 之难AJAX 知识体系梳理大公司里怎样开发和部署前端代码？Best前端工程：基础篇 - 分治：组件化开发与资源管理 BestTCP/IP 协议栈及 OSI 参考模型详解TCP/IP 协议详解内容总结高扩展性网站的50条原则FreeRouterV2_HandBook.pdf temp{json:api} - B/S 间的 JSON 格式数据的传输规范 temp为什么全栈JavaScript经常被黑，而Java却不会被黑？- “全栈”之路 tempPHP-FPM 不完全指南 todo架构架构腐化之谜 Best什么不要做？关于失败和优化MVC，MVP 和 MVVM 的图示如何用消息系统避免分布式事务？追求极致：从技术细节看美团架构从无到有：微信后台系统的演进之路 Best端游、手游服务端常用的架构是什么样的？Best万亿级调用系统：微信序列号生成器架构设计及演变千万级规模高性能、高并发的网络架构经验 - 微博平台架构从优化性能到应对峰值流量：微博缓存服务化的设计与实践谈谈系统设计的面试 - 服务端的扩容、缓存与架构升级（评论更精彩）西乔的漫画《神秘的程序员们》- 此处推荐《架构师成长之路》系列：深入浅出！常见的网站服务器架构有哪些？- 演进LinuxThe Art of Command Line BestLinux Tools Quik Tutorial todo服务器操作系统的选择Filesystem Hierarchy Standard - 各目录用途Awesome Sysadmin - 译文：运维资源清单Comparative Introduction To FreeBSD For Linux Users译文：FreeBSD 和 Linux 有什么不同？Unix 传奇（上篇）、Unix 传奇（下篇）Unix 40年：昨天，今天和明天Unix 现状与未来网络安全理解 OAuth 2.0图解 SSL / TLS 协议知道创宇研发技能表 v3总结 XSS 与 CSRF 两种跨站攻击Web 安全入门 - 国内安全专家，余弦我的通行你的证 - 帐号体系的安全 Best加盐密码哈希：如何正确使用 - 英文出处 BestCNNIC 干过的那些破事儿 - 警告：不要在国内注册和使用 CN 域名CNNIC 证书的危害及各种清除方法矛与盾：二进制漏洞攻防思想对抗关于移动端的钓鱼式攻击职业发展怎样花两年时间去面试一个人计算机行业还能火几年？- 前景！？Why I Strive to be a 0.1x Engineer - 不折腾的哲学 简译为什么有些大公司技术弱爆了？再谈「我是怎么招聘程序员的」（上）再谈「我是怎么招聘程序员的」（下）白板编程浅谈——Why, What, HowDon’t Call Yourself A Programmer, And Other Career Advice译文：不要自称是程序员，我十多年的 IT 职场总结精益技术简历之道——改善技术简历的47条原则 - Google 工程师，Lucida如何优雅地参加技术分享会？- 听技术分享的意义 temp左耳朵耗子：不灌鸡汤，说真的年龄渐长，技术人的发展之路该怎么走？IT 业态RedditHacker News碎片化信息的价值：懒惰与慰藉 BestSteveY对Amazon和Google平台的吐槽 - Steve Yegge。 Best链家全解剖：必须佩服、也必须警惕的巨无霸 Best （链家模式）科技公司十大最愚蠢的错误来信，创业和移动互联网腾讯，竞争力和用户体验Facebook 广告系统比谷歌先进在哪里？从空空狐谈信用卡套利Management开发团队的效率产品小团队加班与效率 GreatGood Practice in Agile Great故障之后 - 故障之后，加流程还是改进技术？Best为什么创业公司开除员工的速度越快越好（fire fast）？BestWhy do business analysts and project managers get higher salaries than programmers? Best译文：软件公司的两种管理方式相关：Theory X and Theory Y如何看待阿里巴巴安全部门的月饼事件？从第三方服务角度看公司技术部门如何正确计算投入产出比～Others《程序员必读的职业规划书》Note &amp; 招聘相关微博摘录&amp; 简历上的 精通、熟练、掌握、理解 英语怎么翻译？]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppleScript 操作 Evernote 与 macOS]]></title>
    <url>%2Fapplescript%2Fevernote_osx%2F</url>
    <content type="text"><![CDATA[I supposed that you have learned AppleScript, so I will not introduce it in detail.You can learn AppleScript in practice or my AppleScript Quick Start 快速入门.ReferencesAppleScript Quick Start 快速入门 - My Blog ArticleAppleScript Fundamentals - Apple Official DocsMac Wrangle Evernote with AppleScript / 通过 AppleScript 连接印象笔记 - Evernote Official DocsEvernote Search Grammar / 搜索语法 - How to Search NotesApp’s AppleScript Dictionary : Open App Script Editor → &nbsp;Enter ⌘ ⇧ o → &nbsp;Choose app_name.app (if it supports AppleScript)Evernote Dictionary : … → Choose Evernote.appMy Github Repos:AppleScript_for_EvernoteAppleScript_for_meEvernoteI just list the code that I use most frequently.If you want further use of manipulating Evernote by AppleScript, you can read the official documentations from Apple and Evernote and use other programming language to cooperate with AppleScript.There is only some sample code, so it cannot run successfully in this order.But you can learn how to manipulate Evernote with AppleScript from it.EvernoteLaunch, Sync, Wait, Quit123456789101112131415161718192021222324-- Launch Evernotetell application "Evernote" to launch-- Quit Evernotetell application "Evernote" to quit-- Wait for Synchronizingif application "Evernote" is running then tell application "Evernote" -- Synchronize Evernote synchronize repeat with i from 0 to 300 -- Is Evernote synchronizing or not? if not isSynchronizing then return i end if delay 0.01 end repeat end tellend ifNotebookExist, Create, Rename, Delete1234567891011121314151617181920212223242526272829303132333435363738394041424344tell application "Evernote" set notebook_name to "nb_1" -- Get Notebook notebook notebook_name -- The above is usually equal to the below. notebook named notebook_name -- But it's more clear when the keyword `notebook` with `named`. -- Notebook exists or not? notebook named notebook_name exists -- Create Notebook if not (notebook named notebook_name) exists then create notebook notebook_name end if -- Rename Notebook set new_notebook_name to "nb_2" if ((exists (notebook named notebook_name)) and not (exists (notebook named new_notebook_name))) then set name of (notebook named notebook_name) to new_notebook_name end if -- Delete notebook if (notebook named notebook_name) exists then -- Need confirmation set dialogReply to display alert ¬ "Warning!" message ("Notebook named &#123;" &amp; notebook_name &amp; "&#125;") ¬ as warning ¬ buttons &#123;"Cancel", "Delete"&#125; ¬ default button 1 ¬ giving up after 9 -- Get the Result of the Dialog if "Delete" = (button returned of result) then -- Delete notebook delete (notebook named notebook_name) end if end ifend tellNoteExist, Find, Create, Import, Export, Read, Rename, Move, Delete1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253tell application "Evernote" set notebook_name to "nb_1" set enex_path to "path_1" # as Unix dir path if (notebook named notebook_name) exists then -- Import Note import (enex_path as POSIX file) to notebook_name end if -- Find Notes (by a search expression) -- `find notes "search_expr"` returns a list that contains one or more notes. set note_found to find notes "intitle:\"" &amp; note_name &amp; "\"" -- Search Grammar: https://dev.evernote.com/doc/articles/search_grammar.php -- Make sure that only one note specified by the search expression was found. -- Just manipulate the specified one for avoiding misoperations. if (count of note_found) = 1 then -- Read Note (as HTML) set html_cont to HTML content of (item 1 of note_found) -- Append Note (with plain text) append (item 1 of note_found) text text_append -- Export Note (as HTML) set html_path to "html_path" export note_found to (POSIX file html_path) format HTML -- Export Note (as ENEX) export note_found to (POSIX file enex_path) -- Move Notes set note_found to find notes "intitle:\"notebook_name\"" repeat with each_note in note_found move each_note to notebook named "another_notebook_name" end repeat -- Delete Note delete item 1 of note_found end if set new_note_name to "note_b" set note_found to find notes "intitle:\"" &amp; note_name &amp; "\"" if (note_name ≠ new_note_name) and (count of note_found) = 1 then -- Rename Note set title of item 1 of note_found to new_note_name end ifend tellSimplify Formating1234567891011121314151617181920212223242526272829303132333435363738tell application "Evernote" set t_note to (find notes ("intitle:\"" &amp; note_name &amp; "\"")) set t_note to item 1 of t_note set note_win to open note window with t_note -- Wait for OS to react delay 0.2 activate note_win -- Use "System Events" to imitate user's manipulation tell application "System Events" -- Put Cursor into Text Editor key code 48 delay 0.1 key code 48 delay 0.1 -- Select All keystroke "a" using command down delay 0.2 -- Simplify Formatting keystroke "f" using &#123;command down, shift down&#125; delay 0.4 -- Save keystroke "s" using command down delay 0.8 end tell close note_winend tellWrite Note content to Clipboard1234567891011121314151617181920212223242526272829303132333435tell application "Evernote" set t_note to (find notes ("intitle:\"" &amp; note_name &amp; "\"")) set t_note to item 1 of t_note set note_win to open note window with t_note activate note_winend tell-- Use "System Events" to imitate user's manipulationtell application "System Events" delay 0.1 -- Put Cursor into Text Editor key code 48 delay 0.1 key code 48 delay 0.1 -- Select All keystroke "a" using command down delay 0.2 -- Copy Text to the Clipment keystroke "c" using command down delay 0.2end telltell application "Evernote" close note_winend tellreturn the clipboardmacOSIf your Mac does not have some commands as mentioned below, you can install them through Homebrew.Is Mac on AC Power?123set is_ac_power to do shell script "pmset -g batt | grep -q 'AC Power' &amp;&amp; echo 1 || echo 0"return ("1" = is_ac_power)Is application running?12345set app_name to "app_x"tell application "System Events" return (name of processes) contains app_nameend tellIs application on Dock?123456789101112131415161718set app_name to "app_x"tell application "System Events" tell process "Dock" tell list 1 try set dockItemTest to UI element app_name -- test if the application is in the Dock on error return false end try click UI element app_name -- Optional: Click it on Dock (Active the app) return true end tell end tellend tellIs network available?12345678910111213141516repeat with i from 1 to 5 try do shell script "ping -c 4 baidu.com" exit repeat on error delay 0.2 if i = 5 then return false end tryend repeatreturn trueSwitch Wi-fiYou need to show Wi-Fi status in menu bar:System Preferences → Network → Check Show Wi-Fi status in menu bar.1234567891011121314151617181920212223242526set flag to truetell application "System Events" to tell process "SystemUIServer" set wifi_menu to (first menu bar item whose description contains "Wi-Fi") of menu bar 1 try if flag = true then if description of wifi_menu contains "not enabled" then do shell script "networksetup -setairportpower en0 on" end if else if flag = false then if not (description of wifi_menu contains "not enabled") then do shell script "networksetup -setairportpower en0 off" end if else return "error" end if end tryend tellreturn trueIs Bluetooth ON?You need to install the command blueutil (through Homebrew).123set is_bluetooth_on to do shell script "/usr/local/bin/blueutil power"return ("1" = is_bluetooth_on)Swith Bluetooth123456789101112131415161718192021222324252627282930set flag to truetell application "System Preferences" reveal pane id "com.apple.preferences.Bluetooth" delay 0.1 tell application "System Events" to tell process "System Preferences" set bluetooth_switch to button 3 of window 1 if flag = true then if "Turn Bluetooth Off" ≠ name of bluetooth_switch then click bluetooth_switch end if else if flag = false then if "Turn Bluetooth Off" = name of bluetooth_switch then click bluetooth_switch end if else return "error" end if end tell delay 0.1 quitend tellreturn trueInput Key Code / Keystroke12345678910set app_name to "app_1"set key_code to "key_1"set using_btn to "btn_1"tell application "System Events" to tell process app_name delay 0.3 # we have to wait for a while to make keystroke successful key code key_code using using_btnend tell12345678910set app_name to "app_1"set key_char to "key_1"set using_btn to "btn_1"tell application "System Events" to tell process app_name delay 0.3 # we have to wait for a while to make keystroke successful keystroke key_char using using_btnend tellEject Disks123456789101112131415161718192021222324252627282930tell application "Finder" -- Specify a disk to eject set diskName to "IceHe_OSX_Bak" -- Check disk existence try disk diskName on error display alert ("Disk '" &amp; diskName &amp; "' does Not Exist!") return end try -- Eject specified one eject disk diskName -- Check &amp; display operation result try disk diskName display alert "FAIL to eject disk '" &amp; diskName &amp; "'!" on error display alert "SUC to eject disk '" &amp; diskName &amp; "'!" end try -- Eject all disks eject the disks display dialog "Successfully ejected disks." buttons &#123;"Close"&#125; default button "Close"end tellExecute Commands in iTermThe version of iTerm is beta 3.0.123456789101112131415161718192021222324252627282930313233set cmds to &#123;"cmd_1", "cmd_2", "cmd_3"&#125;set isOpenAlready to application "iTerm" is running-- 启动终端，然后执行命令行tell application "iTerm" activate -- macOS 下有可能：iTerm 在脚本执行前已经运行，但还没窗口 set without_win to 0 = (count of windows) if without_win then create window with default profile end if tell current window -- iTerm 在脚本执行前已经运行，且也有窗口时， -- 新建一个 tab，避免影响其它 tab 的作业状态。 if isOpenAlready and not without_win then create tab with default profile end if tell current session repeat with cmd in cmds write text cmd end repeat end tell end tellend tellGet local IP address12345678910111213141516171819-- Physical: 物理网口的 IPset cur_ip to do shell script "/sbin/ifconfig en7|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d 'addr:'"if cur_ip = "" then -- Wireless: 无线网络的 IP set cur_ip to do shell script "/sbin/ifconfig en0|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d 'addr:'"end ifif cur_ip = "" then -- All: 全部网络的 IP set cur_ip to do shell script "/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d 'addr:'"end ifif cur_ip ≠ "" then -- Copy the IP address to the macOS clipboard do shell script "echo '" &amp; cur_ip &amp; "' | tr -d \"\\n\" | pbcopy" display alert "IP: " &amp; cur_ipend ifStartup Tasks12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667on run argv if script = class of argv then set is_startup to true else set is_startup to (item 1 of argv) end if -- Append the records to the list set apps to &#123;&#125; set apps to apps &amp; &#123;&#123;name:"iStat Menus", ac_power:true&#125;&#125; # Slow set apps to apps &amp; &#123;&#123;name:"Moom", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"ClipMenu", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"Bartender 2", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"HyperDock Helper", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"Amphetamine", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"Flux", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"HazeOver", ac_power:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"ShadowsocksX", online:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"Firefox", ac_power:true, online:true&#125;&#125; # Slow set apps to apps &amp; &#123;&#123;name:"iHosts", ac_power:true, online:true&#125;&#125; set apps to apps &amp; &#123;&#123;name:"Evernote", ac_power:true, online:true&#125;&#125; set is_ac_power to run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_ac_power.scpt") set is_online to run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_network_available.scpt") repeat with each_app in apps set is_allowed to true try if (online of each_app) ≠ is_online then set is_allowed to false end if on error -- -1728: undefined field 'online' -- do nothing end try try if (ac_power of each_app) ≠ is_ac_power then set is_allowed to false end if on error -- -1728: undefined field 'ac_power' -- do nothing end try if is_startup then if is_allowed and not (run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_app_running.scpt") with parameters &#123;name of each_app&#125;) then tell application (name of each_app) to launch end if else if not is_allowed and (run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_app_running.scpt") with parameters &#123;name of each_app&#125;) then tell application (name of each_app) to quit end if end if end repeat -- Romove iStatMenus from Dock if is_startup then set target_app to "iStat Menus" if (run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_app_running.scpt") with parameters target_app) and (run script (POSIX file "/Users/IceHe/Documents/AppleScript/Lib/is_app_on_dock.scpt") with parameters target_app) then tell application target_app to quit end if end ifend run]]></content>
      <categories>
        <category>AppleScript</category>
      </categories>
      <tags>
        <tag>AppleScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppleScript 快速入门]]></title>
    <url>%2Fapplescript%2Fapplescript%2F</url>
    <content type="text"><![CDATA[ReferencesAppleScript Fundamentals - Apple Official DocsApp’s AppleScript Dictionary :Open App Script Editor → &nbsp;Enter ⌘ ⇧ o → &nbsp;Choose app_name.app (if it supports AppleScript)My Github Repos:AppleScript_for_EvernoteAppleScript_for_meFundamentalsExport *.scpt as a runable Application（导出为可运行程序）:Menu Bar File → Export → Choose Format Application → Click Save12345678-- Comment -- line comment # line comment (* block comment ... *)TypesTypes and their related operations.123456789101112131415161718192021222324252627282930313233343536373839404142-- String "string" # The string must not be surrounded with single quotes! # It's wrong like this 'string'.-- Join String "abc" &amp; "123" # "abc123"-- List &#123;1, 7, "Beethoven", 4.5&#125; &#123;&#125; # Empty List-- Length of List set a_list to &#123;"foo", "bar"&#125; count of a_list # 2-- Get a item from a list # item &lt;number&gt; of &lt;list&gt; item 1 of a_list # "foo"-- Record &#123;product:"pen", price:1.45&#125; product of rec # "pen"-- Number 123 # integer -94596 # negative integer 3.1415 # real 9.9999999999E+10 # scientific-- Class &amp; Other Objects # OmmitedBasic Operations123456789101112131415161718192021222324252627282930313233343536373839404142434445464748-- Assign Variable set myName to "John" copy 33 to myAge-- Reference a ref to something ref to something-- &amp; Operator # It can be used on Text, Class, Object... "hello" &amp; ", " &amp; "world" # Text-- as Operator # Converts, or coerces, a value of one class to a value of another class. 123 as string # "123" "45" as integer # "45" "/Users/IceHe/.vimrc" as POSIX file # file # integer, string or real set num to "12306" as integer-- Calculate 1 + 2 # 3 2 - 3 # -1 3 * 4.5 # 9.0 # real 3 / 6 # 0.5 2 ^ 3 # 8.0 # 2 to the power of 3 9 div 4 # 2 # Divide Exactly 9 mod 4 # 1 # Remainer-- 获取变量的类型 class of &lt;variable_name&gt; class in &lt;variable_name&gt; # 包括 integer、real、text等-- 逻辑运算 not variable class of variableDateSrc Code :123456789101112131415161718192021222324252627282930313233set today to current datelog todaylog year of todaylog month of todaylog day of todaylog time of todaylog date string of todaylog time string of todaylog short date string of todayset year of today to 2008set month of today to 12set day of today to 24set time of today to 3 * hours + 12 * minutes + 12—- hours &amp; minutes &amp; days &amp; months &amp; years are built-inlog todayset curDate to current dateset doomDate to date "Friday, December 21, 2012 at 06:00:00"set btwDate to curDate - doomDatelog doomDatelog btwDateset y to btwDate div (days * 365)set d to (btwDate - y * 365 * days) div daysset h to (btwDate - y * 365 * days - d * days) div hoursset m to (btwDate - y * 365 * days - d * days - h * hours) div minutesset s to (btwDate - y * 365 * days - d * days - h * hours - m * minutes)log "Countdown:" &amp; y &amp; " " &amp; m &amp; " " &amp; d &amp; " " &amp; h &amp; ":" &amp; m &amp; ":" &amp; sResult :1234567891011121314(*date Saturday, September 19, 2015 at 16:50:34*)(*2015*)(*September*)(*19*)(*60634*)(*Saturday, September 19, 2015*)(*16:50:34*)(*9/19/15*)(*date Wednesday, December 24, 2008 at 03:12:12*)(*date Friday, December 21, 2012 at 06:00:00*)(*86613240*)(*Countdown: 2years 14months 272days 11:14:0*)Conditional123456789101112131415161718192021222324252627282930313233-- contains, is contained by &#123; "this", "is", 1 + 1, "cool" &#125; contains &#123; "is", 2 &#125; # true &#123; "this", "is", 2, "cool" &#125; contains 2 # true 2 is contained by &#123; "this", "is", 2, "cool" &#125; # true-- equal to ("1" as integer) is equal to 1 # true ("1" as integer) is not equal to 1 # false # Same as = and ≠ 1 = 1 # true 1 ≠ 1 # false-- greater than, less than 3 is greater than 1 # true 2 is less than 1 # false # Same as &gt; and &lt; 3 &gt; 1 # true 2 &lt; 1 # false-- starts with, ends with # Work with text objects and lists. "icehe" starts with "ice" # true "icehe" ends with "he" # true &#123;"foo", "bar"&#125; starts with "foo" # true &#123;"foo", "bar"&#125; ends with "bar" # trueControl Statements123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142-- Conditional 逻辑语句 # if &lt;expr&gt; then # ... # else if &lt;expr&gt; then # ... # else # ... # end if display alert "Hello, world!" buttons &#123;"Rudely decline", "Happily accept"&#125; set theAnswer to button returned of the result if theAnswer is "Rudely decline" then beep 5 else if theAnswer is "Happily accept" then say "Hello." else say "Piffle!" end if-- Loop 循环语句 # Repeat forever repeat -- commands to be repeated end repeat # Repeat a given number of times repeat 10 times -- commands to be repeated end repeat-- Conditional Loop set x to 5 repeat while x &gt; 0 set x to x - 1 end repeat set x to 5 repeat until x ≤ 0 set x to x - 1 end repeat # Loop with variable repeat with i from 1 to 2000 -- commands to be repeated end repeat # Enumerate a list set total to 0 repeat with x in &#123;1, 2, 3, 4, 5&#125; set total to total + x end repeat-- Tell 命令块 tell application "Finder" quit end tell # or express in one line tell application "Microsoft Word" to quit # For events in the "Core Suite", # (activate, open, reopen, close, print, and quit) # the application may be supplied as the direct object to transitive commands: quit application "Microsoft Word" # The concept of an object hierarchy can be expressed using nested blocks: tell application "QuarkXPress" tell document 1 tell page 2 tell text box 1 set word 5 to "Apple" end tell end tell end tell end tell # It can also be expressed using nested prepositional phrases: pixel 7 of row 3 of TIFF image "my bitmap"-- Handler on func_name(params...) -- subroutine commands end func_name on run -- commands end run on rock around the clock display dialog (clock as string) end rock -- called with: rock around the current date to check for yourNumber from bottom thru top if bottom ≤ yourNumber and yourNumber ≤ top then display dialog "Congratulations! You scored." end if end check -- called with: check for 8 from 7 thru 10-- Catch Error 捕获错误 try -- commands to be tested on error -- error commands end try-- Script script scriptName -- commands and handlers specific to the script end script # Script objects can use the same 'tell' structures that are used for application objects, and can be loaded from and saved to files. # Runtime execution time can be reduced in some cases by using script objects.-- Execute AppleScript Scripts as Shell Commands #!/usr/bin/osascript -- Beginning it with the following line and giving it execute permissionComponents123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778-- log 历史记录log pilog test# log result(*3.14159265359*)(*test*)-- Execute Shell Commands set fileInfo to do shell script "cd ~; ls"-- An audio message using a synthesized computer voice say "Hello, world!"-- Beep 5 times beep 5-- Delay for 9.8 seconds delay 9.8-- A modal window with “OK” and “Cancel” buttons display dialog "info_text"-- A modal window with a single “OK” button and an icon representing the app displaying the alert display alert "warning_text"-- ¬ character &amp; Dialog Samples # It can be produced by typing option-return in the Script Editor, # It denotes continuation of a single statement across multiple lines.) # For example: -- Dialog set dialogReply to display dialog "Dialog Text" ¬ default answer "Text Answer" ¬ hidden answer false ¬ buttons &#123;"Skip", "Okay", "Cancel"&#125; ¬ default button "Okay" ¬ cancel button "Skip" ¬ with title "Dialog Window Title" ¬ with icon note ¬ giving up after 15 -- Choose from list set chosenListItem to choose from list &#123;"A", "B", "3"&#125; ¬ with title "List Title" ¬ with prompt "Prompt Text" ¬ default items "B" ¬ OK button name "Looks Good!" ¬ cancel button name "Nope, try again" ¬ multiple selections allowed false ¬ with empty selection allowed -- Alert set resultAlertReply to display alert "Alert Text" ¬ as warning ¬ buttons &#123;"Skip", "Okay", "Cancel"&#125; ¬ default button 2 ¬ cancel button 1 ¬ giving up after 2-- Get Input 获取输入的数据 display dialog "please input" default answer "" log text returned of resultAdvancedIt is not the whole AppleScript above.If you want know more in detail, please read official documentations.Further use:用 AppleScript 操作 Evernote / macOSA service to log Dictionary lookups]]></content>
      <categories>
        <category>AppleScript</category>
      </categories>
      <tags>
        <tag>AppleScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 总结]]></title>
    <url>%2Fcmd%2Fgit_note%2F</url>
    <content type="text"><![CDATA[Omit the unusual commands at my work.ReferencesGit SCM —— Official SiteGit Book - Official Guide 细致全面（简体中文版）Git Reference - Official Docs猴子都能懂的 Git 入门 - 深入浅出（中文版）闯过这 54 关，点亮你的 Git 技能树 - 实用主义。在具体的工作场景下学习如何使用廖学峰的官方网站：Git 教程 - 快速上手30 天精通 Git 版本控管 - 深入理解GIT和SVN之间的五个基本区别 - 英文出处Memo笔者不时得用上但常忘记的指令。提要：HEAD 代表的是最近的一次提交（ Refname ）。Frequent 频繁凭印象简单罗列出以下个人常用命令，仅供参考。git statusgit diff : --cached , HEAD^ compare to the past of the past , --word-diffgit pull : [remote_name:branch_name]git add ( git rm , git mv ) : -u the updated , -A allgit commit : --amend fix | append , -m commit msg , -a add allgit pushgit stash : pop , list , drop [stack_id] , clear allgit log : --statgit refloggit reset : --hard , [commit_id]git rebase : -i , --continue , --abortgit checkout : [branch_name] switch to , [path/to/file|dir] back to the past , -b [branch_name] new branchgit branch : -a list all , -d delete | -D force to deletegit cherry-pick [commit_id]git remote add [name] [url]git config : -e edit , --listCheck 检查Commit 提交git status -s 查看仓库状态（以短格式）。git reflog 最近的 Git 操作历史。git log --oneline 查看提交日志（以短格式）。git log -p -2 - -p 用来显示每次提交的内容差异；加上 -2 以便仅显示最近两次提交。---git diff 查看 working tree 与 index file 的差别。git diff --cached 查看 index file 与 commit 的差别。git diff HEAD 查看 working tree 和 commit 的差别。File 文件git blame -C &lt;file_path&gt; 查出错误代码的最后的编辑者。git blame -L -C [开始行数],[结束行数] &lt;filename&gt;查看某文件每行代码的变更历史，包括 commit id，作者，时间，行号。---加上 option -C Git 会分析正在标注的文件，并且尝试找出文件中从别的地方复制过来的代码片段的原始出处。Git 不会显式地记录文件的重命名，而会记录快照，然后在事后尝试计算出重命名的动作。这其中有一个很有意思的特性就是你可以让 Git 找出所有的代码移动。Text 文本git grep &quot;search_text&quot; 在 Git 仓库中，查找代码片段。Index 索引git add &lt;file_path&gt; 将需要提交的文件加入暂存区。---git rm --cached &lt;file_path&gt; 删除文件在 Git 中的索引，但保留原件！--staged = --cached---git commit -m &quot;commit_desc&quot; 提交修改，并添加描述。git commit -am &quot;commit_desc&quot; 自动将被修改、删除的文件（不包括未加入索引的文件）加入暂存区，并提交。---git log --pretty=&quot;%H&quot; --author=&quot;authorname&quot; | while read commit_hash; do git show --oneline --name-only $commit_hash | tail -n+2; done | sort | uniq列出某个作者所有修改过的文件 ( Ref )。Back 反悔File 文件git checkout &lt;file_path&gt; 将已被修改的文件恢复到上一次提交的状态。git checkout &lt;commit_id&gt; &lt;file_path&gt; 将已被修改的文件恢复到指定版本的状态。---git reset 取消所有文件的暂存状态（staged，即等待被 commit 的状态）。git reset HEAD &lt;file_path&gt; 取消该文件的暂存状态。git reset &lt;commit_id&gt; &lt;file_path&gt; 取消该文件的暂存状态，将其 HEAD 指针移到指定 commit_id 的版本。Commit 提交遗漏了部分需要提交的变更后，将其补充到上一个提交：git commit --amend 上一次提交的内容有误，对其进行补充或更正。错误合并后，返回合并前的状态：git reset --hard ORIG_HEAD 成功合并后反悔，回到合并前的状态。git reset --soft HEAD^ 取消上一次提交，但保留提交后的修改。git reset --hard HEAD^ 取消上一次提交，不保留提交后的修改。另一种方式：（未经笔者验证过）12$ git checkout &lt;merge 操作时所在的分支&gt;$ git reset --hard &lt;merge 前的版本号（其 commit_id）&gt;选取部分有用的变更，应用到另一分支上：git cherry-pick &lt;commit_id&gt; 将另一分支的某一个 commit 的修改，应用到当前的分支来。当某个分支将要被删除，但其中某些 commit 的修改是有用的，于是将其单独取出来。git cherry-pick &lt;commit_id&gt; -e 提交前，需要重新编辑其提交说明。git cherry-pick &lt;commit_id&gt; -n 执行 cherry-pick 操作，只为套用该 commit 修改，但不会自动提交。以便在进行一些其它修改后，再一并提交。变更已经被提交到远端服务器后，回滚该变更：git revert commit_id 撤销某个 commit 的修改（以新建一个提交的方式）。一般在需要撤销的 commit 已经被 push 到远端服务器时，需要这么做。不慎 revert 了某次 commit 后，又反悔了，想恢复原来的状态，取消刚才的操作：12$ git reflog # 查看 revert 操作的前的 commit 的 id$ git checkout &lt;commit_id&gt; # 恢复到 revert 前的 commit 的状态。Branch 分支git branch 查看分支。git branch &lt;branch_name&gt; 新建分支。---git checkout -b &lt;branch_name&gt; 新建分支，并切换到该分支。git checkout &lt;branch_name&gt; 切换分支。---_git merge &lt;branch_name&gt; 将另一分支导入到当前分支。__git merge --squash &lt;branch_name&gt; 把另一分支的所有提交合并成一个提交，并导入到当前分支。`_---git fetch -p 删除远程不存在的分支。git branch --merged | egrep -v &quot;(^\*|master|dev)&quot; | xargs git branch -d 删除所有已经合并到主干的本地分支 ( Ref )Config 配置git config user.name &quot;icehe&quot; 设置用户名。git config user.email &quot;x@icehe.me&quot; 设置邮箱。---git credential.helper osxkeychain 长久储存密码，不用每次输入（macOS）。git config credential.helper store 长久储存密码，不用每次输入（非 macOS）。git config --unset credential.helper 密码更改后，重新设定。最后，还是建议为 Git 配置 SSH Keys 或 GPG Keys，提交拉取代码免登录，既安全又方便。Pull &amp; Pushgit pull faraway another:master 将远端 faraway 仓库的 another 分支，拉到本地 master 分支。git push faraway master:another 从本地的 master 分支，推送到远端的 faraway 的仓库的 another 分支。---git config http.postBuffer 524288000 当更新的内容较多时，Git 的缓存区可能不够用，可能导致 git push 失败，需用该指令增加缓存空间。Rebase 变基git rebase &lt;branch_name&gt; 变基的操作可能会发生 “冲突” 等意外状况。git rebase --continue 修复 “冲突” 等意外后，执行它以继续变基操作。git rebase --abort 假如情况弄得一团糟，需要中途中止变基操作时，运行该指令。Short DocsAbbreviationsabbr abbreviationaddr addressauto automatically---cmd commandconfig configurationcur current---del deletedesc descriptiondiff differencedir directorydirs directoriesdocs documentations---info informationmsg messagemv movenum number---obj objectopt optionproj project---repo repositoryrm removevar variableSetup &amp; ConfighelpDisplay help info.--all | -a All available cmds.configGet and set repo or global opts.git config name [value]-----list | -l List all config vars.--edit | -e Modify config file.--unset Rm matching key.-----local Write opts to repo .git/config .--global … to global ~/.gitconfig--system … to system-wide $(prefix)/etc/gitconfigCreate &amp; Get ProjinitCreate an empty Git repo or reinitialize an existing one.--bare 创建裸仓库。裸仓库在 Git 服务器上，纯粹为了共享使用，没有 working dir，其目录一般以 .git 结尾。clone &lt;repo&gt; [&lt;dir&gt;]Clone a repo into a new dir.--branch &lt;branch_name&gt; | -b &lt;branch_name&gt;Snapshotadd &lt;pathspec&gt;Add file contents to the index.--all | -A--update | -u Update the file modified in the working tree!statusShow the working tree status.--short | -s Show in short-format.diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…]Show changes between commits, commit and working tree, etc.--minimal Spend extra time to make sure the smallest possible diff is produced.--patience Generate a diff using the “patience diff” algorithm.--histogram Generate a diff using the “histogram diff” algorithm.commitRecord changes to the repo.--all | -a Auto stage files that have been modified and deleted, but not untracked ones.--message=&lt;msg&gt; | -m &lt;msg&gt; Use givenas the commit msg.--amend Replace tip of cur branch by creating a new commit.reset [&lt;mode&gt;] [&lt;commit&gt;]Reset cur HEAD to the specified state.Modes:--soft Does not touch the index file or the working tree at all (but resets the head to &lt;commit&gt;).--mixed Resets the index but not the working tree.--hard Resets the index and working tree.--merge, --keep …rm &lt;file&gt; …Remove files from the working tree and from the index.-r Allow recursive removal.--cached Remove paths only from the index.mv &lt;source&gt; &lt;destination&gt;Move or rename a file, dir or a symlink.Branch &amp; Mergebranch [&lt;option&gt;] &lt;branch_name&gt;List, create, or del branches.--delete | -d--force | -f-D Shortcut for --delete --force-----move | -m Move / Rename.-M Shortcut for --move --force-----all | -acheckout &lt;commit&gt;Switch branches or restore working tree files.&lt;commit&gt; can be a branch, a commit(id), a tag or a file path.---[-b|-B] &lt;new_branch&gt; [&lt;start_point&gt;] Create a new branch.-B … , if the branch already exists, reset it to &lt;start_point&gt;&lt;start_point&gt; The name of a commit at which to start the new branch. Defaults to HEAD.---git checkout [--] &lt;file_path&gt; Dangerous! 撤销对工作区修改；这个命令是以最新的存储时间节点（add和commit）为参照，拷贝原来版本的文件覆盖工作区对应文件。除非确实不要那个文件中的修改了，否则不要使用这个命令！merge &lt;commit&gt;Join two or more development histories together.&lt;commit&gt; can be a branch name, a commit id or a tag id.log [&lt;options&gt;] [&lt;revision range&gt;] [[--] &lt;path&gt;…]Show Commit logs.-L &lt;start&gt;,&lt;end&gt;:&lt;file&gt;&lt;start&gt; &amp; &lt;end&gt; can be line num, /regex/ or +offset | -offset (line num) .-L :&lt;funcname&gt;:&lt;file&gt;[--] &lt;path&gt;… Show commits related to specified paths in brief.----p Show diff between each commits.--stat Generate a diffstat.--name-status Show only names and status of changed files.--abbrev-commit show only a partial prefix of the full 40-byte hexadecimal object name.--graph Draw a text-based graphical representation of the commit history on the left hand side of the output.stashStash the changes in a dirty working dir away.git stash = git stash save---list List stashes you have.show [&lt;stash&gt;] Show the changes recorded in specific stash.pop [&lt;stash&gt;] Rm a single stashed state from the stash list and apply it on top of the cur working tree state.---&lt;stash&gt; e.g. stash@{&lt;revision&gt;}ster +10 ~0 -0 !在这段提示的地方，你可以看到几个东西：master 代表目前工作目录是 master 分支，也是 Git 的预设分支名称。“红色”的数字都代表 Untracked (未追踪)`tag [-f] [-m &lt;msg&gt;] &lt;tag_name&gt; [&lt;commit&gt; | &lt;object&gt;]Create, list, del or verify a tag obj signed with GPG--force | -f Replace an existing tag with the given name (instead of failing).--message=&lt;msg&gt; | -m &lt;msg&gt; Use the given tag msg (instead of prompting).Add a tag reference in refs/tags/, unless -d and -l (to del or list tags).mergetool …Share &amp; Updatefetch [&lt;options&gt;] [&lt;repo&gt;]Download objs and refs from another repo.--all Fetch all remotes.--prune | -p Before fetching, remove any remote-tracking references that no longer exist on the remote.pull [&lt;options&gt;] [&lt;repo&gt;]Fetch from and integrate with another repo or a local branch.In its default mode, git pull is shorthand for git fetch followed by git merge FETCH_HEAD.push [&lt;repo&gt;]Update remote refs along with associated objs.--all Push all branches.remoteManage set of tracked repos.add [-t &lt;branch&gt;] &lt;name&gt; &lt;url&gt;rename &lt;old&gt; &lt;new&gt;remove &lt;name&gt; | rm &lt;name&gt;show, set-url …submoduleInitialize, update or inspect submodules.Inspect &amp; CompareshowShow various types of objs.shortlog [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…]Summarize git log output.--summary | -s Suppress commit desc and provide a commit count summary only.--email | -e Show the email addr of each author.log, diff &nbsp; See above.describe …Patchrevert &lt;commit&gt;…Revert some existing commits.git revert --continue Continue the operation in progress using the info .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.git revert --quit Clear the sequencer state after a failed cherry-pick or revert.git revert --abort Cancel the operation and return to the pre-sequence state.rebase [&lt;upstream&gt; [&lt;branch&gt;]]Forward-port local commits to the updated upstream head.&lt;upstream&gt; Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the cur&lt;branch&gt; Working branch; defaults to HEAD.--interactive | -i Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing.---git rebase --continue Restart the rebasing process after having resolved a merge conflict.git rebase --abort Abort the rebase operation and reset HEAD to the original branch.cherry-pick &lt;commit&gt;…Apply the changes introduced by some existing commits.-edit | -e Edit the commit msg prior to committing.--no-commit | -n Apply the changes without making any commit.---git cherry-pick --continue Continue the operation in progress using the info in .git/sequencer. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.git cherry-pick --quit Forget about the cur operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.git cherry-pick --abort Cancel the operation and return to the pre-sequence state.diff &nbsp; See above.apply …Debugbisect &lt;subcommand&gt; &lt;options&gt;Use binary search to find the commit that introduced a bug.Subcommands: start, good, bad, reset …blame &lt;file&gt;Show what revision and author last modified each line of a file.-b Show blank SHA-1 for boundary commits. This can also be controlled via the blame.blankboundary config opt.-l Show long rev (Default: off).-t Show raw timestamp (Default: off).----L &lt;start&gt;,&lt;end&gt; -L :&lt;funcname&gt; Annotate only the given line range. May be specified multiple times. Overlapping ranges are allowed.&lt;start&gt; and &lt;end&gt; are optional. -L &lt;start&gt; or -L &lt;start&gt;, spans from &lt;start&gt; to end of file. -L ,&lt;end&gt; spans from start of file to &lt;end&gt;.----M Detect moved or copied lines within a file.-C In addition to -M, detect lines moved or copied from other files that were modified in the same commit.grep &lt;pattern&gt;Print lines matching a pattern.--cached Instead of searching tracked files in the working tree, search blobs registered in the index file.--no-index Search files in the current directory that is not managed by Git.--untracked In addition to searching in the tracked files in the working tree, search also in untracked files.-----fixed-strings | -F Use fixed strings for patterns (don’t interpret pattern as a regex).--ignore-case | -i Ignore case diff between the patterns and the files.--line-number | -n Prefix the line num to matching lines.AdministrationreflogManage reflog info.--all Process the reflogs of all references.clean, gc, fsck, filter-branch, instaweb, archive, bundle …Emailam, apply, format-patch, send-email, request-pull …External Systemssvn, fast-import …Server Admindaemon, update-server-info …Plumbing Cmdsls-filesShow info about files in the index and the working tree.--cached | -c Show cached files in the output (default).--delete | -d … deleted …--modified | -m … modified …--others | -o … others …--ignored | -i … ignored …--stage | -i … stage …--unmerged | -u … unmerged …cat-file, commit-tree, count-objects, diff-index, for-each-ref, hash-object, merge-base, read-tree, rev-list, rev-parse, show-ref, symbolic-ref, update-index, update-ref, verify-pack, write-tree ….gitignoreA file specifies intentionally untracked files that Git should ignore. Files already tracked are not affected.Gitignore patterns from multiple sources, with the following order of precedence, from highest to lowest:From cmd line.File .gitignore specifies files all developers will want to ignoreFile $GIT_DIR/info/exclude specifies files that are just useful to a particular repoe.g., auxiliary files are specific to one user’s workflow.The file specified by config var core.excludesFile in the user’s file ~/.gitconfig.For ignoring some files in all situations. e.g., backup or temporary files generated by editors.Pattern FormatA line starting with # serves as a comment.An optional prefix ! which negates the pattern.A pattern which ends with a slash / will only find a match with a dir e.g. foo/ will match a dir foo and paths underneath it.A leading slash / matches the beginning of the pathname. For example, /*.c matches “cat-file.c” but not “mozilla-sha1/sha1.c”.* asterisk wildcard (通配符).…ConceptsGit 中的部分概念、指令的简要笔记。Commit IDGit 对象 id 是透过内容进行 SHA1 哈希后的结果，所以很长。在 Git 标示 “绝对名称” 时，可以用前面几个字符代替，最少不可低于 4 个字符。也就是说 4 ~ 40 个字符长度的 “绝对名称” 都是可以用的。Refname“参照名称” 简单来说就是 Git 对象的一个 “指针”，用来指向特定 Git 对象，所以可以把 “参照名称” 想像成 Git 对象绝对名称的别名 （Alias），用来帮助记忆。HEAD 代表最新版本，tag 标签名称，这些都是 “参照名称”，总之就是为了让你好记而已。不过当你输入参照名称的 “简称” 时，预设 Git 会依照以下顺序搜寻适当的参照名称，只要找到对应的文件，就会立刻回传该文件内容的“对象绝对名称”：.git/&lt;参照简称&gt;.git/refs/&lt;参照简称&gt;.git/refs/tags/&lt;参照简称;标签名称&gt;.git/refs/heads/&lt;参照简称;本地分支名称&gt;.git/refs/remotes/&lt;参照简称&gt;.git/refs/remotes/&lt;参照简称;远端分支名称&gt;/HEADGit 参照名称又有区分“一般参照”与“符号参照”，两者的用途一模一样，只在于内容不太一样。“符号参照” 会指向另一个 “一般参照”，而 “一般参照” 则是指向一个 Git 物件的 “绝对名称”。Differ ^ and ~相对名称表示法 ^ 与 ~ 的差异关于 ~ 的意义，代表“第一个上层 commit 对象”的意思。关于 ^ 代表的意思则是“拥有多个上层 commit 对象时，要代表第几个第一代的上层对象”。如果有一个“参照名称”为 C，若要找到它的第一个上层 commit 对象，可以有以下表达方式：C^ , C^1 , C~ , C~1如果要找到它的第二个上层 commit 对象（在没有合并的状况下），有以下表达方式：C^^ , C^1^1 , C~2 , C~~ , C~1~1但不能用 C^2 来表达“第二个上层 commit 物件”！原因是在没有合并的情况下，这个 C 只有一个上层对象而已，只能用 C^2 代表 “上一层对象的第二个上层对象”。上述概念比较抽象，透过图解更清晰易懂。如上图所示，想找到 C 这个 commit 对象的相对路径下的其它 commit 对象（上层对象），由于 C 这个 commit 对象有三个上层对象，这代表这个 commit 对象是透过合并而被建立的，那么要透过“相对名称”找到每一个路径，就必须搭配组合 ^ 与 ~ 的使用技巧，才能定位到每个想开启的版本。File Statuses“索引” 的目的主要用来纪录 “有哪些文件即将要被提交到下一个 commit 版本中”。换句话说，如果你想要提交一个版本到 Git c昂哭，那么你一定要先更新索引状态，变更才会被提交出去。Index 索引Cache 缓存Directory cache 目录缓存Current directory cache 当前目录缓存Staging area 等待被 commit 的地方Staged files 等待被 commit 的文件untracked 未追踪的，代表尚未被加入 Git 仓库的文件状态unmodified 未修改的，代表文件第一次被加入，或是文件内容与 HEAD 内容一致的状态modified 已修改的，代表文件已经被修改过，或是文件内容与 HEAD 内容不一致的状态staged 等待被 commit 的，代表下次执行 git commit 会将这些文件全部送入仓库Objectsblob 对象就是工作目录中某个文件的 “内容”，且只有内容而已，当你执行 git add 指令的同时，这些新增文件的内容就会立刻被写入成为 blob 对象，文件名则是对象内容的哈希运算结果，没有任何其它信息，像是文件时间、原本的文件名或文件的其它信息，都会储存在其它类型的对象里（也就是 tree 文件）。tree 对象这类文件会储存特定目录下的所有信息，包含该目录下的文件名、对应的 blob 对象名称、文件连结（symbolic link）或其他 tree 对象等等。由于 tree 对象可以包含其它 tree 物件，所以浏览 tree 对象的方式其实就跟文件系统中的“文件夹”没两样。简单来说，tree 对象这就是在特定版本下某个文件夹的快照（Snapshot）。commit 对象用来记录有那些 tree 对象包含在版本中，一个 commit 对象代表着 Git 的一次提交，记录着特定提交版本有哪些 tree 对象、以及版本提交的时间、纪录信息等等，通常还会记录上一层的 commit 对象名称只有第一次 commit 的版本没有上层 commit 对象名称。tag 对象是一个容器，通常用来关联特定一个 commit 对象（也可以关联到特定 blob、tree 对象），并额外储存一些额外的参考信息（metadata），例如: tag 名称。使用 tag 对象最常见的情况是替特定一个版本的 commit 对象标示一个易懂的名称，可能是代表某个特定发行的版本，或是拥有某个特殊意义的版本。）Cmd Prompt命令行提示符中，位于路径后面的 Git 相关提示：[master +10 ~0 -0 !]PS: 具体显示效果根据命令行配置而不同。在这段提示的地方，可以看到几个东西：master 代表目前工作目录是 master 分支，也是 Git 的预设分支名称。“红色” 的数字都代表 Untracked（未追踪）的文件，也就是这些修改都不会进入版本库。+10 代表有 10 个 “新增” 的文件。~0 代表有 0 个 “修改” 的文件。-0 代表有 0 个 “删除” 的文件。Reset Mode除了默认的 mixed 模式，还有 soft 和 hard 模式。欲了解受各模式影响的部分，请参照下面的表格。模式名称HEAD的位置索引工作树soft修改不修改不修改mixed修改修改不修改hard修改修改修改只取消提交（soft）。复原修改过的索引的状态（mixed）。彻底取消最近的提交（hard）。credential.helperGit 拥有一个凭证系统来处理密码储存的事，避免用户总是需要重复输入密码。git config credential.helper &lt;options&gt;Options as follow:默认所有都不缓存。 每一次连接都会询问你的用户名和密码。cache 模式会将凭证存放在内存中一段时间。密码永远不会被存储在磁盘中，会在15分钟后从内存中清除。store 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。osxkeychain 模式，需要你使用的是 Mac。它会将凭证缓存到你系统用户的钥匙串中。它将凭证存放在磁盘中，且永不过期，但会被加密，其加密方式与存放 HTTPS 凭证以及 Safari 的自动填写的方式是相同的。如果使用的是 Windows，可以安装一个叫做 “winstore” 的辅助工具。这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。可以在 https://gitcredentialstore.codeplex.com 下载。Rebase Example整合分支最容易的方法是 merge 命令。它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。“变基”（rebase）的方法：可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上再应用一次。使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。上图的操作指令是:12$ git checkout experiment$ git rebase master原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master）的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件，然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。现在回到 master 分支，进行一次快进合并，结果如下图。12$ git checkout master$ git merge experiment此时，C4’ 指向的快照就和上面使用 merge 命令的例子中 C5 指向的快照一模一样了。两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是先后串行的一样，提交历史是一条直线没有分叉。---一般这样做是为了确保在向远程分支推送时能保持提交历史的整洁，如向某个别人维护的项目贡献代码时。在这种情况下，首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。---请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。---总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式（变基VS合并）带来的便利。更多的变基例子参考 Git 分支 - 变基。Hook钩子，暂略。Zsh AliasesAll details : https://github.com/IceHe/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263alias g='git'alias ga='git add'alias gaa='git add --all'alias gb='git branch'alias gba='git branch -a'alias gbl='git blame -b -w'alias gc='git commit -v'alias gc!='git commit -v --amend'alias gca!='git commit -v -a --amend'alias gcm='git commit -m'alias gcam='git commit -a -m'alias gcf='git config'alias gcfl='git config -l'alias gce='git config -e'alias gcl='git clone --recursive'alias gco='git checkout'alias gcom'git checkout master'alias gcb='git checkout -b'alias gcp='git cherry-pick'alias gd='git diff'alias gdc='git diff --cached'alias gdw='git diff --word-diff'alias gg='git gui citool'alias gga='git gui citool --amend'alias ggr='git grep'alias gk='\gitk --all --branches'alias gke='\gitk --all $(git log -g --pretty=format:%h)'alias gl='git pull'alias glog='git log --oneline --decorate --graph'alias gp='git push'alias grm='git remote'alias grma='git remote add'alias gr='git reset HEAD'alias grh='git reset HEAD --hard'alias grb='git rebase'alias grba='git rebase --abort'alias grbc='git rebase --continue'alias grbi='git rebase -i'alias gs='git status -sb'alias gst='git stash'alias gsd='git stash drop'alias gsl='git stash list'alias gsp='git stash pop']]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 快捷键]]></title>
    <url>%2Fmac_shortcuts%2F</url>
    <content type="text"><![CDATA[天下武功，唯快不破。Simple &amp; Less没什么不好意思承认的，写这篇文章的初衷就是想炫耀自己的「与众不同」—— 彰显自己是一个酷爱快捷键的「键盘党」，一个有个性的少数派。然而这样做真的有意义吗？正确的做法：选用符合直觉的好设计 —— 它们容易上手、容易习惯，不容易被错误地使用。「开箱即用」，即用默认配置就能用得顺手，就是一个很高的标准。根据「二八法则」（帕累托法则），只做关键部分的改进，用更少的工具完成更多的事情。工具提供足够的设置选项，然后将工具配置得足够贴合个人的使用习惯。例如，同时使用多个 IDE 和代码编辑器的话，尽量将快捷键配置得一样，增强快捷键的通用性，减轻记忆快捷键的负担，减少误用；尽量都使用 Vim 插件，统一以 Vim 的方式操作，就可以进一步减轻记忆负担，增加操作效率。ExplanationHere are the Mac shortcuts:The default ones that I use most frequentlyAll my custom onesI hide all the default shortcuts that are of little use.Meanings of Font Format:The item with the superscript custom&nbsp; implies it might be custom by me.The italic item is not frequently-used.Related :《 Tools 利器 》《 Mac Efficiency 效率指北 》Reference :《 Mac 键盘快捷键 》Key Symbols Power⌘ Command ( Cmd )⌥ Option | Alt^ Control | Ctrl⇧ Shift ( Shf )⇪ CapsLock⇥ Tab⎋ Escape ( Esc )↩ Return ( Ret ) | Enter凵 Space↑ Up↓ Down ( Dn )← Left ( Lf )→ Right ( Rg )⌫ Delete ( Del ) | Backspace0~9 One of the digits 0 ~ 9a~z One of the alphabet a ~ zAbbreviationsButtonsCmd CommandCtrl ControlEsc EscapeOpt OptionRet ReturnShf ShiftDel DeleteDirections &amp; PositionsDn DownLf leftRg RightPrev PreviousBtm BottomWordsApp ApplicationDir DirectoryMv MoveRm RemoveStr StringPf PrefixSymbols&amp; And| OrOthersaka Also known asExamplesMeaning of Font StyleItalic : I seldom use it .custom : Added | modified by myself .⌘ ⌥ a ManipulationPress “Cmd”, “Opt” &amp; “a” at the same time to do the manipulation .A Manipulation⇧ A ManipulationThe capital letter “A” means pressing “Shf” &amp; “a” at the same time !⌘ 1 | ⌘ 2 ManipulationPress “⌘ 1” or “⌘ 2” to do the manipulation.⌘ 1, ⌘ 2 Manipulation⌘ 1, ⌘ 2 ManipulationPress “⌘ 1” then “⌘ 2” to do the manipulation.macOSSome are common &amp; default in operating system.Some of the keys below can be modified in System Preference → Keyboard.Some are modified by Apps Karabiner , Seil.SystemPower Wake Up⌘ ⌥  Sleep^ ⇧  Display Sleep^  Shut DownThen you can choose to Sleep or Restart in the prompt dialog box.Accessory⌘ 凵 SpotlightLf ^ = ⌥ 凵 Switch Input Sources customF1 Desktop custom⌥ ⇧ F Search in All Files custom⌥ ⇧ ? Show Help Menu customDock &amp; Menubar &amp; Sidebar^ F12 Do Not Disturb On/Off custom⌘ ⌥ d Dock Hiding On/OffFinderFile⌘ ↓ Open⌘ d Duplicate⌘ e Eject DiskFolder⌘ ⇧ A Application⌘ ⇧ D Desktop⌘ ⇧ F All My Files⌘ ⇧ G to Folder⌘ ⇧ O Documents⌘ ⇧ R AirDrop⌘ ⌥ l Downloads⌘ ⇧ N New Folder⌘ ↑ to Parent DirView凵 Quick Look⌘ i Get Info⌘ 1 View the files in way of Icon⌘ 2 View as a List⌘ 3 View as columns⌘ 4 View as a cover flow⌘ ⇧ ⌫ Empty TrashFile &amp; EditFile⌘ n New⌘ o Open⌘ s Save⌘ p Print⌘ ⇧ S Save asEdit⌘ f Search⌘ g Next Match⌘ ⇧ G Prev Match⌥ ← Prev Word⌥ → Next Word⌘ a Select All⌘ z Undo⌘ ⇧ Z Redo⌘ c Copy⌘ ⌥ c Copy Path⌘ v Paste⌘ ⌥ v Move ( After ⌘ c )After Selection, then input:⌘ b Bold⌘ u Underline⌘ i Italic⌘ + Bigger | Zoom In⌘ - Smaller | Zoom OutWindow &amp; TabWindow⌘ ` Switch windows of the current AppIt’s enhanced by App HyperSwitch | Keyboard Maestro⌘ ^ f Toggle Full Screen⌘ , Preferences⌘ q Exit⌘ w Close⌘ h Hide⌘ ⌥ h Hide All Apps But the Front-mostThe manipulation Hide is much better than Minimize in macOS!So I prefer Hide to Minimize.Tab⌘ r Refresh⌘ t New Tab⌘ 0~9 Select Tab( If there are more than 9 tabs, ⌘ 9 will select the last one. )^ ⇥ Next Tab^ ⇧ ⇥ Prev Tab⌘ ⇥ Next App⌘ ⇧ ⇥ Prev App⌘ [ Backward⌘ ] ForwardEmacs ModeA few people know that it’s supported in by default in macOS.They don’t work, if you append any modifier key to them.^ f = ←^ b = →^ p = ↑^ n = ↓^ a = ⌘ ← Home^ e = ⌘ → End^ t Exchange the Charactors before &amp; after the cursor^ o Insert a Blank Line &#39;\n&#39; after the cursor^ h = ⌫ Del^ d = Fn ⌫ Forward Del^ k Del to the End of the LineThey are also enabled in iTerm2 :Modified by .zshrc in Zsh and .vimrc in VimMoreoverModified by Keyboard Maestro^ w = ⌥ ⌫ Del Preceding Word custom^ u = [ ^ a, ^ k ] Del the Whole Line customThese modifications can be supported in Karabiner too.Ref : (Emacs) Keyboard Shortcuts for Editing Text Fields in OS XInput SourcesSelectLeft ^ = ⌥ 凵 Switch Input Source⌘ ^ 凵 Emoji &amp; SymbolsPinyin - Simplified (macOS default)[ Page Up] Page Down⇥ Sort By0~9 SelectBaidu Input Now I use^ t [ Simple | Traditional ] Chinese CharactersActivity Monitor⌘ ⌥ f Filter Processes⌘ ⌥ q Quit the selected ProcessCrazy RemappingsWhat are they used to:Remap the key codes.Open or Switch to the specified app or URL.Supported byKeyboard MaestroKarabinerSeilFunctional Keys = F1 ~ F12⌥ ⇥ Prefix KeyIt’s used to prevent you from launching the unwanted App when pressing its shortcut by accident.Only when you pressed Pf Key at first and then the App shortcut, did it launch.Layout 凵0123 …凵 1 iTerm2凵 2 Sublime Text凵 3 Firefox凵 4 Chrome凵 5 2Do凵 6 System Settings → Keyboard凵 7 Keyboard Maestro凵 8 Karabiner凵 9 Seilasdf …凵 o = \凵 p = | = ⇧ \凵 ;asdfghjkl = 0~9Symbols凵 ` = ⇧ ` = ~凵 - = ⇧ - = _凵 = = ⇧ = = +凵 [ = ⇧ [ = {凵 ] = ⇧ ] = }凵 \ = ⇧ \ = |凵 &#39; = ⇧ &#39; = &quot;Layout ⌥ ⇧ ^1234 …⌥ ` 1Password⌥ 1 Script Editor ( AppleScript )⌥ 2 System Preferences⌥ 3 Notesqwer …⌥ q QQ⌥ w WeChat⌥ e Mail⌥ r Preview⌥ t Thunder⌥ u Sublime Text⌥ i iTunes⌥ o OpenEmu⌥ p Postman⌥ \ 1Password ( Mini )⌥ ⇧ Q QQMusic⌥ ⇧ W Word⌥ ⇧ P PowerPoint⌥ ⇧ R VS Code⌥ ⇧ E Evernote⌥ ⇧ I Prompt the local IP address^ ⌥ ⇧ E Excel⌥ ] Show Bartender 2⌥ ⇧ ] Show Bartender 2asdf …⌥ a PyCharm⌥ s PhpStorm⌥ d EuDic Free⌥ f Finder⌥ g Acrobat Reader ( PDF )⌥ h Photos⌥ j IntelliJ IDEA⌥ k Numi ( Calculator )⌥ l CLion⌥ ; Input the symbol …⌥ ⇧ A Activity Monitor⌥ ⇧ S Safari⌥ ⇧ D Dictionary⌥ ⇧ F Search in All Files⌥ ⇧ J Eject the disks⌥ ⇧ K Calculator⌥ ⇧ L System Settings → Launch Rocket^ ⌥ ⇧ A App Storezxcv …⌥ x Xiami Music⌥ c Charles⌥ v ClipMenu ( History Menu )⌥ b MindNode ( b for Brainstorm )⌥ n NeteaseMusic⌥ m Messages⌥ ⇧ C Calendar⌥ ⇧ V ClipMenu ( Main Menu )⌥ ⇧ B System Settings → BlueTooth⌥ ⇧ M Send Clipboard to iPhone by Messages⌥ ⇧ N System Settings → Network^ ⌥ ⇧ M Sequel Pro ( MySQL )Layout FnArrange the windowsAka Resize &amp; Move the windows. ( Frequently Used )These features can be supported by Moom | Spectacle | Keyboard maestro.Fn d Lf 1/2Fn f Rg 1/2Fn e Lf 3/5Fn r Rg 3/5Fn g Fit to DesktopFn t Fit to Center 1/2Fn q Top Lf 1/4Fn w Top Rg 1/4Fn a Btm Lf 1/4Fn s Btm Rg 1/4Direction KeysThey’re Vim-like.Fn h = ← LfFn j = ↓ DnFn k = ↑ UpFn l = → RgLayout ⎋1234 …⎋ 123456790-= = Functional Keyse.g. Functional keys control Brightness, Music, Volume, Keyboard Light &amp; etc.qwer …⎋ w Weibo⎋ e Sina ERP⎋ r Sina Redmine⎋ i IceHe.me⎋ p PHP.netasdf …⎋ a Apple⎋ g Google⎋ h GitHub⎋ l localhost:4000zxcv …⎋ z Sina GitLab⎋ b BaiduKeyboard MaestroSearch in Web⌘ ^ ⇧ A Amazon⌘ ^ ⇧ B Baidu⌘ ^ ⇧ D Douban⌘ ^ ⇧ G Google⌘ ^ ⇧ J JD.com⌘ ^ ⇧ M Tmall⌘ ^ ⇧ T Taobao⌘ ^ ⇧ W Weibo⌘ ^ ⇧ Z ZhihuAbbrsDateType string |hm, it will be replaced by the time string hh:mmType |ymd, replaced by yy/MM/dd|Ymd/ → YYYY/MM/dd|Ymd- → YYYY-MM-dd( I abbreviate the similar sentences below like this. )Symbols|up → ↑|dn → ↓|lf → ←|rg → →|esc → ⎋|tab → ⇥|cap → ⇪|shf → ⇧|opt | |alt → ⌥|cmd → ⌘|spa → 凵|del → ⌫|ret | |ent → ↩|app → Others|[a-z]* → ID card number, my phone number &amp; etc.KarabinerChanges not only the shortcuts but also the keyboard key-remappings!Quit⌘ q, ⌘ q Double tap ⌘ q to send one real keystroke ⌘ qProfile⌘ ⌥ ^ ⇧ 1 Switch to the default setting profile ( without all custom key-remapping )⌘ ⌥ ^ ⇧ 2 Switch to the custom_mac setting profile⌘ ⌥ ^ ⇧ 3 Switch to the custom_hhkb setting profileThey’re used to toggle the custom setting profile for the guest who need to use my Mac temporarily.Input SourcesRg ⌥ = ⌘ 凵 Switch Input SourceSeilChange Modifier-Key-Remapping⇪ Caps → ^ Lf Ctrl⌘ Rg Cmd → ⎋ Esc^ Ctrl → to Chinese Layout ( Baidu Input Method )Required:System Preferences → Keyboards → Modifier Key : CapsLock → Control, Control → No ActionApp Seil : ^ Lf Ctrl → F19App Karabiner : F19 → F17App Keyboard Maestro : F17 → to Chinese Layout ( Ref )⇧ Lf &amp; Rg Shf | ⌘ Rg Cmd | ⎋ Esc → English Input MethodRequired:App Karabiner : LR⇧ | R⌘ | ⎋ will trigger F18 as wellApp Keyboard Maestro : F18 → to US English LayoutContactMail⌘ ⇧ N Get All New Mail⌘ ^ s Get All New Mail custom⌘ r Reply⌘ ⇧ r Reply All⌘ ⌥ f Mailbox SearchQQ⌘ ^ a Screenshot⌘ ^ r Screen RecordingTwo functions above can be used without opening QQ.⌘ ↑ Select Prev Chat⌘ ↓ Select Next ChatThey can be used in WeChat as well.⌘ 1 Switch to Messages⌘ 2 Switch to Contacts⌘ 3 Switch to ApplicationsSystem Assistant1Password⌘ \ Fill Login on current web page⌥ \ Show 1Password Mini⌘ e Edit⌘ s SaveClipMenu⌥ v History Menu⌥ ⇧ V Main MenuDevelopmentPhpStormReferencesQuick Guide : PhpStorm → Help → Keymap ReferenceAdvance Settings : PhpStorm → Preferences… → KeymapRefactor^ ⌥ t Refactor This^ ⌥ o Optimize Imports⌘ ⌥ l Reformat CodeThe rules for reformation can be modified in :Preferences → Editor → Code Style → Select the programming language.F5 Copy FileF6 Move File⌘ ⌥ e Rename $variableName, ClassName, functionName ( Auto rename other related code )⌘ ⌥ n Inline Variable⌘ ⌥ m Extract Method⌘ ⌥ v Extract Variable⌘ ⌥ F Extract Field⌘ ⌥ c Extract ConstantCode⌘ / Line Comment⌘ ⌥ / Block Comment⌥ ↑ Extend Selection⌥ ↓ Shrink Selection⌘ j Insert Live Template^ 凵 Auto Complete⌥ ↩ Show Intention Actions⌘ ⇧ ↩ Complete Current Statement^ ⌥ h Toggle Parameter Name^ ⌥ g Select All OccurrencesDebug^ ⇧ B Toggle Line BreakPoint^ ⇧ E Edit BreakPoint ( Break if conditional is true)^ ⇧ V View BreakPoints^ ⇧ W Add to Watches^ ⌥ w Add to Watches^ ⇧ R Run…^ ⇧ A Rerun^ ⇧ D Debug^ ⇧ S Stop^ ⇧ I Step Into^ ⇧ O Step Out^ ⇧ N Resume Program ( Next BreakPoint )^ ⇧ J Step Over ( Next Line )File⌘ ⇧ C Copy Path^ ⌥ r Copy Reference ( File:Line | Class::method() )⇧ ↩ Open in a new Editor WindowFind⌘ f Find⌘ ⇧ F Find in Paths⌘ r Replace⌘ ⇧ R Replace in Paths⌘ g Find Next⌘ ⇧ G Find Prev^ ⌥ g Toggle Regex^ ⌥ c Toggle Case Sensitive^ g Find Usage⌘ o Find Class⌘ ⇧ O Find File⌘ ⌥ o Find Symbols ( Class, Files, Methods, Functions )Navigate⌥ F1 Select current file or symbol in any view⌘ j Next Method⌘ k Prev Method⌘ e Recent Files⌘ ⇧ E Recently Edited Files⌘ ⇧ T Test Subject : Jump to Test for current file | Create Test for it⌘ ↑ Navigation Bar⌘ 1~9 Jump to the specified Tool Window | Hide it⌘ 1 Project⌘ 2 Favorites ( Projects, Bookmarks, Breakpoints )⌘ 3 Find⌘ 4 Debug…⌘ 9 Version ControlF2 Next Highlighted Error⇧ F2 Prev Highlighted Error^ m Toggle Bookmark^ ⌥ m View Bookmarks^ ⌥ j Next Bookmark^ ⌥ k Prev BookmarkVCS: History &amp; Compare⌘ t Update Porject from VCS^ ⇧ C Commit Project to VCS⌘ ⌥ g ‘VCS’ Operations Quick Popup^ ⌥ l Local History -&gt; Show History^ ⌥ a Git -&gt; Annotate^ ⌥ v Git -&gt; Compare with the Same Repository Version^ ⌥ b Git -&gt; Compare with Branch …^ ⌥ . Git -&gt; Compare with …^ ⌥ c Git -&gt; Resolve ConflictsTools⌘ ^ h Hide All Tool Windows^ ⌥ q Terminal^ ⌥ s Test RESTful Web ServiceIdeaVimIt is the best Vim-Emulator plugin for IDEs from JetBrains.Its most keys are the same as Vim, so I just list my custom keys.TabH Prev TabL Next TabCtags Like^ ] Find Declaration^ t Back from DeclarationMimic Emacs in Insert Mode:^ b = ←^ f = →^ p = ↑^ n = ↓^ a = Home^ e = End^ k Del to End of Line^ u Del to Head of Line^ t Exchange Chars ( Before &amp; After Cursor )Vim-Surroundds* Delete Surroundsuch as ds&#39; ds&quot; ds[ ds{ ds` dst ( t for HTML Tag ) …ys** Add Surround :1st * for Postion ( Start or Stop )2rd * for Surround Char (or HTML Tag)such as yse&#39; ysW&quot; ysfb[ ysTh{ …cs** Change Surround1st * for Current Surround Char2rd * for New Surround Charsuch as cs&#39;&quot; cs[{ cst&lt;p&gt;…Tripple h/j/k/l to Normal Modehhh | jjj | kkk | lll = ⎋JetBrainsThe shortcuts in other IDEs from JetBrains are same as PhpStorm,such as CLion , IntelliJ IDEA , RubyMine , PyCharm and so on.All the shortcuts can be modified in Preferences → Keymap!VS CodeFile &amp; Folder^ r Open Recent⌘ p Quick Open^ ⇧ w Close WindowView⌘ ⇧ E Explorer⌘ ⇧ F Find in Files⌘ ⇧ G Git⌘ ⇧ D Debug⌘ ⇧ A Extensions⌘ b Toggle Side Bar⌘ j Toggle Panel^ ⌥ q Toggle TerminalEditor Group⌘ \ Split Editor⌘ ⌥ 1 Toggle Editor Group Layout⌘ k, 1~3 Switch to Editor Group 1~3VimH Prev EditorL Next EditorY Copy to EOL (End of Line)zh Mv Editor Lfzl Mv Editor RgSelection⌘ d Expand Selection to Word⌘ ⇧ L Split into LinesFind &amp; ReplaceAs same as Sublime TextSublime TextFind &amp; Replace⌘ f Find⌥ ↩ Find All⌘ ⌥ f Replace⌘ ⌥ e Replace one by one^ ⌥ ↩ Replace All⌘ ⌥ r Toggle Regular Expression⌘ ⌥ r Toggle Case SensitiveSelection⌘ d Expand Selection to Word^ ⇧ M Expand Selection to Brackets⌘ ⇧ L Split into LinesBookmarks⌘ F2 Toggle BookmarkF2 Next Bookmark⇧ F2 Prev Bookmark⌘ ⇧ F2 Clear All BookmarksLayout⌘ ⌥ 1~4 1~4 Columns⌘ ⌥ 5 Grid⌘ ⌥ ⇧ 2~3 2~3 RowsCommand Palette…⌘ p Quick Open File⌘ ⇧ P Command Palette…⌘ ⇧ C Copy File Path^ s Trim Trailing WhitespaceCharlesProxy⌘ r [ Start | Stop ] RecordingSession⌘ ⌫ Clear⌘ o Open⌘ n New⌘ s Save Request⌘ ⇧ s Save As …View⌘ 1 Overview⌘ 2 Request⌘ 3 Response⌘ 0 Sequence⌘ 9 StructureTools⌘ ⇧ R Repeat⌘ ⇧ D DNS Spoofing Settings custom⌘ ⌥ m Map Remote⌘ m Compose ( Edit )⌘ ⇧ M Compose NewScript Editor⌘ ⇧ O Open Dictionary⌘ r Run the script⌘ . Stop the scriptCLItmuxMore details in Official Docs.^ q Prefix Key ( aka Pf )The description Pf, * implies that tap Pf at first and then tap the key *.Pf, ⇧ ? List KeysPf, d Detach ClientPf, c New WindowPf, \ Split Window HorizontallyPf, - Split Window VerticallyPf, ^ y Resize Pane LfPf, ^ u Resize Pane DnPf, ^ i Resize Pane UpPf, ^ o Resize Pane RgPf, h Select Lf PanePf, j Select Dn PanePf, k Select Up PanePf, l Select Rg PanePf, ↑ Maximize Current Pane in New WindowPf, ↓ Put Current Pane back to its Parent WindowPf, [ Use Vim-like keys to copy str at Copy ModeIn Copy Mode:v Begin Selectiony Copy Selectionu Copy Selection &amp; Exit Copy Mode⇧ L Copy Line ( &amp; Exit Copy Mode )VimOnly list the useful keys that I’m unfamiliar with here.Mv Cursor^ o | ^ i [ Prev | Next ] Cursor Pos{ | } [ Prev | Next ] Blank Linew | ⇧ W Head of Next [ Word / Str ]e | ⇧ E Tail of Next [ Word / Str ]b | ⇧ B Head of Prev [ Word / Str ]ge | gE Tail of Prev [ Word / Str ]; Repeat the last manipulation about f t ⇧ F ⇧ T0 Head of Line^ = ⇧ 6 Head of Line ( Non-Whitespace )$ = ⇧ 4 End of LineSelect Rangeciw Del Wordcaw Del Word including the Following Spaces 凵dw Del until Head of Next Wordde Del to End of Cur Wordci* Select &amp; Manipulate the string surrounded by *.ca* Select &amp; Manipulate the string surrounded by * including *.Column Edit ModeExample:In normal mode ^ v then select a block area⇧ I then type some string to insert⎋, ⎋ ( Twice ) to apply the insertion at each line heading of the selected block areaSearch &amp; Replace:%s/search_str/replace_str/gci: switch to Command Mode% find each occurence of search_strs replace operationg replace globallyc ask for confirmationi case insensitive , I case sensitive:&#39;&lt;,&#39;&gt;s/foo/bar/g&#39;&lt;,&#39;&gt; replace within a visual selection (when compiled with +visual):5,12$/foo/bar/g5 , 12 start from line 5 to the line 12:.,$/foo/bar/g. , $ start from the current line to the last line:.,+2s/foo/bar/g. , +2 start from the current line to the next two lines:&#39;a,&#39;bs/foo/bar/g&#39;a , &#39;b start from the mark a to the mark b:g/^baz/s/foo/bar/gChange each ‘foo’ to ‘bar’ in each line starting with ‘baz’Ref : Search and replace &amp; Vim 字符串替换及小技巧Command. Repeat CommandCp⇧ Y Copy from the cursor to the end of lineDelx Del Char Forward ⌦⇧ X Del Char Backward ⌫s Del Char Forward &amp; then Insert⇧ S Del Current Line &amp; then Insert⇧ C Del to End of Line &amp; then Insert⇧ D Del to End of LineExchangexp Exchange the Current Char and the Next Charddp Exchange the Current Line and the Next LineLower or Upper Case⇧ ~ Toggle Case &amp; Mv Cursor to Next charu to Lowercase⇧ U to UppercaseIncrease or Decrease NumIn Normal Mode:^ a Increase Num^ x Decrease NumMacroq a~z|A~Z Start Recording Macro marked as a~z|A~Zq Stop Recording@ a~z|A~Z Play Macro marked as a~z|A~Z@@ Repeat Macro that you last usedSave &amp; Quit⇧ ZZ Save &amp; Quit⇧ ZQ Quit without SavingCTags ( plugin )^ ] Find Declaration^ t Back from DeclarationMimic Emacs in Insert Mode^ b = ←^ f = →^ p = ↑^ n = ↓^ a = Home^ e = End^ k Del to End of Line^ u Del to Head of Line^ t Exchange Chars ( Before &amp; After Cursor )Tripple h/j/k/l to Normal Modehhh | jjj | kkk | lll = ⎋I used to use the Vim Distribution spf13-vim.Vim Cheat Sheet - ImageMore details in Official Docs.TODO: I will write another article for Vim and will move the content above about Vim to it._Zsh^ v Edit Command Line in VimEmacs Mode^ a Mv Cursor to Head of Line^ e Mv Cursor to End of Line^ w Del Word^ k Del to End of Line^ u Del Line^ p = ↑ Prev | Up^ n = ↓ Next | Dn^ f Mv Cursor Rg ( I use Fn l instead. )^ b Mv Cursor Lf ( I use Fn h instead. )^ h Del Backward ⌫ ( I used to use ⌫. )^ d Del Forward ⌦ ( seldom used )^ l Clear ScreenExtra^ _ Undo^ y Yank⎋, f Forward Word⎋, b Backward Word⎋, h Run Help for current Cmd⎋, &#39; Quote Line⎋, q Push Line⎋, g Get Line^ x, a Expand Alias^ x, ^ v Vi Cmd Mode^ x, ^ e Edit Command Line in Vim^ x, ^ b Vi Macth BracketAliases.zshrcdirgittmuxvi-modeoh-my-zsh &nbsp;&amp;&nbsp; my forkMore details in Official Docs.Other Tools2DoI don’t want to list all its shortcuts, as there are so many…⌘ s SyncView⌘ 0 Inbox⌘ 1 All⌘ 2 Today⌘ 3 Starred⌘ 4 Scheduled⌘ 5 Done⌘ ↑ Prev List⌘ ↓ Next List⌘ ⌥ ↑|↓ [ Collapse | Expand ] All Projects⌘ ⇧ ↑|↓ [ Collapse | Expand ] All List GroupsEdit0 ~ 3 Priority : None | Low | Medium | Highs Star^ s Unstard Due Datee Due Timek Schedule ( Start Date )t Start Today^ t Due Todayy Start Yesterday⌘ / Dates⌘ e Notes⌘ ^ ⇧ 1 Convert to a Task⌘ ^ ⇧ 2 Convert to a Project⌘ ^ ⇧ 3 Convert to a Checklist⌘ l Move to another listMindNodeFile⌥ ↩ New Mind Map⌥ → Next Mind Map⌥ ← Prev Mind MapNew↩ Append New Sibling⇧ ↩ Prepend New Sibling⇥ New Child⇧ ⇥ New ParentEdit⌘ ↩ Edit Title ( Current )⌘ ⇧ K Note Popover⌘ ⇧ T Add / Rm Task ( Check Box )⌘ ⇧ U Toggle Task⌘ k Add Link⌘ l Add Connection ( to Another Node )Move⌘ ↑ Move Above Sibling⌘ ↓ Move Below Sibling⌘ ⇧ D Detach NodeFold⌘ ⌥ ← Fold Node⌘ ⌥ → Unfold Node⌘ ⌥ ↑ Fold All Nodes⌘ ⌥ ↓ Unfold All NodesSelect⌘ ⌥ a All SubnodesEvernoteNote⌘ ^ s SyncEdit⌘ ⇧ H Insert Horizontal Rule⌘ ⇧ T Insert To-DoAfter Selection, then input:⇥ Increase Indent⇧ ⇥ Decrease Indent⌘ ^ c Code Block⌘ ^ k Strikethrough⌘ k Add Link⌘ ⇧ K Rm Link⌘ ⇧ F Simplify ( Rm ) Formatting⌘ ⇧ V Copy and Match Style⌘ ⇧ O Toggle Numbered List ( Ordered )⌘ ⇧ U Toggle Bulleted List ( Unordered )Input*, 凵 → Bulleted List1., 凵 → Numbered ListIn a new line, input - 3 times, ↩- insert Horizontal RuleIn a new line, input ` 3 times, ↩ - insert Code QuoteWeb ClipperActivate^ ` Open Clip Mode⎋ ExitAfter activation⇧ A All Main Text⇧ C Main Text without Advertisement⇧ F Full Web Page⇧ B Clip as a Bookmark⇧ M Capture↑ Extend Selection↓ Shrink Selection↩ SaveFirefoxCommon⌘ l Edit Address Bar⌘ j Downloads⌘ b Bookmarks ( Badly Use )⌘ ⇧ B Manage Bookmarks⌘ ⇧ H Toggle History⌘ ⇧ A ExtensionsDevelopment⌘ ⌥ i Inspect Elements⌘ u Page Source CodeVimFXIt is a Vim-Emulator extension in Firefox.Inputc Input in Address Bari Input in First Input BoxLinkf Open Link in Current TabF Open Link in New Tab^ f Open Links in New TabsC Copy URL of Current Tab to ClipboardHint ( After f | F and the link )⌫ Delete the Last Hint Character凵 | ⇧ 凵 Switch Hint LayoutTabOpen Tabt New at the Last of TabsT New at the Rg of Cur TabS Duplicatev Open URL in Clipboard in Current TabV Open URL in Clipboard in New TabSwitch Tabw to Preve to Next0 = ! = 1 = ) to First4 = $ to Last⇧ 6 to First Unpined TopMove TabW to LfE to RgClose Tabx Close Current TabRegret OpX Reopen Last Closed Tab^ x List of Last Closed Tabs of Tabs^ p Pin / UnpinScrollVerticalgg to TopG = ge to Btmj = 凵 Dn a Half Pagek = ⇧ 凵 Up a Half Paged Dn a Whole Pageq Up a Whole PageHorizontalh Lfl RgSpecified Posm, a~z Mark the Page Pos represented by ‘a~z’`, a~z = &#39;, z~z to the Mark represented by ‘a~z’Navigatez Backwardb Forward[ Prev Page] Next PagegH Cur Tab Visit History MenuLoadr RefreshR Refresh ( including Cache )Find/ Finda/ Find Alln Next MatchN Prev MatchVisual^ c Copy Element Text^ i Enter Visual Mode &amp; Put Cursor at Head of Element^ s Enter Visual Mode &amp; Select Element Text^ n Exit Visual Mode^ v Select Focus PointVisual Modev Start / Cancel Selectiono Switch Cursor between Head and End of Selectiony Copy Selection &amp; Exit Visual Modeh ← Lfj ↓ Dnk ↑ Upl → Rg^ a Mv to Head of the line^ e Mv to End of the Linew Mv to Head of Next Wordb Mv to Head of Prev WordOthersQ Click Elements of BrowserI Enter Ignore Mode ( Ignore All VimFX Shortcuts )^ n Exit Ignore Mode ( Back to Normal Mode )gB Edit VimFX Blacklist? Help Tips⎋ | ^ [ CancelNeteaseMusic凵 Play | Pause⌘ → Next⌘ ← Prev⌘ ↑ Volume Up⌘ ↓ Volume DownShadowsocksX-NG^ ⌥ ⇧ P Toggle Shadowsocks On / Off^ ⌥ p Toggle Proxy Mode: Auto PAC / Global]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见 2015]]></title>
    <url>%2Fthink%2Fbye2015%2F</url>
    <content type="text"><![CDATA[始写于 2015-12-26量化2015全年时间使用情况英语（App扇贝）记账（App随手记）阅读（App多看）近况上半年，做毕设，写论文，顺利毕业。再也不用顾忌成绩，与同学朋友一起痛快地生活，每晚跑一圈大学城的内环路，几乎每天流窜于各高校间踢毽球，不时熬夜开黑打游戏，经常聚会吃饭谈天，度过了最后的校园时光。更常回家了，花更多时间呆在家里，陪家人一起吃饭生活，或许以后就只有逢年过节才有这样的机会了。下半年，开始北漂生涯，来到新浪微博的移动端的对外接口部门工作。---与其它大学同专业的同学相比，我的工作相对清闲，但习惯每天都回公司呆着。毕竟写字楼有空气净化系统，空气质量有保证，而且懒得做饭，呆中关村附近便于觅食。在每天早晚的班车上用扇贝英语的App背单词短语、练听力；中午打一小时羽毛球，胃口自然好，当然要下馆子吃好的；晚上回到公寓健身半到一小时；晚餐节制饮食，一般只吃水果、鸡蛋（或三明治）加牛奶。经常折腾这个技术博客，虽然没什么人看，但却已然成为我现阶段的精神寄托。在北京找到了毽球组织了~ 庆幸还能偶尔有机会继续玩毽球。进步一直在暗地里跟别人比，不时会被别人获得的成绩所激发，心血来潮地拼命努力上一阵子，然后低潮…… 总想改掉坏的习惯，过程却常充满反复。一开始打算有节制地娱乐，可真要开始了玩游戏、煲日剧、美剧、动画、漫画，却就收不住，玩疯了，晚睡早起，废寝忘食，不想工作学习运动……现在经常劝自己不要对自身自制力抱有不切实际的幻想。尽量多做正事的最好办法大概还是“远离诱惑”。---虽然偶尔会过分沉溺玩乐，但现在会让自己多运动，不时听歌放松；节制饮食后，吃东西也会更津津有味。 可晚睡的坏习惯就反反复复。唉，知道“这些事情都可以明天做的，为何要牺牲睡眠去做这些事呢！”，可以依然做不好。现在少了些对无谓的事情作“尽善尽美”的苛求，毕竟以我的资质也苛求不来。常常提醒自己，已经后悔了的事情就尽快放下，去做下一件事情并做好。毕竟能做好少数几件事就很不容易了。看开一直在不紧不慢地努力着，当前的努力程度还比不上太多的人。一直也在暗地里跟别人比，与他们相比，我太低微了。同行业大学同学不少去了BAT等一流IT企业，高中同学太多继续深造的了，到北美、德国、日本、北京等各地顶尖的学校，不乏颜好还家境优渥之辈，已经看不清其中一些还在飞奔着的遥远背影。---以前一直都靠着跟他们比，来勉强让自己不时会奋起一阵子。最近才看开了：即使努力，也很可能永远比不上他们了。但是在这过程中，我却实实在在地活得更好了。相对值上，我永远都追不上他们，但是自己的绝对值会越来越高。所以，保持住自己前进的节奏，一切都会变得更好的。---能有余钱多下馆子，有闲交到更友好有趣的朋友，买自己想买的东西时不太顾忌价钱了，去自己想去的任何地方去旅行，就算不能完全做到，也能实实在在地活着更舒心。现在多少从“这山还看那山高”的逻辑中稍微跳脱了出来，过得宽心了些。时间时间管理挺有意思的，就像《游戏改变世界》一书所说，游戏对玩家即刻的付出产生的及时的反馈，如经验值、等级、属性、金钱、装备、排名、地位，令人更容易产生兴奋感，不断产生正反馈，不像现实生活，努力却很难看到成果。---我的时间管理，就是把自己的生活都量化并记录下来。每次看到自己的管理记录，就能感觉到每天都有所进步，并且还想着再接再励，创造新纪录，比如，今天玩得很尽兴，吃得很好，运动的汗流得舒爽，学习时间更长了，效率更高了，学习了新知识技能，提高了熟练度，达成了新成就。于是更容易坚持下来。英语以前从来没想过要出国。挣到钱了，出国旅游体验生活不久行了，为什么非得异国他乡那么苦呢？我很早就这样想了，本来就对英语没兴趣，这样就更没有紧迫感，所以一直对英语学习不以为意。但是人是会互相影响的，高中同学一个接一个出国深造、工作或移民，后来数量越来越多，最后实在太多了。管他是不是从众呢，反正我渐渐地也产生了一种感觉：总有一天，我也要出国工作、深造，或者体验异国他乡的生活。英语确实是一个很重要的能力。虽说我觉得软件工程师的思维也是要时日熏陶的，但编程本身并不难学。反而是数学、英语这些深入内化的技艺，能让人有思维和能力上的大跨越。越难掌握，越是彰显出价值，现在确实不容易补上了。还是保留这么一个念想吧，或许某一天它能开花结果。阅读纸上得来终觉浅，绝知此事要躬行。看了不少书和文章，听了、看了许多演讲、节目，“知道很多道理，却活不好这一生。”其实，只有做事，做事，还有做事，才能实现愿望，对吧？这个世界只关心你能给予什么。…我们用「我能做到什么」来判断和定位自己，而别人用「你已经做过什么」来判断和定位你。实用主义吾生有涯。想学的知识太多，想去的地方太多，想吃的美食太多，想看的书和文章、动漫、电视剧太多，想享受的乐趣无穷无尽…… 少说、少听、少读，做事，做事，做事。这是给自己的建议。极简主义极简主义还是不够用。目标、生活再怎么精简，即使集中精力就只想做好少数几个目标，仍难免遭遇不尽人意的结果，还是得习惯与“不如意”共处。完美显然是不存在的，过分追求完美当然是有害的，但脑内还是常冒出“可以做到”的幻觉…… “习惯将就，习惯放弃，凡事适可而止”，只能靠多点这么劝劝自己来治我的妄想症了。反正，“一旦接受这个设定”，感觉又好了些。---大概“暴露疗法”才是有效的，要过一下永远忙不完的生活：被迫排优先级，做取舍，但结果仍然常常令人糟心、崩溃……经历多了，自然就好了。存着很多好东西呢，没来得及细看，没来得及好好体验，都不想错过。大概把它们放着就好，大浪淘沙，放着放着，没价值、不在意的东西你自然会欣然放下，值得珍视的，还会留在那里。健康身体是革命的本钱，所以才要每天都坚持运动。可惜我优先级搞错了，总是晚睡早起，饮食不当。想起今天还没运动，23点我可能还去跑步、健身，却压缩了睡觉时间；为了运动，常常会打乱进食的时间，暴食或少食；不时又因为吃夜宵延迟了睡觉。觉得优先级是这样的才对：睡眠 &gt; 饮食 &gt; 运动。希望我的执行力足够支撑我在以后的日子里，能始终作出正确的选择。花钱不买没必要的东西，或许偶尔借别人的就能解决。常用的东西，就买最好的，充分利用它。该省的省，该花的都花；然后才是最重要的一步：“有智慧分辨两者的不同”…… = =---假如一个东西很好用但要收费；只要不是太贵，都会去买。许多工具App，例如扇贝英语，买几个付费的功能，可能一下子花个两三百不在话下。要是玩手游、买点卡、网吧钱，不也差不那个钱，怎么这时候就不舍得了？iPhone是很好的投资，用的舒心，有很多高效好用的App，真是恨为什么当年为什么不早点买。毕竟事在人为，若是有人把它当作玩物，只是用法不对，不是工具的错。MBPr更是程序员标配。有个朋友花大价钱买了它，非要都找免费的或者破解的App用，几乎不想再额外再花钱买App了。我说，没啥，花着花着会习惯的。他说怕是习惯了，就停不下来了就…… 我只能说：好吧。（当然现在还穷，虽然已经买了不少正版，但盗版也没少用……）---每天打羽毛球，场地费、买球、买拍、买水，每月得花掉￥400，这也很费钱呢。但药费和医疗保险难道不更费钱？主动“这辆公交太挤了，上不了，或许下一辆是空车？”其实何苦迷信下一辆是空车。“等这车的人都累积得这么多了，大概车很快就到了吧；等了5分钟，10分钟，半小时… 等了那么久还没到，但大概也快了吧？”虽然上了直达的公交能很快到达目的地，却不知道要多久才能等到；坐地铁可能更久，也更贵，还得多走很长一段路。我宁可选择地铁。比起去依赖无可把握的外物，我更相信可靠但可能麻烦的路径，更信赖自己的双腿，多迈几步，走快一点，不就到目的地了吗？听音乐小学初中开始听音乐，喜欢的基本是有歌词的，特别是情歌，在那个情窦初开的年纪毕竟难免。习惯边听边唱，竟然发现自己唱女歌不错…（虽然后来高中毁嗓了）高中了，容易精神颓废、郁闷，于是开始喜欢听激昂的摇滚、电子，或者其它吵闹的歌曲去振奋精神，还很爱动漫歌曲。边听边唱，确实影响了这一时期晚上的学习效率。大学了，在宿舍生活再也不方便边听边唱了，而且有歌词的歌难免影响专注，于是“无时无刻都在听音乐”的日子慢慢离我而去。认识了一个音乐学院的同学，间接给我传了4GB的交响、小提琴曲，偶尔会浸淫其中。工作了，听激昂的音乐没一两小时，就感觉很累；听一般的流行音乐也受不了了，听了半天也受不了了；慢慢习惯了听小提琴、钢琴、舞曲、交响乐，虽然还说不出个所以然来，但是我的豆瓣FM播放却早已被它们占据。独立今年的股市大起大落，年中5000点后狂泻，损失难免惨重。某次谈话家人竟说：本来家里条件还好，结果搞成这样，对不起……---自小学后，家里条件好了起来，我已经过了十年只有少年闲愁的快乐生活了，现在工作了，经济独立。家里说到要每个月要打多少钱回去补贴家用这点事，怎么能推辞。作为俗人一个，当然也会想买Apple的最新产品，不时盘算着要不要跟家里人说“能不能少打点钱”这种自私的话，甚是惭愧，不过忍住了。我其实我是个开不起玩笑、放不下节操的闷骚男，天生懒惰，容易颓废，有点自私，爱慕虚荣，比较敏感、略显孤僻；在别人看来，我大概太中性了，不够“男子气概”。I am not the one. I am not special. I am nothing but a man.发愿发个只有自己知道的大愿，希望某年某月某日还能自豪地记得回到这里给自己还愿。祝 2016 一切顺利。]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客导航]]></title>
    <url>%2Fbookmarks%2F</url>
    <content type="text"><![CDATA[欢迎来到博客 IceHe.me！RSS 订阅 默认索引：归档（ 时间序 ）分类（ Hexo 自动生成 ）下文为自定义的索引。阅读量前 20C++C++ Primer 第五版C++ 面试宝典C++ 编程规范Effective C++笔记 1 , 笔记 2 , 笔记 3 , 笔记 4C++ 宏定义与位操作Cmd. 命令行Git 总结 - 常用操作Read 阅读积累技术阅读收藏文字阅读收藏最喜爱的 - 影视 &amp; ACGMN 定义博客导航 当前页面Mac利器 - 软硬件推荐Mac 效率指南Mac 快捷键AppleScriptAppleScript 快速入门用 AppleScript 操作 Evernote / macOSASM 汇编准备：在win7 64位系统上使用 debug.exe「1」寄存器、CS、IP、CPU、内存「2」大小端、寄存器、DS、[addr]、栈「3」伪指令、编译、连接、调试，[BX]、loop、段前缀、内存空间「4」栈、数据、代码、栈的段、多段程序，大小写转换、寻址、SI、DI「5」bx、si、di、bp、寻址、除法、dd、dup、结构化数据「6」转移、offset、jmp、jcxz、loop、dec、超界检测「7」call、ret、mul、显示字符串（指定位置、颜色）、除法溢出、数值显示「7+」课程设计：公司数据以指定格式在屏幕上显示「8」 标志寄存器，adc、sbb、cmp，检测比较结果的条件转移指令，DF标识和串传送指令，及相关实验「9」 内中断、中断处理程序、中断向量表，安装、设置中断向量「10」 int 指令，中断例程，及相关实验「11」 端口的读写，in、out、shl、shr，访问 CMOS RAM。「12」 外中断，接口芯片和端口，可屏蔽/不可屏蔽中断，PC机键盘的处理过程，及相关实验「13」 直接定址表，数据、地址标号。在其它段中，计算sin(x)，及相关实验「14」 用 BIOS 进行键盘输入和磁盘读写，及相关实验「15」 附录内容：汇编编译器对jmp的处理，地址计数器（AC），处理伪操作指令，栈传递参数，无溢出除法…Batch 批处理Batch 批处理指令Batch 批处理中的特殊符号DOS 常用指令DOS 环境变量JavaScript某次 JavaScript 代码优化过程PythonPython3 快速入门Web搭建个人博客折腾个人博客 New实现网站的打赏功能Think 思考2017 春2016 冬2016 秋2016 春夏再见 2015生活指南Time Mgt. 时间管理时间管理日志时间管理日志说明Who am I 我是谁CV 简历IceHe’s CV回忆旧博索引打赏博主一些想法为什么写我可以用 Evernote「记录」，但是难以「分享」；用 GitHub 可以同时做到两者，但是展示效果不佳；所以做了这个博客。只可惜我不够懂「前端、设计」，只能在别人完备的方案上进行自定义的修改。比起「悦人」，这里更是「悦己」的场所。这个博客首先是为了「记录、总结」 自己的知识和见解，其次才是「分享、展示」。当然，我希望有更多的访客，但更在意这片小天地是否每一处都符合自己的心意。因此，我常常在完善旧文章，很少发布新文章。虽然文章少，但通常都很长。写什么不追赶容易过时的技术软件技术日新月异，其中大多数不过昙花一现，很快就会被层出不穷的优秀后来者所取代。当然还是有许多历久弥新的技术、思想，以及软件工程师的基本功、素养，亟待掌握，这些才值得总结记录。少记叙技术细节再长久的技术也终有过时的一天，不值得过多地记叙其中技术细节。从中以小见大，得到启发，产生自己的见解 —— 这些才值得记叙。例如，写短平快、不成体系的技术入门文章、笔记，就价值不大，不过是在对外宣示自己在努力“学习”（倒腾新玩意）罢了。（其实现在还有写这种文章，得狠狠反省）少抒情，多思考已经过了矫情的年纪，不再是少年，没有那么多闲愁值得抒发，不要「为赋新词强说愁」。比起技术，还有更值得记叙的事情：什么时候，什么背景下，我遇到了什么事，作出怎样的决定，为什么这么做，结果怎样，后续发展又怎样……后来我我是怎么想的，有什么感受，得出了什么道理，如果可以重新选择，我会怎么做……其中决定的理由、做事的方法、个人的情绪等等等等…… 都是值得记叙的。不断地记录，为的是拥有依据，不断用于思考、总结、反省、复习，积累经验，螺旋式上升，变得更理性、成熟，更了解自己，更坦诚面对自己，更少地重蹈覆辙。没错「听过很多道理，依然过不好这一生」。因为每个人都是不一样的，不同的经历、性格、观念，没有亲历过的东西，就不会有深刻的体会，自然不容易明白其中的道理，更难说践行了。「纸上得来终觉浅，绝知此事要躬行」。记于 2017-01-01强迫症生活本来就是一团乱麻，「完美」只是镜花水月，盲目接近它和追求它，均是徒劳，甚至可以说是一出悲剧，就如西西弗斯的滚石。追求整洁、秩序、完满，还不如由它杂乱不堪来得省心。我就是一个典型的「强迫症、细节控」，可是不想再继续这样下去了。人生太短暂了，何不及时行乐去享受乐趣，或是好好做事追寻人生的意义。不过，我还是想留下这个博客 —— 这一片隐秘天地，让我自己一个人，能够静静地跟自己说说话。记于 2017-03-15好友链接Jan Fan - Pythoner, ML &amp; NLP, TencentSF Zhou - ACMer, MicrosoftShiwey Yan - Game Developer, QQ 飞车, TencentJohnson - Pythoner, Web, Sina]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利器 - 软硬件推荐]]></title>
    <url>%2Ftools%2F</url>
    <content type="text"><![CDATA[君子生非异也，善假于物也。荀子说明主要介绍 macOS、iOS 的 Apps（下文 Apple 指代 macOS + iOS）；只简单提及 Windows。适合自己的工具，才是最好的工具。所以本文仅供参考，自行尝试才是正道。原则「常用」的工具才值得折腾，不常用的工具凑合着用就行了。选择工具，最重要的是「实用」，「美观」次之，「价格」不要太贵就行。稳定：不能引起系统崩溃，起码提升效率的收益得超过崩溃重启的损失。简洁易用：满足实际的需求即可，不需要花哨、多余的功能。参考 KISS 和 SR 原则（Keep it simple stupid &amp; single responsibility）。设置项齐全：可以根据自身习惯调整 App，让它用起来更顺手、省心。比如，设置好 App 各常用功能的快捷键，以便调用；或设置好自动运行的条件，以后就不用再费心了。部分参考少数派 - 高质量 App 推荐媒体，关于 iOS、Mac、硬件。利器 - 创造者和他们的工具 以及使用的方式和原则。Best App - List in GitHubmacOS 有哪些值得装的小软件？MacTips - Mac 使用经验和技巧。…相关文章 :《 Mac Efficiency 效率指北 》《 Mac Shortcuts 快捷键 》字体格式的含义删除线 标识的一定是我现在不用的 Apps。粗体 标识的通常是在用的 Apps。同时有 删除线和粗体 标识的 Apps，我现在不用但值得一试。软件常用网络Shawdowsocks Ladder首选的 PC 番羽土啬方案：Shadowsocks 服务 + Mac 的 ShadowsocksX-NG + 浏览器的 proxy 类插件：如 FireFox 的 FoxyProxy，Chrome 的 SwitchyOmega。ShadowsocksX、ShadowsocksX-NG 等可以用更强大的 Surge 替换。备选方案：VPN + CHNRoute + Dnsmasq。Firefox Favorite配合 VimFX 拓展，可在浏览器内 全局使用 Vim 键位 浏览网页、操作浏览器！键盘党神器。不过 Firefox 冷启动较慢，界面不够 Safari、Chrome 漂亮，偶然会遇到一些奇怪的 bug。毕竟工具是拿来用的，最重要的是高效。Chrome Most Usual用 Inspect Element、Postman 等 Develop Tools 做 Web 开发、调试，远比 Firefox 顺手。Chrome 很好，但更耗电，影响到了 Mac 的续航；更重要的是类似 VimFX 的 Vimium、cVim 等 Extensions 无法在页面未加载完毕的情况下使用 Vim 键位，不够极致，所以我更倾向于使用 Firefox + VimFX。常用2Do FavoriteGTD 类事务管理。功能齐全、好用，用法可简可繁。快捷键完备，深得我这个键盘党的喜爱！一开始用 Doit.im 入门 GTD，虽然它的 Web 端的操作很极致高效，可是客户端做得不尽人意。然后发现自己的生活比较规律，觉得 Apple 自带的 Calendar 够用。后来又改用免费版 Wunderlist，捉襟见肘的功能勉强满足个人需求，胜在简洁易用。现在用 2Do。推荐使用 iCloud Reminders 的 CalDAV 同步方式（支持 2Do 绝大部分特性，足以满足我的需求）；Dropbox 的同步方式虽然可以支持 2Do 的所有特性，可是需要翻墙才能同步数据，iPhone 需要长期开着 VPN 略显麻烦。所以为了稳定和省心，选择了前一种同步方式。MindNode Favorite思维导图，归纳总结笔记。操作简便易上手，轻巧稳定OS。以前我也不待见思维导图。可是有一天你会终于发现：学习、归纳、总结、复习的时候，Markdown 线性的列表用起来太长了，要不断缩进以添加内容，组织内容真的远不如思维导图灵活！Evernote云笔记，第二大脑（知识管理）。好记性不如烂笔头，而如今知识更新之快，纸笔已跟不上，于是笔记软件大放异彩。云端存储同步笔记（同时定期备份整个硬盘），有备份就不怕丢；便于检索，甚至搜索图片中的文字。总是死记硬背没有出路，不能被检索的知识毫无意义。现在觉得值得离线记录的东西不多了，用 Google 搜索更便捷，而且还能获得更新更好的资料；值得沉淀的知识不断更新记录在博客就够了。现在我主要将它作为 Read It Later 类 App 来用。使用方式：剪藏、微博 @我的印象笔记、微信分享给 我的印象笔记、邮件收藏 等。Other choices:有道云笔记：Evernote 迁移到其它平台比较简单，但 有道云笔记 导出的笔记格式经过加密、无法通用，很难迁移到别的平台，所以不推荐使用为知笔记、Leanote …NotesApple 自带的轻量级笔记应用。用于收集灵感和想法，做书摘、读书笔记和日记。因为它启动迅速，使用便捷稳定，所以更常使用它而非 Evernote。1Password帐号密码管理，以及私人信息的加密存储。用一（两）个主密码管理所有其它密码。可生成随机密码，可记录登录网站时用的帐号密码，可自动填写表单登录网站。以前一直用不惯，觉得用浏览器自带的自动登录和 iCloud 的 KeyChain Access 来记录管理帐号和密码足矣，可是不便于保存一些私人信息。工作之后，经济独立，更加注意保护个人隐私和财产安全了，要管理的私人信息多而杂乱，所以不得不借助专用的工具。Other choices :KeyChain Access : Default &amp; convenient on macOS &amp; iOS.Dashlane : Excellent but expensive!LastPass : Good enough &amp; free to use.双拼输入方案 Favorite高效，易学！比五笔容易掌握得多，输入效率提升显著，习得的性价比高。来试试双拼吧。《做少数派中的少数派：双拼输入快速入门》《选择输入法的哲学：兼论双拼的优缺点》命令行代码管理Git Essential分布式代码版本管理系统（必学）。编辑器Vim God-like编辑器之神（ Emacs 则是神的编辑器 ）。服务器通常是 nix 系统，vi 是标配，而 Emacs 不常有。服务端开发和运维人员经常要在远程服务器编辑文本，遂 vi* 是必备技能！大的项目还是使用专用 IDE 进行编写更便捷靠谱。IDE 装个 plugin 也能以 Vim 的方式高效地操作，Vim 通用的键位可以让你少记很多必要的 IDE 快捷键。Vim vs. Emacs! &nbsp;What are the main differences between Vim and Emacs?__》Others :《一年成为Emacs高手（像神一样使用编辑器）》spf13-vim Essential一整套 Vim 配置方案。比起漫无休止地折腾配置，不如遵从实用主义：站在巨人的肩膀上，直接使用久经考验的的配置方案。后来发现，根本用不上其中的很多功能，而且高配的 MBP 用起来竟然卡！如果只将 Vim 作为轻量的文本编辑器，其实用熟之后，根据个人习惯在 .vimrc 写好的基本设置就够了。ShellZsh Powerful比 Bash 更强大、便捷、高效的 Shell！配置 Zsh 比较复杂，可以使用 oh-my-zsh 等成熟的配置方案。Fish ( a shell for the 90s 😂 ) 虽然很好，但存在兼容性问题，有些 Bash 的指令需要改写才能运行在 Fish 上。Ref : Comparison of Command Shells - Wikipediaoh-my-zsh Efficient管理 Zsh 配置的开源框架，预打包了相关的主题、插件、配置。配置过程傻瓜化，一条安装指令就能让你畅快地享受 Zsh 的强大与高效！tmux Powerful终端多路复用软件，即命令行中的 「桌面」、「分屏工具」。允许一个用户在一个终端窗口或一个远程终端会话中，使用多个终端会话。包管理Homebrew BestmacOS 的包管理器。brew 就如 agt-get 之于 Ubuntu，yum 之于 RedHat、CentOS 的存在。Homebrew Cask Great安装、更新 macOS Apps 的命令行工具。用命令行的方式安装、更新 Mac Apps，其中还包括了许多第三方的 Apps。不用忍受 AppStore 缓慢的下载速度，也不必一一访问各个官网去下载第三方 Apps 了！重装 macOS 时可以用 brew cask install 命令组成的脚本便捷地安装必要的 Apps。dotfiles各路大神的 dotfiles 配置。（dotfiles 是什么？）其实并不需要那么多工具包，有需要再折腾才是正道。e.g. : YADR - Yet Another Dotfile Repo一个便捷的命令行配置方案，包括 Vim、Zsh、tmux、Git、RubyGems 以及 Alias 等各种配置。新手可以一试。软件开发常用PyCharm , PhpStorm Master PiecePython、PHP 的最佳 IDE！现阶段类型推导做得最好，稳定、少崩溃，功能完善，设置选项齐全。（我觉得）比 ZendStudio、Eclipse 之流好用多了。配合 IdeaVim 插件可用 Vim 键位编辑，可以少记许多执行类似操作的 IDE 快捷键。JetBrains 出品的其它 IDE： IntelliJ IDEA、WebStorm、RubyMine、CLion 等。iTerm2 BestmacOS 下的终端仿真机。是系统默认自带的 Terminal 的最佳替代 App。Dash To the point查阅 API 参考文档、管理代码片段的工具。功能单一却精准。我还是习惯去官网查看文档，毕竟在浏览器可以用我的 Vim 式快捷键进行操作。）编辑器其实可以完全用 Vim 来编辑文本文件（在终端中）。Sublime Text Fastest代码编辑器，我用其替代 TextEdit 作为默认的文本编辑器。Vintage 模式，可用 Vim 键位进行操作。冷启动快如闪电！VS Code Best发展至今，足以取代 Sublime Text 的优秀轻量级代码编辑器。内置 Git 管理、终端、调试框架，齐全、足量的优秀插件，配置选项完备，使用稳定顺手……开源，持续且活跃的开发，更不必说本身有微软过硬的技术实力背书。缺点：打开大文件的稳定性、速度和冷启动速度，不如 Sublime Text。Typora ElegantMarkdown 编辑器，所见即所得。国人制作，完全免费，支持 Mac、Windows！（除了写博文，我很少真的需要预览 Markdown 内容的实际显示效果，所以用一般编辑器即可。）网络Charles Best网络封包分析（抓包）工具。如 Fiddler 之于 Windows。主要用于「应用层」的分析。Wireshark Powerful网络封包分析工具。比 Charles 强大得多，但是也复杂得多。主要用于「网络层」的分析。（我的日常工作很少用得着。）Postman PowerfulAPIs 开发、测试、归档的辅助工具。Mac 的 HTTP 客户端。用于与 REST 服务交互，以助构建 API、HTTP 请求，检查来自服务器的响应。Others : PawLaunchRocket安装在 macOS 系统设置面板的 App，通过 launchd 管理各式 services。比使用命令行，更便于启动、终止 services 以及进行 root 授权。数据Squel Pro Free管理 MySQL 数据库的 GUI 工具。TransmitFTP 的 GUI 工具。（rsync 命令比 FTP 的效率高多了，用法也丰富。一般情况下用 netcat 命令传输文件就够了。）办公Adobe Acrobat Reader DC一般情况下，不使用额外的 PDF 阅读软件，Mac 系统自带的 Preview 就够用了。但在特殊情况下，需要用到 PDF 的一些高级特性，还是 Adobe 家的软件亲自处理更妥当，例如签证申请文件、合同、保密文件等。Parallel Desktop Best虚拟机软件。最适合用于安装 Windows。它将 Windows、Ubuntu 跟 macOS（几乎）无缝对接，使用流畅自然。（我现在完全脱离了 Windows 平台独占的软件，包括游戏，所以几乎用不着它。还有它的软件升级定价策略很不地道，跟重新买差别不大……）Others : Virtual Box（适合装 Linux），VMWare Fusion（没用过）快捷键Keyboard Maestro Geek, Best, Favorite!限制你的只有你的想象力！高度自定义的效率工具，难以一语道尽玄机。---替代用于 快速启动、切换 Apps 的 Manico Great、Contexts Simple。我是键盘党，以前用 Windows 时已经习惯用快捷键和鼠标手势迅速打开、切换程序，因此离不开这类工具。---替代用于 Apps 分屏 的 Moom Efficient, Best、Spectacle Simple。用快捷键等触发分屏操作，按需快速摆放 App 窗口（移动、缩放）。Moom 用久了我形成了固定的习惯，主要用全屏、左右各半、左右 3/5 和居中等少数几个布局，只需要设置几个快捷键来触发对应操作就够了。Ref : 《说说 Mac 分屏的事(2) - Moom 的10个技巧》---替代用于 用缩写加速文本输入 的 TextExpander Great、aText Simple。输入缩写时，会根据用户的设定模板来自动拓展输入的文本，以提升输入效率，特别是高频重复的词句。---替代用于 稳定便捷地切换同一 App 的多个子窗口 的 HyperSwitch Best。这类应用的出现，是因为在某些 Apps 下，无法用系统的 ⌘ ` 来切换其下的各个子窗口。用触摸板三指下滑的手势或快捷键触发 App Expose，可以显示当前应用的所有窗口，然后点击选择其中一个进行切换，但是不够快捷。---可以替代用于 剪贴板管理 的 ClipMenu Efficient、Paste Beauty。这类应用很多，Keyboard Maestro 在这方面还是做得不够好。Paste 颜值高，可是配置选项不多，不如 ClipMenu 定制性强。ClipMenu 短小精悍，显示紧凑（可能你会觉得丑），快捷键调用方便，响应迅速。所以，剪贴板方面我还是选用了更合我口味的专用 App ClipMenu。---甚至可以尝试用它 定制系统全局 Vim 快捷键，或者 配合 Keymo 用键盘控制鼠标 等。根据个人需求，用它来自动化、加速常用的操作 —— 可以编写控制流程，调用命令行、运行脚本，判断系统状态如网路、蓝牙、电源连接等…… 喜欢 DIY 还是亲自动手试试吧，Ref :《懒的前提是要足够高效： Mac 效率工具Keyboard Maestro 详解 - 少数派》。---Karabiner Geek, Best强大、稳定的键位修改功能，预定义了大量奇巧的修改方案。键盘党神器！可自定义快捷键去启动、切换 App，打开文件和网址，快速输入关键词跳转到网站的搜索页，甚至运行命令行和脚本（AppleScript 等）。发挥想象力，还能做到更多的事。例如，它也可以实现 Manico 的功能，不过得费些时间。当然除了「键位修改」其它繁杂的功能还是交给 Keyboard Maestro 之类的 App 来定制更省心。噩耗：macOS Sierra (10.12) 中关于键盘控制的底层架构大改，所以这代以后的 macOS 就不能使用 Karabiner 了。它的作者正在开发支持新版 macOS 的 Karabiner-Elements，然而工作量颇大，尚需时日才能实现大部分旧版的功能…… 所以，我为了 Karabiner 只能不升级系统继续使用 OS X EI Capitan。SeilKarabiner 的补充，主要修改 Caps Lock、 Esc、Shift、Ctrl、Option 等按键的键位。Karabiner Event-Viewer键盘码查询。不用查表，直接击键，即得出对应的键盘码和按键组合等。属于 Karabiner-Elements 附带的用于调试键位、快捷键组合的工具 App。Others : Key Codes系统加强Amphetamine防止 Mac 休眠。原因：Mac 每次休眠后都会重启软件，导致软件丢失部分上下文，于是我无法在完全一样的环境下持续工作，一定程度上打断了工作，降低了效率。休眠（Sleep）：硬盘休眠。屏幕休眠（Display Sleep）：即关闭屏幕，连屏幕保护程序（Screen Saver）也不运作。Others : 它比同类软件 Caffine、Owly 功能完备、好用；InsomniaX 没用过。Bartender 2 Clean Menubar收起或彻底隐藏毋需过多关注的菜单栏 App 图标。CheatSheet Tips, for Freshman快捷键快速提醒。长按 Command 键，显示当前程序的快捷键列表，方便快速入门 Mac 各处的快捷键。（新手专用）ClipMenu Efficient剪贴板管理。主要用于快速查询剪贴板的历史记录，并提取出需要的内容保存到当前的剪贴板中。支持 URL、纯文本、RTF、图片、文件等各种格式，包括剪贴历史的排序、内容的大小写转换、自定义文本的调用。Others : Paste 最好看！Copied（没用过）。HyperSwitch Best稳定切换同一 App 下各子窗口。HyperSwitcher 选择切换的窗口时，会显示各应用的缩略图。我用 Keyboard Maestro 来替代了它，因为我倾向于用更少的工具完成尽可能多的事，好用够用就行了。不过 HyperSwitcher 仍然是最佳选择，强烈推荐！Related : HyperDock窗口增强工具。光标停到 Dock 的 App 图标上，能快速预览该软件的所有窗口，点击切换到不同的窗口或桌面。还有快速调整窗口布局、大小、位置等的功能。用处还是不大，用 HyperSwitcher 切换子窗口时就能看到 App 下所有子窗口的预览图。Quick Look plugins增强 Finder 的文件预览（Preview）功能。在 Finder 浏览目录和文件时，选中文件，再按空格键，即可进行简单的预览。该插件提供各种类型文件的预览功能：快速预览各种格式的图片，包括 GIF；对各种不同编程语言的代码进行着色，便于查看… 详情查看其 GitHub 仓库 README.md 的说明。ShowyEdge Great输入法状态提示。显示一条样式可定制的色带在屏幕顶部，以提示正在使用什么输入法。在全屏使用 App 时，也能轻易区分输入法状态！就好像盲插 USB 接口可能要插三次才成功，感觉很糟糕。随时都能便捷地确认输入法所处的状态，可以减少多余的输入法切换操作和误输入后的回退操作。我输入英文只使用默认的「U.S.」input source，输入中文只使用「拼音输入法」，切换「中/英」输入只要直接切换输入法就好了。我不想只用「拼音输入法」，然后在一种输入法下进行中英输入切换。这时中英切换通常只需要用一个键 ⇧、^ 或 ⇪，看似操作很方便，但也容易「误操作」，使用大量使用快捷键时就很不便，特别是在用 Vim 的方式进行编辑时，误操作几率非常高！常用Time Machine RequiredmacOS 自带的系统备份、恢复软件。要有忧患意识，不要等硬盘坏了、Mac 丢了，才追悔莫及。Dictionary Great EnoughmacOS 系统自带的字典应用，足够好用。EuDic Free Free, Great欧路词典，Mac 上最好用的第三方词典。ShawdowsocksX LadderShadowsocksX 是在 Mac 上配合 Shadowsock 工作的软件。Numi Great系统默认计算器的替代方案。单位换算好用啊！例如，您输入左边的内容，就能得到右边的结果：Input 1 day in sec , print 86,400 s .Input 547 day in year , print 1 yr 6 mon. 2 day .IINA Player视频播放软件。比 MPlayerX、VLC 都好用！NeteaseMusic Joy网易云音乐，用音乐休闲放松，看评论找共鸣。Others : 由于音乐版权的原因，只能多下载几个 Apps，如 QQMuscic、Xiami 虾米。不常用连提及都没有价值的 Apps 在此就不一一列举了。放在这里的有一些公认很好的 Apps，但我不常用甚至觉得鸡肋，且看我的理由。效率Alfred 键盘党的神兵利器Spotlight 的增强版！关键字缩写的检索还是 Spotlight 精准；要用命令的话，也基本在终端中操作，没有 Alfred 之流的用武之地；要启动程序的话，有 Manico 的支持足矣。很多人把它说得神乎其神，其实我并不觉得有大用。看看操作流程：先输入一些字符，Alfred 智能检索猜出你要做的事，如打开程序、文本，或者运行脚本等；然后，选一个选项执行。我更喜欢敲快捷键「一步到位」执行要做的操作！ 例如，我借助 AppleScript、Python、Shell、Keyboard Maestro 和 Automator 等写好脚本、录制好一系列操作或设置控制流程，然后用快捷键激活它们就好了。真正常用的组合操作并不会很多。Others : LaunchBarBetterTouchTool为 Mac 的触摸板定制更多手势操作。iOS 版 App 还可以用来让 iPhone、iPad 设备化身为 Mac 的触摸板。现已是收费软件，但不贵。可是作为键盘党，自定义的快捷键足以让我驰骋 macOS，基本没机会用它。Contexts GreatApp 窗口切换工具。操作行云流水，切换方面比 Manico 更优秀！但不能定制用于快速启动 App 的快捷键，因而被 Manico 替代。iHosts灵活管理 macOS 的 hosts 的方案。可惜通常情况下，hosts 并不需要复杂的管理；而且还有很多其它手段达到同样的目的。对于程序员来说，不如直接在 .zshrc 加上 alias vh=&#39;vim hosts&#39; 一句剪短的配置，然后在命令行直接打开并修改 hosts 文件更省事。Keymo 极不推荐使用键盘操作鼠标，四象限定位法颇有创意！作为键盘党的我，真要用到鼠标的时候，还是用触控板比较舒心。我的触摸板、鼠标的触控灵敏度（移动速度）向来调到最高，操作还是很快的。这种操作方式不如直接用鼠标那样符合人的直觉，需要不少练习，所以不值得使用。Shortcat 极不推荐UI 上的 Spotlight。暂时难堪大用，直说就是鸡肋…… 不如快捷键来得迅速，甚至不如鼠标操作来得直接！系统增强Boom 极不推荐音效增强软件。可用于突破系统音量的上限，留意音量过大可能损坏 Mac 音箱。可有可无。HazeOver Focus瞬间找到当前正在使用窗口。除当前激活的窗口，其它窗口都会显示阴影，让人更专注与当前窗口的工作。可惜经过长期使用，感觉可有可无，上述说法可能只有理论上的作用和心理安慰的作用。iStat Menus支持顶部菜单栏部分自定义，显示硬件状态的监控软件。方便查看 CPU、内存、网络、硬盘及其它硬件的状态，还有日期时间栏的定制。Mac 没异常时，知道这些状态并没有显著的用处，如果设备崩溃了、卡了，还不是直接重启了事。f.lux Health根据所在地当时的日照，自动调整屏幕色温、亮度，减少蓝光对眼睛的刺激，以调整激素水平，保护正常睡眠节律。然而效果相同的 Night Shift 功能已经在 10.12.4 版本整合到了 macOS 中了！这个应用即将退出历史舞台。输入法Squirrel Geek but 不推荐鼠须管输入法，稳定、流畅、开源，个人可定制性极高。是 Rime 中州韵输入法的 Mac 发行版。折腾一番后，个人定制出来的输入法，从界面到操作细节都能很好地贴合个人习惯。但是，词句齐全的成熟本地词库不多，缺失「云输入」在线匹配新词，输入生词时诸多不便，用久了我就不想再折腾了。所以使用几个月后，回归了我惯用的 百度输入法（我手机输入法用 讯飞输入法）。iFanr 爱范儿的推荐 《 鼠须管，“神级”输入法 》配置教程 《 Rime 输入法 — 鼠须管（Squirrel）词库添加及配置 》我自定义的 Rime 配置、 Dictionaries 词库其它Time Out Health定时作息提醒工具。定时遮盖桌面的应用程序，提醒你离开电脑，去休息眼睛、活动身体。如人饮水，冷暖自知。自己多注意就好，要是实在不自觉，这个应用才有用武之地；其实真到了严重的程度，它也帮不到你了Nozio &amp; etc白噪音应用。模拟大自然的声音，屏蔽其它噪音干扰，帮助保持专注，提高效率，放松睡眠。音乐听久了也累，有时戴个 3M 降噪海绵耳塞（便宜），纯粹安静地工作就很专注、舒服，其实毋需白噪音。可以的话，买 Bose 的 QC 系列消噪耳机，效果更佳。我买的是 QC 20。CleanMyMac 不推荐Mac 系统清理软件。macOS 本身已经够好用、省心，毋需过多维护，它只不过锦上添花，不客气地说，是画蛇添足、无关痛痒。帮助卸载一些顽固的软件还是有用的。OpenEmu游戏机模拟器！可以模拟众多的旧时代的游戏主机！怀旧党福音。我又可以方便地玩我最喜欢的 NDS 游戏《最终幻想战略版 A2》啦！（还是少玩游戏为妙）iOS常用Safari SimpleiOS 自带浏览器。已足够好用。Shadowsockrocket FavoriteiOS 上配合 Shadowsocks 使用的番羽土啬利器。Others : Surge Expensive讯飞输入法 Favorite在使用非手写输入的键盘时，竟然可以在键盘区滑动，即可以手写方式输入！优秀的语音识别输入能力，准确率高，支持方言（我已经越来越多地使用语音进行日常输入了）。支持 3D Touch 移动光标。搜狗输入法 Great云输入匹配词语最准的输入法（个人感受）。唯一一个拥有 OCR 识别输入功能的输入法（留着备用）。语音输入不足为奇，但它独有更进一步的「语音修改」功能，使其更易用。笔记、时间、财务管理Notes SimpleiOS &amp; macOS 自带的轻量级笔记应用，启动、编辑、同步迅速稳定，方便易用。Evernote Powerful剪藏好文章，离线保存，做笔记。 ( Ref Above )2Do PowerfulGTD 事务管理。( Ref Above )BlockyTime Simple时间的记录统计工具，规划、督促、自省。A quicker time logger, let you never spend much time on tracking time.HabitBull习惯养成，记录、统计、分析养成的情况。该领域有很多 App，好用的不多…… 这个也不算最好的选择，需要自行挑选。MindNode Powerful思维导图。( Ref Above )网易有钱 Simple简单方便的记账软件。可以自动同步银行储蓄卡、信用卡和支付宝账户的交易和余额数据，然后再给每笔收支调整分类和补充备注就行了，实在是方便。后来，我发现自己只需要知道自己各个账户的余额，以及总体的收支情况，所以就弃用「随手记」换用它。如果注重隐私信息的安全，请注意退避该 App。随手记专业版 One fo the best我用得最顺手的记账软件。弃用理由见上文。社交Mail SimpleiOS 自带邮箱客户端。已足够好用。WeChat Required for payment微信，主要用于支付、社交和碎片阅读（公众号）。能用微信小程序代替的 App 我都不下载。例如：大众点评、摩拜单车、嘀嘀出行、京东 等等。TIM Simple手机上简洁版的 QQ，腾讯官方出品。去除了多余的娱乐功能，保证基本的进阶功能使用，方便工作，如音频视频通话等。不过还是得留着原版的 QQ，TIM 还不支持 QQ 的授权登录操作……阅读 &amp; 学习KindleAmazon 的电子书资源是最全面、最丰富的，喜欢读书的话，没有太多其它的选择。多看阅读 Best阅读软件。可导入 PDF，带云存储，操作流畅，阅读体验一流。扇贝英语 系列 Apps English扇贝单词、扇贝炼句、扇贝听力、扇贝读书。工具不重要，最重要还是要坚持学习。网易公开课国内最好的公开课平台。播客用过绝大多数 FM 类 App，唯剩它们。内容为王，通常都为了追喜欢的栏目被迫换 App 的，才发现某产品体验好，自然而然成为其用户。得到 Great「罗辑思维」团队推出的主打 知识服务 的 App。Castro 2 Favorite小巧易用，轻量级泛用型播客 App 的最佳选择！PodcastsiOS 自带泛用型播客 App，功能完备，无广告，最稳定，但是有太多用不着的功能，选择旧节目下载的操作太捉急。---喜马拉雅FM Popular使用体验与内容俱佳，许多电台自媒体的首选独播平台。当之无愧的国内第一播客平台。凤凰FM拥有凤凰传媒的版权内容，有我最喜欢的谈话节目《锵锵三人行》。企鹅FM腾讯出品用户体验必然好，娱乐类节目偏多。资讯 &amp; 知识知乎 - 优质问答社区。微博 - 国内最大的自媒体平台。（暂时无法被替代……）微博问答 - 微博内置问答平台，还是有不错的内容的。可以用 Weibo H5 Beta 版，有正常的时间序，轻度使用体验拔群！即刻 - 关注感兴趣的主题，收到量身定制的更新推送。很不错。青芒阅读 - 资讯类 Apps 内容汇总。音乐 &amp; 娱乐Douban FM豆瓣FM，随便听听，或者想要发现喜欢的新歌，还是会选择它。已入 Pro 版。Netease Music Favorite网易云音乐，音乐类软件的新标杆。能找到很多好歌单，冷门好歌，最喜欢看歌曲评论，分享感动和共鸣。Deemo Favorite, Best最爱的音乐游戏！最爱曲目：Magnolia 。超喜欢这个游戏工作室：Rayark ！AcFunBilibili Favorite, Best现在看视频不带弹幕，就总觉得差点意思。Others : 土豆 , YouTube安全1Password密码管理。Authy Better Authenticator!两步验证器。可以多设备云同步、备份其中的验证信息。不像其它验证器，无法便捷切换到新的设备商，而且一旦卸载了，相关信息就丢失了。Google Authenticator Required两步验证器。提高安全意识，能开启两步验证的网络服务都开启，别嫌麻烦。Tencent Security 腾讯手机管家iOS 最好的来电防骚扰助手。（实际很少收到骚扰电话，所以已卸载）其它支付宝不得不装，用于交水电费、查快递、淘宝天猫亚马逊付款……高德地图各个地图 App 当中，个人觉得这个最美观、顺手。腾讯地图虽然可以完全离线，可是用起来不习惯。欧路词典 Pro英语词典。可使用在线有道词典，无广告！QQ 同步助手iOS 语言设置为 English 后，需要它进行中文联系人排序；还可以合并、去重、修改以及备份通讯录。Serverauditor temp免费的移动 SSH 客户端。运维、服务端研发工程师们随时随地“救火”的利器。（只能作为权宜之计，远不如笔记本电脑方便）除了 iOS 自带且不能删除的 Apps，iPhone 里就几乎只有以上的少数（没划删除线）的 Apps。浏览器插件其有必要使用的浏览器插件并不多。例如，改善微博浏览体验的各种插件、油猴脚本、Stylish 样式等等，用它们还不如把微博戒了。如果要看用原版网页就够了，觉得折腾起来意义不大。常用1Password Pwd Security管理帐号密码。Evernote Web Clipper Efficient, Best一键收藏各类网页图文，保存到 Evernote。Web Proxy代理服务配置工具。Firefox : FoxyProxy Standard Web DevelopmentChrome : SwithyOmega Web DevelopmentVim用 Vim 的键位去浏览、导航网页，减少使用鼠标的使用，键盘党神器！Firefox : VimFX Favorite, BestVimperator 拓展功能太强大，响应速度、稳定性、外观和易用性不如 VimFX。我的 VimFX 设置Chrome : Vimium SimplecVim Powerful 功能更强大、丰富、可配置，但需要用类似 .vimrc 的文本方式进行调整功能配置，比较麻烦。浏览器增强uBlock Simple快速轻量级的广告过滤器。Adblock Plus &amp; Adblock Plus Elem Hide Helper Focus, Clean老牌广告过滤器之一。防止追踪、屏蔽恶意域名，过滤横幅广告、弹窗广告以及视频广告。配合元素隐藏助手使用，可更轻松地建立元素隐藏规则。xThunder Firefox统一管理浏览器各下载器的调用，支持迅雷、DownThemAll 以及浏览器的自带下载器等。JSONView Web Development清晰明了地展示页面的 JSON 格式数据。DownThemAll!批量下载工具。多线下载，速度更快，功能更强，非 P2P 下载用它代替迅雷和浏览器自带的下载器。（一般情况下用浏览器默认的下载器就够了）Greasemonkey Geek使用 JavaScript 脚本自定义网站网页的布局、外观、操作等！有提供油猴脚本的 网站。（用多了，影响网页的加载速度和性能还有安全性…… 没必要这样折腾，用原版网页。）WindowsTortoisGit - 便捷好用的 Git GUI 工具。Fiddler - 抓包工具。EditPlus - 功能强大的文本编辑软件。StrokesPlus - 强大的 全局鼠标手势软件。Everything - 强大的 全局文件检索工具（ Q &amp; A ）。Listary Pro - 类似于 Everything，各有优劣。AutoHotkey - 全局快捷键设置工具。Ref : Windows常用软件推荐硬件以下附带部分个人测评（使用感受）。电脑 &amp; 外设MacBook Pro Retina 13-inch Favoritei7 - 3.1 GHz / Mem 16 GB / SSD 512 GB ，Mac 是软件工程师的最佳工作平台！Unix-like，稳定、省心。用好了 Windows，才了无牵挂地换了 Mac。Magic Trackpad 2 - 触摸板Macbook 自带触摸板的手感已经非常好了，但它还要更胜一筹！第二代比第一代触摸面积大了不少，有三段式压感反馈，手感细腻。还是嫌它大了点，因为我的 Mac 光标移动速度向来调到最快，基本一次小幅度滑动，光标就到位了，不需要太大的触控面积。基本不玩 PC 游戏，所以完全改用触摸板。SAMSUNG Portable SSD T3 500GB - 便携 SSD用这个便携固态硬盘当作备份盘确实有点奢侈……拓展邬Sabrent USB 3 Universal Docking Station - 拓展邬 &amp; 底座可当底座可以当手机、平板、笔记本电脑的底座用（我的 MBP 不开盖，外接显示屏用）。接口够用USB 3.0 接口 x 2，USB 2.0 接口 x 2，USB 充电专用接口 x 2，全都是 Type-A 的；还有 Ethernet 接口、HDMI、音频 IO。外接备份硬盘、机械键盘，不用带 USB 充电口的插线板了；外接物理网口，不用 Ethernet 转 USB Type-A 的适配器了；（真是浪费了之前买 Moshi USB 3.0 - 千兆以太网转接线 ……）音频输出不灵，耳机还是得插在笔记本电脑的机身上；HDMI 接口连 2K 屏，帧率达不到 60 Hz 以致有卡顿（可能是传输线的带宽不够），只能用回 Thunderbolt 2 接口连外接显示屏。方便拔线现有的外接线头都插在笔记本电脑的左侧，电源、连显示屏的 Thunderbolt 2、连拓展邬的 USB 3.0，还有耳机插线。略有遗憾，但足够满意线头集中摆放，工位整洁多了；外接新设备，接口够用，接入也方便多了。本来想买个用 Thunderbolt 2 接口接入的更好的拓展邬，但至少贵一倍，而且新款 MacBook Pro 支持的是更先进的兼容 USB Type-C 的 Thunderbolt 3 接口，所以我不想买 Thunderbolt 2 的，最后决定先买个便宜的将就着用。键盘Magic Keyboard - 蓝牙键盘（第二代）小巧轻便。Mac 的键盘布局紧凑合理，手用更小幅度的移动就能触及所有按键，省力。可能你会觉得敲起来手感「绵软」，但是作为「键盘党」的我，快捷键很多而且用得频繁，就觉得使用它很舒适、省力、安静。键程 不会太长或太短，不需要用力按下，有舒适的反馈感（个人感觉），用久了手也不容易疲劳，特别是小指；而且敲击按键的声音小，不容易打扰到别人。使用蓝牙 4.0 无线连接，功耗低 —— 没有连接线，这点简直是洁癖和强迫症的福音；内置电池，Lightning 接口充电，一次充电能够续航三周以上，省心。PFU HHKB Professional JP - 静电容键盘黑色，有刻印（按键上印有键位说明），日文键盘布局。果然还是按耐不住好奇心，买了一把机械键盘（严格来说静电容键盘不是机械键盘）来尝试。「HHKB Pro 2」系列 60 键 US 布局精简至极，看起来精致小巧、赏心悦目「逼格满满」啊！但是我这个快捷键党为了改键的需求，最终选择了按键更多、布局奇特的日本版。为了无痛切换 HHKB JP 和 Mac 键盘而同时修改两者的布局，其键位功能基本一致，并吸收了 60% 键盘的特点：如数字键 1 左侧的 Backquote 键换成了 Esc 键等。其它：觉得键盘还是该配腕托，不然每天敲键盘的时间太长很累。还有该配桌垫，不然我手臂瘦没有肉，手肘放在桌上感觉特别「搁」。手机iPhone 8 wish!iPhone 7 Black Favorite128GB + Red Silicone Case ，闪电般流畅，稳定省心；小巧称手，单手操作高效、舒适。笔记、记账、GTD、阅读、通讯… 随身的效率工具，我一定买最好的。哑光黑很 Geek！强迫症的我受不了娇贵易损的亮黑。我很喜欢 Red Silicone Case（官方硅胶保护壳）的轻微磨砂质感，舒适、不滑手。iPhone 6 Plus Gold 备用64GB + Turquoise Silicone Case ，续航不错、屏幕尺寸合适。作为iPad 的替代品和备用手机，出门就可以不带充电宝了。比小屏 iPhone 更适合阅读和看视频，又比 iPad Mini 更便携、方便单手操作，挤地铁公交的时候用也没问题，也是最适合玩手机游戏的尺寸。Turquoise Silicone Case（宝石绿官方硅胶保护壳），一分钱一分货，用久了也能保持悦目的颜色。Rose Gray Leather Case 官方真皮保护壳易氧化变色，显脏，所以得买深色的。手表Apple Watch Sport Favorite38mm Space Gray Aluminum Case with Black Sport Band ，手机辅助工具、健康助手。消息推送更私密，还可以使用语音识别输入内容，不用掏出手机就可以快速预览信息、回复。便于设置闹钟、计时、倒计时，倒计时可结合番茄工作法使用。可以控制手机的音频播放，不用掏出手机进行操作。便于查看日期时刻、天气，例如：之后每小时的降雨概率，便于决定是否带雨伞、骑行出门。显示每日的运动清况，激励、提醒你保持运动的习惯，促进健康；每久坐一段时间，它就会提醒您站起来休息一下。很喜欢 watchOS 3 新增的深呼吸辅助应用，可以用来放松、冥想、帮助睡眠。平板电脑iPad Air32GB + Red Smart Cover + 言外 Involve Leather Bag，多用于阅读技术类书籍，看看动漫、电影、公开课。结合 Magic Keyboard 能够满足轻度使用，不用总是携带笔记本电脑回住处。Kindle Paperwhite E-reader - 电子阅读器 Sold+ Amazon Onyx Black Leather Cover ，需要长时间看书时，还得用 E-Ink 屏，保护视力。耳机Bose QC30 wish!无线蓝牙连接，充电 &lt;3h，续航 10h；消噪程度可控，分多级。续航时间比 QC20 短，不能像 QC20 那样一键切换「消噪」和「接收外部声音」两个状态，比较麻烦。Bose QC20 Favorite, BestQuietComfort® 20 Acoustic Noise Cancelling®headphones — Apple devices目前市面上我所知的最好的降噪耳塞。主动降噪，耳塞发出一种波与有规律的噪音相消。可「一键切换」是否隔绝周围环境的噪音；降噪后，可用更小的音量使用耳塞，声音更清晰。人声不能完全隔绝，但其音量会变得很小；主动降噪时，再稍微播放音乐或白噪音，即可在很大程度上隔绝外部噪音。它帮助我在嘈杂的办公室也能在静谧、专注地做事。虽然它贵，但花得值！SONY MDR-EX750BT portable颈戴入耳式耳塞，外观亮骚，音质出众（只对比各蓝牙耳塞，且不含头戴式耳机），便于携带；续航 7.5 h，没电时，也可用外接耳机线连接其它设备继续使用。无线蓝牙耳塞中的佼佼者！音箱Sony SRS-X1-V FavoriteBluetooth Wireless Speaker System (Purple)，不打扰别人情况下，尽量用蓝牙音箱来外放，更舒服自在。在安静环境下，用适度的音量外放合适的音乐或白噪声，更容易让人产生沉浸式的专注体验。戴耳塞、耳机，让音源很靠近耳朵（头部），发出的声音太容易抢占人的注意力，沉浸体验不如外放设备。而且戴耳机、耳塞，多少会压迫侧颊、耳朵、头部，耳道有异物感，始终不是最舒适的状态。长时间戴耳机、耳塞，又不注意清洁设备和耳朵，有可能导致中耳炎，请注意保护听力。音效还不错（对比类似价位的同类产品）；续航持久；无线连接迅速；防水，可以在浴室使用。还是一分钱一分货啊。护牙牙刷Philips Sonicare DiamondClean Sonic Electric Rechargeable Toothbrush FavoriteModel HX9331/04, White，声波式电动牙刷，确实比手动刷干净多了！（亚马逊中国）电动牙刷刷牙相比手动刷牙有什么优缺点？Summary：电动比手动好，各种好（完爆）；旋转式的比声波式的刷得干净；声波式的比旋转式的磨损小；用电动牙刷的话使劲别太大。My Related Note - 牙齿保健冲牙器Philips Sonicare Airfloss Ultra - 冲牙器（水牙线）Model HX8332/11。（京东）Summary：使用牙线有必要性吗？牙齿与牙齿间的缝隙，牙线或冲牙器，才能弄干净；需要牙刷 + 牙线结合使用才能全面清洁牙齿。清理牙缝哪家强？两款水牙线的主观评测Debate：美国卫生署删除了“剔牙”“用牙线”的建议…Flossing has no proven benefits, so U.S. health department stops recommending the practiceMy Related Note - 牙齿保健羽毛球Victor TK-ONIGIRI - 羽球拍 Favorite胜利的 Thruster K ONIGIRI 突击鬼斩。进攻型羽毛球拍，重量 4U，手柄 G5 粗细，拉 28 磅的 YONEX 80 Power 线。毕竟我喜欢暴力打球。打惯 3U 的球拍，一开始不适应，感觉它偏轻、没“手感”。挥拍扣杀时，感觉球拍不够重，惯性不够大，出力不足。但移动、挥拍、救球、回球来更快更灵活，省腕力，长时间打球省体力。Mizuno WAVE SMASH LO 白 - 羽球鞋美津浓的鞋比尤尼克斯的更柔软舒适，特别对我这种经常跑动刹车的人来说没那么顶脚趾。旧：YONEX 65FT 白 JP 版 已穿坏…买一双像样的羽球鞋，是为了运动时能更舒适、灵活地移动，保护脚趾、脚掌、脚踝、膝盖。快速移动、跳跃后，脚跟落地，能明显感受到它的抗震性很好。YONEX 16201 训练服 - 运动服VC 面料，透汗、速干；Made in Japan 原版，高性价比。纯白色 &amp; 纯黑色，各一件。骑行Merida Duke 300 Favorite美利达公爵 300，入门级山地车，白色款，24 速 + 油碟（刹车灵敏，手感好，持久耐用）。主要用于：上下班通勤，以及 方圆 20 km 内的日常出行。安全装备：头盔 + 运动臂袖（护臂&amp;防晒）+ 手套 + 车前灯。其它装备：防晒霜 + 魔术头巾 or 铁发箍。智芯 Z1 - 自行车智能硬件用于 骑行数据记录（定位、计时…）、车队组网互动、防盗！还可以进一步购买 自行车盗抢险，更放心、充分地用车。背包背包Côte &amp; Ciel BackpackIsar Eco Yarn / Black Melange ，就是喜欢它特别的外观设计。即使是小号的包，也还是偏大了，适合高大的人背。而且外形奇特，不容易搭配衣着，比较“挑人”。只是个尼龙材质的包，但价格不便宜，建议先试背，询问亲朋好友的意见后，再购买。Rains Msn Bag wish坐飞机看到旁边妹子背的这款包很好看。也在考虑 Backpack、Backpack Mini。迪卡侬 骑行背包有了自行车之后，就在公司待到比较晚才回住处，因为懒得背电脑回去使用。带回去的东西少，小包更方便。而且夏天背着比较大的背包奔走、骑行，容易汗流浃背。骑行、跑步甚至日常出行，我都喜欢使用这个小巧轻便的透气户外背包。其它日用电子小米插线板 - 插座小巧精致，节省空间又好看，省了不少 USB 充电器。纯白色 &amp; 纯黑色，各一个，分别放公司的工位 和 住处的床头；出行时也带一个以备不时之需。极路由 1S - 路由器小巧便宜，设置简单，可以远程操控，满足一般的居家使用。广州家里 &amp; 北京住处，各一个。（坏了的话，打算换 华为的路由器）Fidget Cube、Fidget Pad、Infinite Cube - 减压神器用新的「手癖」—— 玩减压神器，去代替其它不良的「手癖」！例如，咬手指、敲桌子、抠鼻、抠耳朵、抠脚、抓脸、抓头发……减压骰子、减压手柄、无限魔方，还有魔方骰子、指尖陀螺、减压笔等。（搜索关键词「减压神器」……）伞具BENJAMIN 本傑明傘 wish!大洋之舞 or 深海鱼群。Topumbrella 渐变色折叠伞 蓝~紫色轻便、好看，直接推拉杆上连接伞骨的圆环，不用按按钮，就可以开合。article .article-content ul li p:first-child{list-style:disc;text-align:match-parent;font-weight:700}]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最喜爱的]]></title>
    <url>%2Ffavourites%2F</url>
    <content type="text"><![CDATA[乐以忘忧，不知老之将至。《论语·述而》所爱之物记录于此。所爱不少，所以只记录最偏爱的那一些。运动羽毛球毽球书Reading Bookmarks - Books电影Limitless《永无止境》，爽！Whiplash《爆裂鼓手》，反励志 / 残酷鸡汤。The Secret Life of Walter Mitty Best《白日梦想家》，让梦境照进现实。Zootopia《疯狂动物城》，隐喻。夏洛特烦恼凡人的梦。Léon《这个杀手不太冷》Inception《盗梦空间》，精彩。Fight Club Best《搏击俱乐部》，另一个自我！The Godfather Best《教父》系列，何为男人。Forrest Gump Best《阿甘正传》，温暖。The Shawshank Redemption《肖申克的救赎》，自由。三傻大闹宝莱坞教育（鸡汤）。未麻的部屋惊悚，精巧的叙事。千与千寻追寻。麦兜故事 Best童真。借东西的小人艾缇莉雅诗意。言叶之庭青涩。红猪洒脱。夏日大作战夏。哈尔的移动城堡 Best 最爱 No.2绚丽。你的名字。 Best 最爱 No.1梦。电视剧半泽直树复仇，弱肉强食。最完美的离婚生活。家族的形式不婚族？Legal High Best法律至高。Black Mirror Best《黑镜》，警世。动画排球少年 Best of the Best新世代的灌篮！乒乓 Best of the Best人生，天赋与努力。虫师恬静，幽深。棋魂围棋。亚人 Best人性，理性。寄生兽人性，自然。一拳超人 Best反英雄主义。剑风传奇 Best快意。进击的巨人热血。火星异种热血。（只推荐第一季，及其漫画）破刃之剑机战。永远之久远异能。叛逆的鲁鲁修 Best of the Best剧情、奇幻、机战、政治…… 各元素熔于一炉的神作！高达 Seed &amp; Seed Destiny &amp; OO &amp; 铁血孤儿神棍偶像剧 &amp; 铁血孤儿。Re：从零开始的异世界生活 Best of the Best轮回，执念。魔法少女圆香 Best of the Best轮回，救赎。打破常规的魔女作品，虚渊玄作品！神作！ONE OUTS~ Nobody wins but I! Best《超智游戏》，渡久地东亚！智力碾压。钢之炼金术师原创结局（当时漫画未完结，但原创结局也很精彩）。钢之炼金术师 Fullmetal Alchemist2011 年重制版，跟随原著一同完结。Fate / Stay Night Best自此爱上 Saber！Fate / Zero英雄的盛宴。Hunter X Hunter Best of the Best《全职猎人》，富奸是天才！剧情世界的架构满分。No Game No Life Best《游戏人生》，动漫就是要看得痛快。Guilty Crown《罪恶王冠》，楪祈好美，音乐作品美哭。Overlord Best《不死者之王》，就喜欢装逼毫无违和感的满级主角。EVA（上一世代的）神作。我的青春恋爱物语果然有问题 Best of the Best少年心声。我的妹妹不可能那么可爱 Best傲矫。暴走的结局。少女月刊野崎君 Best恋上漫画家。甘城光辉游乐园欢乐。邻座的怪同学女学霸和男学霸的爱情故事。交响情人梦野田妹~[ C ] The Money of Soul and Possibility Control未来。伪恋恋爱喜剧。齐木楠雄的灾难 Best笑得根本停不下来… 哈哈哈…冰上的尤里华丽。Angel Beats!音乐。花开伊吕波花开之色。冰菓 Best of the Best情愫。One Piece心目中的最燃作。无奈太长弃坑。火影忍者入宅作，从只有几集动画时就开始追了，却没坚持到最后。罗小黑战记 Best萌~&nbsp;其它看过的片用豆瓣记录所有看过的片意义不大还麻烦，以后只在博客此处做记录。游戏iOSDeemo Best最爱的音乐游戏！最喜爱的曲目： Magnolia , Walking by the sea , Living in the one.PC三国志 9战略游戏经典之作。Hearth Stone《炉石传说》，勾起当年玩「游戏王」的卡牌情结。Heroes of the Storm《风暴英雄》，有趣易上手。最喜欢跟朋友一起并肩作战，半夜兴奋狂吼。Warcraft 3 Best《魔兽争霸3 冰封王座》！当年多喜欢即时战略，不过这股风潮已经过去。之后崛起的 Dota、LOL 就没玩了。掌机Final Fantasy Tactics A2 Best《最终幻想战略版》 A &amp; A2 ！ 我最喜欢的游戏类型就是战棋，它就是我心目中的神作！ 最喜欢的最终幻想衍生游戏分支，我重玩次数最多的游戏， 献给这个系列的两作游戏的时间远超700小时。Kingdom Hearts Re Chain Of Memories《国王之心：记忆之链》逆转裁判 系列 Best当之无愧的神作！律师的故事，有趣的玩法，巧思妙绝、荡气回肠的剧情，让人久久不能平复！只通关一次怎能完全体会其中绝伦的精彩……Dissidia Final Fantasy《最终幻想：纷争》Pokemon《口袋怪物》系列，童年经典。PS2Gundom Seed &amp; Seed Destiny当年迷高达的，所以爱屋及乌。木叶的忍者英雄们 系列我曾经最精通的格斗游戏。有很长一段时间，我曾是我那一片街区，这个游戏打得最好的！红白机热血系列 Best热血硬派、热血高校、热血物语、热血足球、热血篮球、 热血进行曲、热血新记录、热血格斗传说……Battle City《坦克大战》，还是好想玩啊，啊啊啊…Super Mario Bros.《超级马里奥兄弟》，横版闯关的经典。Gal Games沙耶之歌 Best我的重口 Gal 入门作，虚渊玄作品。壳之少女超文艺，也超重口。鬼哭街2011重制版 Best我想象中的现代中式武侠打斗的文字描写范本，虚渊玄作品。其它游戏王 Best挚爱的卡牌游戏，当年几个损友一起愉快地玩了三年，花了不少钱去买正版卡牌；初三戒了，就再也没有继续下去，几个损友如今也难再聚。围棋 Best深奥幽玄。当年买了好几本大部头教材，小学中午午睡时间我不睡觉，就在被窝里钻研。歌手Twins Best古巨基陈奕迅 Best杨千嬅 Best卫兰周杰伦王力宏陶喆F.I.R.S.H.E.Tank南拳妈妈梁静茹 Best张韶涵苏打绿 Best陈绮贞 Best方大同 Best初音ミク BestClariSEgoistSupercellGARNiDELiALiSA]]></content>
      <categories>
        <category>read</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2Fweb%2Fbuild_blog%2F</url>
    <content type="text"><![CDATA[竹径通幽处，禅房花木深。《题破山寺后禅院》常建进阶文章《 折腾个人博客 》本文旧版《 Why and How to bulid my blog? 搭建我的个人博客 》后记写了不少，舍不得删掉。但是这类教程，网上已经够多了，再写价值不大。特别是知道了 Next 这个 Hexo 主题之后。这个 Hexo 主题基本包办了我想要的几乎所有博客功能，而且配置方法也很简单。但是这些便利性造成了一个问题：做个人博客是为了彰显个人的独特个性和审美。用别人做好的博客主题，可以选择一个不热门的，但是配置起来麻烦，很可能缺少一些特别的功能支持，要自己 DIY。而我自己现在就特别讨厌没有意义的折腾。要是选择一个比较流行的博客主题，虽然功能齐全，但是会觉得不够独特，容易跟别人撞主题，感觉就跟「撞衫」一个道理。但是要是再仔细想想，如果你是一个会思考有思想的人，总能提出独特的观点，无论你是用微博、CSDN、博客园还是随便哪个平台发，都是无所谓的，总会赢得别人的认同。外观与众不同，当然可以算作是是独特的。但是真正的与众不同、特立独行，不光在表面上，更应该是思想上的，不然我觉的就没啥意思。算了吧，保留本文，不过不再更新了。记于 2017-01-02初衷与其到各大博客平台去写博客，不如自己搭建个独一无二的。不但过程有意思，还能学到许多新知识。可以用来记录 自己的人生，放一些值得分享的技术、读书笔记和感想。过程教程的各步骤描述得越详细，时效性往往越差。网上的类似的教程多如牛毛，不差这篇。所以，我并不打算详细写，只简略说明过程与所用的「轮子」（工具、模块），并列出本人参阅的教程文章的链接，其它更具体的细节自行百度 / Google，查阅其它教程与相关工具模块的官方文档。还有，折腾才能学到真东西，下文做法、用法从略处，还请自行摸索。引子非软件、计算机专业的人，自行搭建个人博客其实不难。前人早已造好了各种「轮子」，只要根据网上的教程摸索一下，动动手指头就可以组装出自己的博客。可以用 isnowfy 的 静态页面生成静态博客 的方法，对一个新手来说，那感觉真是妙极了！当时就想：不如自己写个博客生成器吧！那当真是一件蛮有 geek 的事啊。但吾生有崖，而知也无涯，没必要自己重新「造轮子」，阅源码解其精妙未尝不可。君子善假于物，省出时间，去做真正想做的事情岂不是更好。搭建博客的方法，除了用不同的静态博客生成器来生成外，还可以租用或搭建一个服务器，来运行一个动态博客，其中最出名的非 Wordpress 莫属，现在有更多性能优越、更便于搭建维护的博客框架，可另行查阅。为了让个人博客有足够定制空间的同时，尽可能降低维护成本，我选择了静态博客生成器：Hexo !（有空会找机会再折腾一个动态博客）Hexo 建站教程广泛检索后，参阅他人的建站教程参考教程：使用 GitHub 和 Hexo 搭建免费静态 BlogHexo 系列教程：（二）搭建 Hexo 博客Hexo 系列教程：（三）Hexo 博客的配置、使用Hexo 系列教程：（四）Hexo 博客的优化技巧Hexo 系列教程：（五）Hexo 博客的优化技巧续…其中会提到，下文涉及的「定制点」的内容，包含功能模块的具体配置方法。可能其中涉及各工具和模块已经有新版本，具体操作细节最好参考它们最新的官方文档。有探索精神的直接可直接参照 Hexo官网，它提供中/英文的各种帮助信息，包括文档、API、插件、主题等，告诉你建站方法、基本操作、自定义部分……前人之述备矣，在此不再赘述基础部分。定制点建站很容易，如果你的需求只是写写文字博客而已，可以到此结束了。但如果要完善博客到合乎自己的心意，那将是万里长征的第一步。要获得更大的定制余地，让自己的博客更独一无二，最好懂些网页技术，就可以修改别人工具模块的源代码，让博客支持更多需要的模块、插件、外观效果等。主题Theme不单只提供不同的博客外观、视觉效果，通常还会提供许多功能模块的配套支持！一般包括但不限于：评论、分享、RSS订阅、联系方式、百度/谷歌的统计分析、标签云。官网上有提供很多第三方主题：官方列表：Hexo Themes现在选用的是：IIssNan 的 NexT（官方文档）曾经选用的是：WuChong 的 Jacman该主题作者的官方教程：如何使用 Jacman 主题它包含了以下绝大多数的定制点，不需要自己折腾太多，也可以很快做好。如果你更喜欢 DIY，想要亲手试一试第一次搭建静态微博，从中多了解学习些细节问题，当然更好。Hexo 官网的文档和 API 中有 theme 写法的说明，可以自己重新写一个 theme。评论利用第三方社会化评论系统，可以便捷地为博客添加评论模块。这些评论系统可以让你和你的访客在你的博客下添加评论，还能审核、删除、迁移（博客变更后保留评论）、自定义评论框的外观效果等，它们一般都提供足够的定制空间。推荐：国内：畅言 （可惜需要网站备案…）国外：Disqus原来国内能用 多说 可惜在 2017 年 5 月 1 日关停了服务。具体评论系统搭建比较麻烦，有能用的，就不推荐自己折腾。分享添加分享模块可以方便自己或他人在第三方的社交平台分享你的博客内容。这还是借助第三方的帮助：它们也会提供许多方便定制选项，懂些 HTML、CSS、JavaScript 就能深度定制了。推荐：百度分享jiathis自己编写（并不会太难）关于页面一般用于介绍博主或博客的页面。例如：我的「Me 我」页面。404 找不到页面当访问一个不存在于博客中的页面时，展示的提示页面。例如：我的 404 页面。推荐：腾讯公益 404域名有只属于自己的个性化域名，简直自豪感满满，因为终于有自己的个人网站了 T_T分两步：买域名，域名解析。域名购买推荐：国内老牌：万网（已被阿里收购）国外老牌：GoDaddy我的选择：NameCheap想要最低的价格，可以参考域名比价网站 Domain Price Comparison。推荐阅读知乎问答：现在去哪里买 .com 域名最便宜？因为买域名不能只考虑价格，还得考虑服务。域名解析推荐：老牌：万网（在万网买的域名，可以直接用它）我的选择：DNSPod（国内、免费、稳定、快速、用户友好）域名解析选择国内运营商，有利于提高国内访客的访问速度。具体配置过程可参考：域名和 DNS购买域名、设置dnsSitemap &amp; RSS站点地图 &amp; RSS 订阅。站点地图给搜索引擎的爬虫以及网站的订阅者，说明了博客里有哪些链接、文章、页面内容，提高博客在搜索引擎的抓取、收录效果，给关注你博客的朋友，提供了订阅功能。TODO: 待日后补全细节，暂参考 RSS 和 sitemap具体配置过程可参考：Hexo 博客的优化技巧续（推荐结合以下内容阅读）注意可能出现的 Bug：本博客 RSS Feed 和 search.xml 曾无法正常地以 UTF-8 的编码格式被解析。（后者用于 Hexo 的 NexT 主题文档推荐的 站内搜索 之一的 Local Search）后来我遍寻网上的相关搜索结果，在仔细研究之下，才发现这原来是因为：自己的某些博文中（不知为何）混入了一些「控制字符」，只要将博客中不在 UTF-8 编码范围内的控制字符去掉，即可恢复正常。搜索、替换的具体操作提示：浏览器打开这些 xml 文件时，就会告诉你哪里解析出错了，看一看第一个解析出错的编码是什么。我的是 0x15 即 ^U，详见 ASCII 表。再看一看这个控制字符来自于博客的哪一篇博文或组件，使用 Vim 编辑器打开混入了控制字符的文件，查找并删除它。（不是所有编辑器都能便捷地支持控制字符的输入和查找）Vim 替换指令请自行 Google，Vim 中输入控制字符的方式如下：例如输入 ^U，要先按 ^V 然后 再按 ^U 即可。重复以上步骤直至完全解析成功为止。闲杂模块除了博客的基本功能模块，还有一半需要额外添加的模块。Hexo自带的功能：archive 归档、category 分类、tag 标签。其它的模块，如：微博秀图床顾名思义，存放博客图片的地方。当然，可以直接存放到托管你静态博客代码的平台，但是，它们的代码仓库的空间有限，以后就可能不够用了。所以，你可以申请多个 Github、Coding.net 等平台的账户，用新的代码仓库来放额外的图片。但是，代码托管平台的访问速度也不够快，会影响博客的加载速度，日后要迁移图片也麻烦。如果放在你的（云）服务器上，动态的服务器也会出现流量和带宽有限的问题。所以，博客里的图片，最好挂载到第三方CDN提供商那里，提高博客网页的读取速度，提升访客体验，也方便图片资源的迁移。推荐：(1) 老牌：又拍云（服务好、价格高）(2) 我的选择：七牛云存储（国内、免费、方便）站内搜索让访客可以自行搜索博客中感兴趣的内容。百度和 Google 都有提供站内搜索功能，但是只能是搜索到你博客中被搜索引擎收录到的那部分内容。对于一个新建的小网站来说，很可能被其收录的内容很少，没有对博客足够齐全的索引，搜索结果差。国内的一般访客也访问不了 Google，百度站内搜索的体验也不佳。推荐：(1) 我的选择：Hexo 主题 NexT 内置的 Local Search(2) 国外免费：Google CSE 需要访客能访问 Google 才行(2) 国外收费：Algolia 和 Swiftype 在免费试用后，需缴费才能继续使用完整功能(3) 国内：暂无足够好的选项Local Search 和 Google CSE 根据官方的流程一步步来即可。而 Swiftype 具体配置过程可参考：利用 Swiftype 为 Hexo 添加站内搜索 v2.0PV/UV访问数/访客数的统计与显示。统计、显示博客每篇、每个页面的访问数。手段繁多，我参考了这个方法：使用 LeanCloud 平台为 Hexo 博客添加文章浏览量统计组件它提供了统计、榜单显示的具体方法。但是，你可能还需要：在首页文章列表、文章页面上显示该文章的访问次数。具体方法，可以通过查看我博客页面的源代码了解，或者到我的 Github 查看我的博客 theme 的源代码：自定义过的 Jacman 和 NexT。如果需要整个网站的页面访问量（PV）、独立访客数（UV）的统计与显示，则可以参看这个第三方工具：不蒜子 - 搞定你的网站计数Site Analysis网站分析服务。帮助你去统计分析网站的各类数据，包括且不限于查看 UV、PV、IP 数、来源网站、入口页面、受访页面、访客地区、设备、系统、忠诚度，抓取网站收录到搜索引擎，提供 SEO 优化建议等的服务。推荐：(1) Google Analytics(2) 百度统计最好两个同时使用，还有它们的站长工具，体会其中的差异，而且它们会派爬虫去抓取你的博客，其结果将会收录到搜索引擎~访问速度优化手段繁多，除了上文提到的将图片放到 CDN 服务商那里的方法外，CSS 文件、JavaScript 脚本等也可以放到 CDN 那里，把静态网站托管到更访问速度更好的平台（也包括 CDN）上，压缩图片到适当大小，优化 theme、JavaScript 脚本的代码……在此不赘述。托管博客到 Gitcafe 比较便捷。可参考 Hexo 系列教程之五：Hexo 博客同时托管在 Github 和 Coding卖广告当你的网站做得一级棒，流量很大（访客很多）的时候，就就可以靠卖广告挣点外快了，挣回网站的维护成本，甚至养活自己，发大财￥推荐：(1) Google AdSense(2) 百度广告还有很多其它广告平台，可自行查阅。围绕上述各点，折腾了不少时间，当然也学到许多新的知识。其它源代码博客实体的代码生成博客用的代码博客 Theme: Jacman 的代码（旧）博客 Theme: NexT 的代码（新）鸣谢Hexo 作者：Tommy Chen主题作者：WuChong关于我这是我的 简介 。感谢您的阅读。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理日志说明]]></title>
    <url>%2Fthink%2Ftime_mgt%2F</url>
    <content type="text"><![CDATA[链接：《 我所有的时间统计日志 》启发：《 奇特的一生 》 柳比歇夫 的时间统计法旧版：《 Time Mgt. 时间管理 - 辅助日志的使用 及 相关思考 》补充：时间管理日志格式一直根据实际使用进行调整，可能与本文描述不一致。最新：2016-12-05本文仅供参考，各位需要自己试着摸索适合自己的方法，才是正道。现在我已经不用 Evernote 来做时间记录，以及 AppleScript 和 Python 脚本来跑统计结果了。而是用 iOS 的 App —— BlockyTime（时间块），它的特点刚好非常适合我使用。以后可能还是会用脚本去自行统计 BlockyTime 其中时间记录，找出自己感兴趣的东西，深入了解自己。原则简便：记录方式简便，只统计要用的信息，避免成为负担有序：格式统一，便于数据的整理、分析时间粒度时间粒度，即每个时段有多长。类似于一节课有多长时间，据此规划、统计自己的时间。对我而言，1、10或15min的时间粒度太小了，而 30min 就刚好，因为：便于规划、统计30min == 0.5hour 该时间粒度，就可以以每小时的整点、半点为界，等分一日的时间。减轻压力适当对统计数据进行模糊处理（四舍五入），让人少产生些心理压力，更利于坚持养成时间管理的习惯。例如，某30min用了15min以上读书，余下时间处理了些琐事，可将该30min归到读书时间。若是过意不去，可在处理琐事的另一30min中省出15min去读书，弥补回来，提高统计的准确性。鼓励集中时间专心处理一件事为了统计更方便，使用者会倾向于尽可能集中时间去（至少 30min）处理一件事（或同一类事务）。避免多任务切换（三心两意同时处理多件事）导致效率下降。刚好可以配合“番茄工作法”来使用。循序渐进（日后慢慢将时间粒度定得更小）因为人的自控力差异，不一定人人都有能力去争分夺秒地利用时间。虽然现有许多可用的时间管理工具和方法，但当它们太复杂时，难免会干扰正常做事，而非更好地做事，有违 “有效利用时间” 的初衷。因为，生活节奏越慢，切换去做不同（类）任务的频率越低，可以用更大的时间粒度来规划、统计时间，当然时间使用情况的统计结果的精度会降低。事务类别事务的分类见仁见智。有些时间管理软件或方法，给出的分类过多过细，如公交、走动、购物、娱乐、上网、看电影、喝酒等，使用不便。六类事务我根据个人实际实践，将生活中的事务分为六类：编号No.简写Abbr.全称Ful.描述Desc.1学 stu学习 study积累新知识、新奇的体验，提升技能熟练度等2动 spo运动 sport锻炼身体，有一定强度的运动，正常步速、中等距离（30min内）的走动不算3读 rd阅读 read阅读/收听有益且非简单的消遣娱乐类的书籍、文章、视频等4乐 joy乐事 joy令人愉悦的事，如娱乐消遣、社交等5必 mus必须 must不得不去处理、又无法归到其它类别的事，如家务6废 was荒废 waste并非必须处理、又无益处、且不能让人愉悦的事，就是浪费时间的有些事可以同属以上多个事务类别，只能再靠个人判断将其再归类。可以简单将其归类于编号较小的类别。日志实例Log 时间使用情况统计日志以 《 15/10/20 stu52 spo12 was3 》 为例简要解释。仅解释（截止至本日志更新之日）最新的日志格式，不赘述旧格式。日志仅记录有效生活时间，即每日从早晨醒来到夜晚入睡的时间。 即24小时减去睡眠时间。 凌晨00:00后才睡觉的时候，00:00后到入睡前的部分时间本属于第二天，但是只要还没睡，该部分时间就统计到前一天的日志里去。日志标题15/10/20 stu52 spo12 was3 格式：yy/mm/dd type1 \d\d type2 \d\d … 年/月/日 事务类别1 百分比 事务类别2 百分比 (a) 事务类别：事务的类别的英文简写。(b) 百分比：某类事务所用的时长占全天有效生活时间的百分比，此处仅精确到个位。主要任务列表# Pri Tasks [y] Demand Development [ ] Evernote Scripts &amp; Shell 格式：[Y/N] task desc [完成与否] 任务的简要描述 行首的复选框代表任务的完成情况，框内 打勾/留空 表示该任务 已完成/未完成。一天很短，人的精力、体力有限，最好一段时间内只专注做一事提高效率，尽可能快速进入状态，避免多任务切换，所以任务量最好限定在1~2个，最多不超过3个。记录简表# Time Table 07-10 〇必，学学，读废，学学， 11-14 学学，动动，乐乐，学学， 15-18 学学，学学，学学，乐乐， 19-22 学学，必动，动必，读读， 23-02 学必。 简要记录全天有效生活时间内所做事务的时段、类别。格式：07-10 (a) 表示 7:00,8:00,9:00,10:00 等4个时间点，实指 08:00 ~ 11:00 这4个小时。〇必，学学，读废，学学， (b) 以上的中文字，如 “必”、“乐”，指所处时间段内所处理事务的类别。中文逗号 “，” 分隔两个时长 1h 的时间段。中文字符“〇”为占位符，指在该时间段记录者还没醒。记录细表# Time Detail to_time|type|desc|duration 0730起 0800必 内务 阅读 .5 0900学 交通 英语 读书 1 ...(略） 2200必 休息 晚餐 内务 .5 2300读 内务 听书 洗澡 思考 1 2330学 写脚本 .5 0000必 内务 .5 0000睡 详细记录全天有效生活时间内所做事务的时段、类别、简要描述、时长。格式：2200 (a) 每行行首处的4个数字，如“2200”，代表22:00（24小时制的时间），实指该行文字描述的事务结束时间。根据时间粒度的规则，它们都是整点（\d\d00）或半点（\d\d30）。2200必 休息 晚餐 内务 .5 2300读 内务 听书 洗澡 思考 1 (b) 除整个记录细表的第一行与最后一行代表醒来和睡去时间点外，每行代表一个时间段，具体时间段从前一行起始处的4个数字代表的时间点开始，到当前行行首处的4个数字代表的时间点结束。上例的第二行代表的具体时段为：20:00~23:00。(c) 每行行首的4个数字后的第一个中文字，如“读”，代表该时段所处理事务的类别；接着用空格分隔的一个或多个文字串，除了最后一个数字字串，都是对该时段所处理事务的简要描述。(d) 每行结尾处的数字串，代表该时段的时间长度，单位是小时如“.5”（0.5的简写）、“1”，实指0.5小时、1小时。纪律表# Discipline [y]早起 (0830前) [y]早餐 [y]英语 [y]运动 [ ]反省 ...（略） 格式：[Y/N] discipline_desc [遵守与否] 纪律的简要描述 日常纪律在当日的遵守情况，以及其简要描述。日统计表# Time Stat 类，时，% 学8.5，51.5 动2，12.1 读1.5，9.1 乐2，12.1 必2，12.1 废0.5，3 总16.5 各类事务的中文简写、当日各类事务的所用时长，及其占全天有效生活时间的百分比；最末行的“总16.5”，表示全天有效生活时间的长度为16.5小时。随笔记录# Diary 0910 唉，我好蠢啊！ 怎么办？ ...（略） 2344 今天很开心... 该部分位于日志的“统计表”后面，首行的4个数字“2344”表示该条记录撰写于当日23:44。第二行起，开始编写你想记录的内容，如日记、备忘、总结等任何内容。本博客的LifeLogs经过编辑，缺省了源日志的该部分内容。周 / 月 统计表周和月的时间使用情况统计日志以《2015/10 stu40 spo9 was4》为例。统计属于当月的几个周 以及整月的时间使用情况：(a) 一周从周一开始(b) 月初和月末的这两周的各天并一定全是属于当月的日子，即某周的各日横跨了两个月：&nbsp; &nbsp; I. 该周有1~3天属于当月，则该周的时间统计归到上或下一个月的“周/月统计表”中&nbsp; &nbsp; II. 该周有4~6天属于当月，则属于该周的时间统计归到当月的“周/月统计表”中(c) 月统计的时间范围从当月1日至当月最后一日，它不会像周统计那样可能会跨月进行统计！类似于 上述 6.（每日）统计表 的格式。（前 4 周略）…… Week 5 15/10/26 ~ 15/11/01 类，时，% 学55.5，46.8 动10.0，8.4 读16.0，13.5 乐10.5，8.9 必19.5，16.5 废7.0，5.9 总118.5 Monthly 2015/10 类，时，% 学206.0，39.9 动47.0，9.1 读73.5，14.2 乐85.0，16.5 必83.5，16.2 废21.5，4.2 总516.5 日程规划曾经使用过不少时间管理工具和方法，在实际使用中发现这些东西仅供参考，常常不适用于特定的个人。例如，太详细的日程规划，对一般人来说不太现实，是谓：计划常常赶不上变化。我一开始也不信邪，非要详细规划；可是在实践中，原计划只有三成左右能够如愿执行，效果不理想。大概是因为日程定得过于详细，死板不够灵活，个人自控力又不足，不懂取舍和坚持，轻易打乱原计划…于是提前规划日程成了心理安慰的行为 —— 规划时就产生了已经将日程完满执行的幻觉。所以，我还是循序渐进，慢慢提高自控力。自动化这些时间管理日志的源内容，都存在我的Evernote的笔记里面。上文中，除了记录细表、主要任务列表其它的部分如周/月统计表、记录简表、日统计表的生成以及日志标题的修改，都是通过Python和AppleScript编写的脚本完成的。这些脚本读取Evernote中的有关日志内容，根据其中的记录细表得出统计结果；再根据结果补充Evernote源日志的内容。当然还有其它脚本将这些内容推送到本博客中。有关脚本详见我的Github：on macOS操作 Evernote 用的 AppleScript 脚本操作时间管理日志用的 AppleScript 脚本操作时间管理日志用的 Python 脚本on Windows操作时间管理日志用的 PHP、Batch 脚本 （已弃用）关于时间管理我们工作是为了生活，而不是为了工作而活着。时间管理的目的，其实还是为了更好的享受生活。]]></content>
      <categories>
        <category>time mgt</category>
      </categories>
      <tags>
        <tag>time mgt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打赏博主]]></title>
    <url>%2Freward%2F</url>
    <content type="text"><![CDATA[搭建此博客期间，想到其它网站的捐赠功能，想必其实现不会太困难，于是查阅资料、动手尝试。《实现博客网站的支付宝打赏功能 —— Donate 打赏博主》记叙了本博客打赏功能的实现。博主水平有限，仅为好奇实现了该模块，若本博客对您有帮助，仍期待您的打赏~谢谢您的鼓励和支持。If you enjoy the blog, please feel free to donate~Thx for your support.window.onload=function(){$("#btn_donate").click(),$("#donate_board").parent().append($("#thx_text").html())}.donate_bar a.btn_donate{display:inline-block;width:82px;height:82px;background:url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif) no-repeat;-webkit-transition:background 0s;-moz-transition:background 0s;-o-transition:background 0s;-ms-transition:background 0s;transition:background 0s}.donate_bar a.btn_donate:hover{background-position:0 -82px}.donate_bar .donate_txt{display:block;color:#9d9d9d;font:14px/2 "Microsoft Yahei"}.bold{font-weight:700}&uarr;If you enjoy the article,please feel free todonate~Thx.若本文对您有帮助，求打赏~谢谢您的鼓励。&nbsp;&nbsp;&nbsp;&nbsp;function donate_on_web(){$("#donate").submit()}document.getElementById("btn_donate").onclick=function(){$("#donate_board").addClass("hidden"),$("#donate_guide").removeClass("hidden")};var original_window_onload=window.onload;window.onload=function(){original_window_onload&&original_window_onload(),document.getElementById("donate_board_wdg").className="hidden"}]]></content>
      <categories>
        <category>whoami</category>
      </categories>
      <tags>
        <tag>whoami</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现网站的打赏功能]]></title>
    <url>%2Fweb%2Fdonate%2F</url>
    <content type="text"><![CDATA[注意据网友 HaiSheng_Zhai 在本文评论中的反映，并经笔者简单测试后确认：下文中，以表单提交的方式，方便地用网页版 支付宝 支付的方法，已经失效。以同样方式进行网页版 PalPay 支付的方法，仍可使用。扫码打赏现在，路边摊都懂得将自己的 微信或支付宝 的 付款二维码 打印出来，粘贴到某处，方便顾客自行用扫码支付。建议采用「扫描支付宝、微信的付款二维码进行支付」的方式来实现打赏，简单易行。获得二维码将自己 微信或支付宝 的付款二维码 保存下来。它们的版本持续更新后，下文中的具体流程和文案可能与实际情况有出入。微信打开 微信（显示应用首屏）；点击 首屏右上角的加号 + ；点击 下拉菜单中的 收付款 选项；点击 我要收款 按钮；长按（iOS的方式）屏幕中央的付款二维码，下方会弹出一个菜单；可选：点击 屏幕右上角的 设置金额 ，定死单次打赏的金额；点击 从下方弹出的菜单中的 保存图片 选项；可选：使用 手机系统的截屏功能，然后再处理截屏图片。支付宝打开 支付宝（显示应用首屏）；点击 首屏右上角的加号 + ；点击 下拉菜单中的 收款 选项；可选：点击 二维码图片 正下方的 设置金额，定死单次打赏的金额；点击 二维码图片 右下方的 下载 图标按钮。发布二维码使用 Photoshop，或者手机 App 美图秀秀、Enlight 等各种工具、方法，编辑二维码图片，打造出自己喜欢的视觉效果，或简洁，或华丽。将二维码图片存放到网络上，如 图床 中。方法一、注册 七牛云存储，把二维码图片存进去，再获得其引用地址。以后可以将您需要在博客展示的图片，都存放到专门的图床（云存储）服务提供商那里，再引用；而非存放到您自己的博客服务器上，因为图床利于加快图片的加载速度。还有很多图床，可自行搜索选择。还是推荐 七牛，因为免费空间（10GB）大，方便易用，服务稳定。我只是其忠实用户，并没有收广告费。方法二、更简便的方法：把 微博 当图床。用一条微博将二维码图片发出去；在浏览器中，用右键点击微博中的该图片；点击右键菜单中的 复制图片链接 选项，就可以获得保存在新浪的二维码图片的网络地址，用于在博客引用图片。展示二维码再在博客中引用，放到合适的位置上，配上合适的文案、排版，引导访客进行打赏。带文章编辑器的博客系统，通常提供便捷的图片插入功能，可以根据具体情况自行操作。有些情况需要根据 标记语言 的语法自行输入，如：Markdown 语法：![图片替代描述](图片的 URL &quot;图片标题&quot;)图片替代描述：通常用于图片无法显示的情况，用这段文字内容来描述这张无法显示的图片。可不填。图片的 URL：上一步 发布二维码 时，获得的图片链接地址。图片标题：鼠标停留在这张图片上时，会悬浮显示的这段文字内容，会显示的文字内容。可不填。Markdown 进阶使用详见 Markdown 语法说明 (简体中文版)。简单实例：![](http://7vzp68.com1.z0.glb.clouddn.com/about/wechat_pay_00.png)详细实例：![二维码](http://7vzp68.com1.z0.glb.clouddn.com/about/wechat_pay_00.png &quot;打赏&quot;) HTML 语法：&lt;img src=&quot;图片的 URL&quot; alt=&quot;图片替代描述&quot; title=&quot;图片标题&quot; /&gt;其中各部分元素的说明，同上一点 Markdown 语法 所述。进阶使用详见 HTML &lt;img&gt; 标签。简单实例：&lt;img src=&quot;http://7vzp68.com1.z0.glb.clouddn.com/about/ali_pay_03.png&quot;&gt;详细实例：&lt;img src=&quot;http://7vzp68.com1.z0.glb.clouddn.com/about/ali_pay_03.png&quot; alt=&quot;二维码&quot; title=&quot;打赏&quot; /&gt;结尾可以看看本博客打赏模块现在的 做法和效果。可以尝试打赏博主，看看整个完整的流程~经考虑，保留本文的上一版原文，因为以下部分仍有借鉴价值：包含 PayPal 打赏 的实现方法。包含 打赏按钮 的实现方法。实际效果见原文结尾 : )上一版原文原来的支付宝钱包有一个实用的功能 「一键转账」，使用便捷，且页面看起来专业、正规，令人放心。它对业务站点而言，无疑是个福音。普通博主、站长也常将其用于捐赠和打赏。但支付宝的个人收款主页 停止服务后，支付宝已经无法实现该功能了。曲线救国 —— 新方法可以使用一个简单的表单（form 标签），通过POST一键自动填写「支付宝转账页面」的信息。方便您的访客、用户转账捐赠、打赏您。HTML 代码注意：修正其中需要您填写的部分。123456789&lt;form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="POST" target="_blank" accept-charset="GBK"&gt; &lt;input name="optEmail" type="hidden" value="你的支付宝账号" /&gt; &lt;input name="payAmount" type="hidden" value="默认的捐赠金额" /&gt; &lt;input id="title" name="title" type="hidden" value="默认显示的付款说明" /&gt; &lt;input name="memo" type="hidden" value="备注" /&gt; &lt;input name="pay" type="image" value="转账" src="https://img.alipay.com/sys/personalprod/style/mc/btn-index.png" /&gt;&lt;/form&gt;显示效果 Reference 参考资料《博客网站支付宝打赏功能》笔者的自定义的“打赏”按钮HTML 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- 打赏表单 --&gt;&lt;form id="donate" action="https://shenghuo.alipay.com/send/payment/fill.htm" method="POST" target="_blank" accept-charset="GBK" style="display: none;"&gt; &lt;input name="optEmail" type="hidden" value="您的支付宝账号" /&gt; &lt;input name="payAmount" type="hidden" value="默认的打赏金额" /&gt; &lt;input id="title" name="title" type="hidden" value="默认显示的付款说明" /&gt; &lt;input name="memo" type="hidden" value="备注" /&gt;&lt;/form&gt;&lt;!-- /打赏表单 --&gt;&lt;!-- 打赏按钮的样式表 --&gt;&lt;style type="text/css"&gt; .donate_bar a.btn_donate&#123; display: inline-block; width: 82px; height: 82px; background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; _background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; &#125; .donate_bar a.btn_donate:hover&#123; background-position: 0px -82px;&#125; .donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px/2 "Microsoft Yahei"; &#125;&lt;/style&gt;&lt;!-- /打赏按钮的样式表 --&gt;&lt;!-- 打赏按钮 --&gt;&lt;div class="donate_bar"&gt; &lt;a class="btn_donate" href="javascript:;" title="Donate 打赏" onclick="document.getElementById('donate').submit()"&gt;&lt;/a&gt; &lt;span class="donate_txt"&gt; &amp;uarr;&lt;br/&gt; If you enjoy the blog, please feel free to donate~ Thx for your support. &lt;/span&gt; &lt;span class="donate_txt"&gt; 若本文对您有帮助，求打赏~ 谢谢您的支持和鼓励。 &lt;/span&gt;&lt;/div&gt;&lt;!-- /打赏按钮 --&gt;进阶的 “打赏” 按钮本博客的打赏按钮的实际代码根据需求不断进行调整，最后更新的版本如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!-- Donate Module --&gt;&lt;div id="donate_module"&gt; &lt;!-- css --&gt; &lt;style type="text/css"&gt; .donate_bar a.btn_donate&#123; display: inline-block; width: 82px; height: 82px; background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; _background: url("http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif") no-repeat; &lt;!-- 因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果， 为了在让打赏按钮显示效果正常 而 添加了以下几行 css， 嵌入其它博客时不一定要它们。 --&gt; -webkit-transition: background 0s; -moz-transition: background 0s; -o-transition: background 0s; -ms-transition: background 0s; transition: background 0s; &lt;!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 --&gt; &#125; .donate_bar a.btn_donate:hover&#123; background-position: 0px -82px;&#125; .donate_bar .donate_txt &#123; display: block; color: #9d9d9d; font: 14px/2 "Microsoft Yahei"; &#125; .bold&#123; font-weight: bold; &#125; &lt;/style&gt; &lt;!-- /css --&gt; &lt;!-- form --&gt; &lt;form id="donate" action="https://shenghuo.alipay.com/send/payment/fill.htm" method="POST" target="_blank" accept-charset="GBK"&gt; &lt;input name="optEmail" type="hidden" value="ice_he@foxmail.com" /&gt; &lt;input name="payAmount" type="hidden" value="1.00" /&gt; &lt;input id="title" name="title" type="hidden" value="打赏《&lt;%= item.title.substr(0, 16) %&gt;》"/&gt; &lt;input name="memo" type="hidden" value="留下您的大名及联系方式(email,blog,etc)，多交流共勉共进：" /&gt; &lt;/form&gt; &lt;!-- /form --&gt; &lt;!-- btn_donate &amp; tips --&gt; &lt;div id="donate_board" class="donate_bar center"&gt; &lt;a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"&gt;&lt;/a&gt; &lt;span class="donate_txt"&gt; &amp;uarr;&lt;br/&gt; If you enjoy the article, please feel free to &lt;span class="bold"&gt;donate~&lt;/span&gt; Thx.&lt;br/&gt; 若本文对您有帮助，&lt;span class="bold"&gt;求打赏~&lt;/span&gt; 谢谢您的鼓励。 &lt;/span&gt; &lt;br/&gt; &lt;/div&gt; &lt;!-- /btn_donate &amp; tips --&gt; &lt;!-- donate guide --&gt; &lt;div id="donate_guide" class="donate_bar center hidden"&gt; &lt;form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"&gt; &lt;input type="hidden" name="cmd" value="_s-xclick"&gt; &lt;input type="hidden" name="hosted_button_id" value="3MPNAMMQA4C8Y"&gt; &amp;nbsp; &amp;nbsp; &lt;input type="image" width="auto" height="40em" src="http://7vzp68.com1.z0.glb.clouddn.com/about/palpay_donate_button_00.jpg" border="0" name="submit" alt="PayPal——最安全便捷的在线支付方式！" style="margin-bottom: 0.5em;"&gt; &lt;/form&gt; &lt;a href="http://7vzp68.com1.z0.glb.clouddn.com/about/ali_pay_02.jpg" title="Alipay_Scan_Payment" class="fancybox" rel="article0"&gt; &lt;img src="http://7vzp68.com1.z0.glb.clouddn.com/about/ali_pay_02.jpg" title="Donate 打赏" height="164px" width="164px"/&gt; &lt;/a&gt; &amp;nbsp; &lt;a href="http://7vzp68.com1.z0.glb.clouddn.com/about/avatar_04.jpg" title="Alipay_Scan_Payment" class="fancybox" rel="article0"&gt; &lt;img src="http://7vzp68.com1.z0.glb.clouddn.com/about/avatar_04.jpg" title="Thanks 谢谢~" height="164px" width="164px"/&gt; &lt;/a&gt; &amp;nbsp; &lt;a href="http://7vzp68.com1.z0.glb.clouddn.com/about_original/wechat_pay_01.jpg" title="WeChat_Scan_Payment" class="fancybox" rel="article0"&gt; &lt;img src="http://7vzp68.com1.z0.glb.clouddn.com/about_original/wechat_pay_01.jpg" title="Donate 打赏" height="164px" width="auto"/&gt; &lt;/a&gt; &lt;span class="donate_txt"&gt; Use App &lt;span class="bold"&gt;&lt;a href="http://global.alipay.com/ospay/home.htm"&gt;Alipay&lt;/a&gt; / &lt;a href="http://www.wechat.com/en/"&gt;WeChat&lt;/a&gt;&lt;/span&gt; to scan QRCode~ Thx for your support.&lt;br/&gt; 用手机 &lt;span class="bold"&gt;&lt;a href="https://mobile.alipay.com/index.htm"&gt;支付宝钱包&lt;/a&gt; / &lt;a href="http://weixin.qq.com/"&gt;微信&lt;/a&gt;&lt;/span&gt;， 扫一扫即可~ 谢谢您的鼓励。&lt;br/&gt; &lt;br/&gt; Or donate on &lt;a id="donate_on_web2" class="bold" href="javascript:donate_on_web();" title="Donate 打赏"&gt;Web Alipay&lt;/a&gt;. / 也可用 &lt;a id="donate_on_web1" class="bold" href="javascript:donate_on_web();" title="Donate 打赏"&gt;网页版支付宝&lt;/a&gt; 打赏。&lt;br/&gt; &lt;/span&gt; &lt;br/&gt; &lt;/div&gt; &lt;!-- /donate guide --&gt; &lt;!-- donate script --&gt; &lt;script type="text/javascript"&gt; document.getElementById('btn_donate').onclick = function()&#123; $('#donate_board').addClass('hidden'); $('#donate_guide').removeClass('hidden'); &#125; function donate_on_web()&#123; $('#donate').submit(); &#125; &lt;/script&gt; &lt;!-- /donate script --&gt;&lt;/div&gt;&lt;!-- /Donate Module --&gt;实际效果以下是本博客打赏按钮的显示效果，点击可以打赏博主哦~.donate_bar a.btn_donate{display:inline-block;width:82px;height:82px;background:url(http://img.t.sinajs.cn/t5/style/images/apps_PRF/e_media/btn_reward.gif) no-repeat;-webkit-transition:background 0s;-moz-transition:background 0s;-o-transition:background 0s;-ms-transition:background 0s;transition:background 0s}.donate_bar a.btn_donate:hover{background-position:0 -82px}.donate_bar .donate_txt{display:block;color:#9d9d9d;font:14px/2 "Microsoft Yahei"}.bold{font-weight:700}&uarr;If you enjoy the article,please feel free todonate~Thx.若本文对您有帮助，求打赏~谢谢您的鼓励。&nbsp;&nbsp;&nbsp;&nbsp;Use AppAlipay/WeChatto scan QRCode~Thx for your support.用手机支付宝钱包/微信，扫一扫即可~谢谢您的鼓励。Or donate onWeb Alipay./也可用网页版支付宝打赏。function donate_on_web(){$("#donate").submit()}document.getElementById("btn_donate").onclick=function(){$("#donate_board").addClass("hidden"),$("#donate_guide").removeClass("hidden")};var original_window_onload=window.onload;window.onload=function(){original_window_onload&&original_window_onload(),document.getElementById("donate_board_wdg").className="hidden"}]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 15]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2015%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社附注1 Intel系列微处理器的3种工作模式重要版本8086/8088、80386。80386具备了80286对多任务系统的支持，又对8086/8088兼容。它可以在以下3个模式下工作：（1）实模式：工作方式相当于一个8086（2）保护模式：提供支持多任务环境的工作方式，&nbsp; &nbsp; &nbsp;建立爆出机制（这与VAX等小型机类似）。（3）模拟8086模式：可从保护模式切换至其中的一种8086工作方式。&nbsp; &nbsp; &nbsp;这种方式的提供使用户可以方便地在保护模式下运行一个或多个原8086程序。PC一开机，处于实模式。DOS处于实模式。Windows系统在加载后，会将CPU切换到保护模式。在Windows下运行一个DOS下的程序，CPU切换至模拟8086模式下运行该程序。附注2 补码特别注意点：1000 0000b = -128附注3 汇编编译器（masm.exe）对jmp的相关处理1. 向前转移先读到标号，后读到jmp指令s: &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp; &nbsp;...&nbsp; &nbsp; &nbsp;jmp s（jmp short s / jmp near ptr s / jmp far ptr s）编译器中有一个地址计数器（AC），编译过程中，每读到一字节，AC+=1。当编译器遇到一些伪操作时，如db / dw等，会根据实际情况使AC增加。向前转移时，complier读到 标号s 后，记下此时AC的值为 as（annotation start？），在读到 jmp &nbsp;... s 后，记下此时AC的值为 aj（annotation jmp？）。那么可以通过 as - aj&nbsp;算出位移值 disp。（1）若disp属于[-128, 127]，这不管汇编指令格式是：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp s / jmp short s / jmp near ptr s / jmp far ptr s&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 都会转变为 jmp short s 所对应的机器码：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EB disp（占 2 Bytes）；（2）若disp属于[-32768, 32767]，则：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于 jmp short 将产生编译错误；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于 jmp s、jmp near ptr s，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;将产生jmp near ptr s 所对应的机器码：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;E9 disp（占 3 Bytes）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于 jmp far ptr s，将产生对应的机器码：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EA 偏移地址 段地址（占 5 Bytes）。2.向后转移：先读到jmp指令，后读到标号&nbsp; &nbsp; &nbsp;jmp s（jmp short s / jmp near ptr s / jmp far ptr s）&nbsp; &nbsp; &nbsp; &nbsp;...s: &nbsp; &nbsp; ...在此情况下，complier先读到 jmp ... s 指令，由于还没读到 标号s，所以不能确定 其位置的AC值，即不能确定 disp 值。此时，complier将 jmp ... s 都当作 jmp short s 来读取，记下jmp指令的位置和AC的值作为 aj（annotation jmp？），并作以下处理：a. 对于 jmp short s，complier生成&nbsp;EB 和 一个 nop 指令，&nbsp; &nbsp; &nbsp;即用 nop 预留 1 Byte&nbsp;空间，存放 8 bits 的disp。b. 对于 jmp s 和 jmp near ptr s，生成&nbsp;E9&nbsp;和 两个 nop 指令，&nbsp; &nbsp; &nbsp;即&nbsp;预留 2 Bytes，放 16 bits 的disp。c. 对于 jmp far ptr s， 生成 EA&nbsp;和 四个 nop 指令，&nbsp; &nbsp; &nbsp;即 预留 4 Bytes，放&nbsp;段地址 和&nbsp;段地址。以上处理完后，当向后读到 标号s 时，记下此时AC的值作为 as（annotation start？），并计算出转移的位移量：disp = as - aj（公式与向前转移相同）。（1）若disp属于[-128, 127]，这不管汇编指令格式是：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp s / jmp short s / jmp near ptr s / jmp far ptr s&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;都在前面记下的 jmp ... s 指令位置处添上&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp short s对应的机器码：EB disp&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *注意：此时，对于&nbsp;jmp s 和 jmp near ptr s 格式，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在机器码 EB disp 后还有 1 条 nop 指令（空着）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;对于jmp far ptr s，在机器码EB disp后还有3条nop指令（空着）。（2）若disp属于[-32768, 32767]，则：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于&nbsp;jmp short&nbsp;将产生编译错误；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于&nbsp;jmp s、jmp near ptr s，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在前面记下的 jmp ... s 指令位置处添上&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp near ptr s对应的机器码：E9 disp（占 3 Bytes）；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对于&nbsp;jmp far ptr s，在前面记下的 jmp ... s 指令位置处添上&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;EA 偏移地址 段地址（占 5 Bytes）。附注4 用栈传递参数此技术和高级语言编译器的工作原理密切相关，结合C语言的函数调用来描述。栈传递参数原理：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中去取得参数。（例）;说明：计算(a-b)^3，a、b为字型数据;参数：进入子程序时，栈顶存放IP，后面依次存放a、b;结果：(dx:ax)=(a-b)^3dif_cube:&nbsp; &nbsp; &nbsp;push bp&nbsp; &nbsp; &nbsp;mov bp, sp&nbsp; &nbsp; &nbsp;mov ax, [bp + 4] &nbsp; &nbsp; ;后入栈的是a&nbsp; &nbsp; &nbsp;sub ax, [bp + 6] &nbsp; &nbsp; ;先入栈的是b&nbsp; &nbsp; &nbsp;mov bp, ax&nbsp; &nbsp; &nbsp;mul bp&nbsp; &nbsp; &nbsp;mul bp&nbsp; &nbsp; &nbsp;pop bp&nbsp; &nbsp; &nbsp;ret 4一个子程序结尾有：ret nn为整数，意思是，将栈顶指针修改为调用前的值。ret n 功能等于&nbsp;pop ip &nbsp; &nbsp;&nbsp;add sp, n调用dif_cube程序的代码如下：mov ax, 1 &nbsp; &nbsp; ;bpush axmov ax, 3 &nbsp; &nbsp; ;apush axcall diff_cube &nbsp; &nbsp; ;注意参数压栈的顺序1.语句call diff_cube后，栈的情况： &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IP &nbsp; &nbsp; &nbsp;a &nbsp; &nbsp; &nbsp; &nbsp;b1000:0000 &nbsp; &nbsp; 00 00&nbsp;00 00&nbsp;00 00&nbsp;00 00 |&nbsp;00 00 XX XX 03 00 01 00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;↑ ss:sp2.dif_cube执行第1句push bp后：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bp &nbsp; &nbsp; &nbsp;IP &nbsp; &nbsp; &nbsp; a &nbsp; &nbsp; &nbsp; b1000:0000 &nbsp; &nbsp; 00 00&nbsp;00 00&nbsp;00 00&nbsp;00 00 | ZZ ZZ XX XX 03 00 01 00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ↑ ss:sp3.所以，dif_cube 子程序以下语句中的 [bp + 4]指 a，[bp + 6]指 b。mov ax, [bp + 4] &nbsp; &nbsp; ;后入栈的是asub ax, [bp + 6] &nbsp; &nbsp; ;先入栈的是b利用C程序，了解栈在参数传递中的应用：*.注意：在C语言中，局部变量也在栈中存储。void add(int, int, int);main(){&nbsp; &nbsp; &nbsp;int a = 1;&nbsp; &nbsp; &nbsp;int b = 2;&nbsp; &nbsp; &nbsp;int c = 0;&nbsp; &nbsp; &nbsp;add(a, b, c);&nbsp; &nbsp; &nbsp;c++;}void add(int a, int b, int c){&nbsp; &nbsp; &nbsp;c = a + b;}编译后的汇编程序：mov bp, sp &nbsp; &nbsp; ;bp = 原栈顶位置 spsub sp, 6 &nbsp; &nbsp; ;栈顶sp - 6，留出空间存放数据段？mov word ptr [bp - 6], 0001 &nbsp; &nbsp; ;int amov word ptr [bp - 4], 0002 &nbsp; &nbsp; ;int bmov word ptr [bp - 2], 0000 &nbsp; &nbsp; ;int cpush [bp - 2] &nbsp; &nbsp; ;push cpush [bp - 4] &nbsp; &nbsp; ;push bpush [bp - 6] &nbsp; &nbsp; ;push acall ADDRadd sp, 6 &nbsp; &nbsp; ;sp恢复回原栈顶top的位置？inc word ptr [bp - 2]ADDR:&nbsp; &nbsp; &nbsp;push bp&nbsp; &nbsp; &nbsp;mov bp, sp &nbsp; &nbsp; ;这里的bp = 新栈顶位置 sp&nbsp; &nbsp; &nbsp;mov ax, [bp + 4] &nbsp; &nbsp; ;b&nbsp; &nbsp; &nbsp;add ax, [bp + 6] &nbsp; &nbsp; ;a? &nbsp; &nbsp;（有点蒙？这里我画图理解，放的应该是c？淡忘之后再分析一次）&nbsp; &nbsp; &nbsp;mov [bp + 8], ax&nbsp; &nbsp; &nbsp;mov sp, bp&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;;栈的情况：a b c | a b c&nbsp; &nbsp; &nbsp;; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;↑top=bp&nbsp; &nbsp; &nbsp;;左边abc是压入的参数，右边abc是其源&nbsp; &nbsp; &nbsp;pop bp&nbsp; &nbsp; &nbsp;ret附注5 （无溢出除法）公式证明无溢出除法公式：H：x的高16位L：x的低16位int()：取商rem()：取余H = int( x / 65536) &nbsp; &nbsp; ; 即 H = x / 0FFFFHL = rem( x / 65536) &nbsp; &nbsp; ; 即 L = x % 0FFFFHX / n = int(H / n) * 65536 + [rem(H / n) * 65536 + L] / n&nbsp; &nbsp; &nbsp;;乘以65536，等于左移16位&nbsp; &nbsp; &nbsp;;1.被除数x的高16位，除以除数n得到，x/n的商的高16位；&nbsp; &nbsp; &nbsp;;2.被除数x的高16位，除以除数n得到的余， 加上被除数x的低16位，&nbsp; &nbsp; &nbsp;; &nbsp; 除以除数n得到，x/n的商的低16位。综合研究（因为寻找适用的tc.exe无果，此部分暂且放弃）研究实验1 搭建一个精简的C语言开发环境研究实验2 使用寄存器研究实验3&nbsp;使用内存空间研究实验4&nbsp;不用main函数编程研究实验5&nbsp;函数如何接收]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 14]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2014%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十七、使用BIOS进行键盘输入和磁盘读写键盘输入：最基本的输入磁盘：最常用的储存设备BIOS：为以上两种外设提供了最基本的中断例程17.1 int 9 中断例程对键盘输入的处理一般键盘输入，在CPU执行完int 9中断例程后，都放到键盘缓冲区中。键盘缓冲区有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。键盘缓冲区使用环形队列结构管理的内存区。int 9 中断例程对键盘输入的处理方法：17.2 使用 int 16h 中断例程读取键盘缓冲区BIOS 提供了 int 16h 中断例程，它包含功能：从键盘缓冲区中读取一个键盘输入，功能编号为0。（例）mov ah, 0int 16h结果：(ah)=扫描码，(al)=ASCII码。功能：（1）检测键盘缓冲区是否有数据；（2）没有则重复第一步（3）读取缓冲区第一个字单元的键盘输入；（4）将读取的扫描码送入ah，ASCII码送入al；（5）将已读取的键盘输入从缓冲区中删除。*. 具体例子，请看原书P303可见，BIOS的int 9 和 int 16h中断例程是一对相互配合的程序。int 9 向缓冲区写，int 16h 从缓冲区读，但调用时机不同。int 9 在键按下时，它就写入；int 16h 则是被应用程序调用时，它才去读。编程：接收用户的键盘输入，输入r，将屏幕字符设置为红色；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; g则设为绿色； b则设为蓝色。源码：assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; int 16h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 1&nbsp;&nbsp;&nbsp;&nbsp; cmp al, &apos;r&apos;&nbsp;&nbsp;&nbsp;&nbsp; je red&nbsp;&nbsp;&nbsp;&nbsp; cmp al, &apos;g&apos;&nbsp;&nbsp;&nbsp;&nbsp; je green&nbsp;&nbsp;&nbsp;&nbsp; cmp al, &apos;b&apos;&nbsp;&nbsp;&nbsp;&nbsp; je blue&nbsp;&nbsp;&nbsp;&nbsp; jmp short sretred:&nbsp;&nbsp;&nbsp;&nbsp; shl ah, 1green:&nbsp;&nbsp;&nbsp;&nbsp; shl ah, 1blue:&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000c0:&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr es:[bx], 11111000b&nbsp;&nbsp;&nbsp;&nbsp; or es:[bx], ah&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp;sret:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start17.3 字符串的输入最基本的字符串输入程序，需具备以下功能：（1）在输入的同时需要显示这个字符串；（2）一般在输入回车符后，字符串输入结束；（3）能够删除已经输入的字符。编程：实现以上3个基本功能，参数如下——&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dh)、(dl)=字符串在屏幕上显示的行、列位置；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ds:si指向字符串的储存空间，字符串以0为结束符。实现思路：详看原书P304~305处理过程：（1）调用int 16h 读取键盘输入（2）若是字符，入栈，显示栈中所有字符；继续执行（1）；（3）若是退格键，一个字符出栈，显示栈中所有字符；继续执行（2）；（4）若是Enter键，向栈压入0，返回。源码：&nbsp; &nbsp; &nbsp;其中子程序charstack的子程序的参数说明：&nbsp; &nbsp; &nbsp;(ah)=功能号，0表示入栈，1表示出栈，2表示显示；&nbsp; &nbsp; &nbsp;ds:si指向字符栈空间；&nbsp; &nbsp; &nbsp;入栈：(al)=入栈字符；&nbsp; &nbsp; &nbsp;出站：(al)=出栈返回的字符；&nbsp; &nbsp; &nbsp;显示：(dh)、(dl)=字符串在屏幕上显示的行、列位置。assume cs:codestack segment&nbsp;&nbsp;&nbsp;&nbsp; db 64 dup (0)stack endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, stack&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp; ;ds:si指向charstack的字符栈空间&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 0&nbsp;&nbsp;&nbsp;&nbsp; ;显示在第0行&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 0&nbsp;&nbsp;&nbsp;&nbsp; ;显示在第0列&nbsp;&nbsp;&nbsp;&nbsp; call getstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;getstr:&nbsp;&nbsp;&nbsp;&nbsp; push axgetstrs:&nbsp;&nbsp;&nbsp;&nbsp; ;获取键盘输入&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; int 16h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 20h&nbsp;&nbsp;&nbsp;&nbsp; jb not_char&nbsp;&nbsp;&nbsp;&nbsp; ;ASCII码小于20h，说明不是字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; ;调用charstack的0号子程序&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;字符入栈&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; ;调用charstack的2号子程序&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;显示栈中的字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp getstrsnot_char:&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 0eh&nbsp;&nbsp;&nbsp;&nbsp; ;退格键的扫描码&nbsp;&nbsp;&nbsp;&nbsp; je backspace&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 1ch&nbsp;&nbsp;&nbsp;&nbsp; ;回车键的扫描码&nbsp;&nbsp;&nbsp;&nbsp; je enter_btn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp getstrsbackspace:&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 1&nbsp;&nbsp;&nbsp;&nbsp; ;调用charstack的1号子程序&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;字符出栈&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; ;类同上&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;显示栈中的字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp getstrs&nbsp;&nbsp;&nbsp;&nbsp;enter_btn:&nbsp;&nbsp;&nbsp;&nbsp; mov al, 0&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;0入栈&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; call charstack&nbsp;&nbsp;&nbsp;&nbsp; ;显示栈中字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;charstack:&nbsp;&nbsp;&nbsp;&nbsp; jmp short&nbsp; charstarttable&nbsp;&nbsp;&nbsp;&nbsp; dw charpush, charpop, charshowtop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dw 0&nbsp;&nbsp;&nbsp;&nbsp; ;栈顶&nbsp;&nbsp;&nbsp;&nbsp;charstart:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 2&nbsp;&nbsp;&nbsp;&nbsp; ja sret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; mov bl, ah&nbsp;&nbsp;&nbsp;&nbsp; add bx, bx&nbsp;&nbsp;&nbsp;&nbsp; jmp word ptr table[bx]&nbsp;&nbsp;&nbsp;&nbsp;charpush:&nbsp;&nbsp;&nbsp;&nbsp; mov bx, top&nbsp;&nbsp;&nbsp;&nbsp; mov ds:[si][bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc top&nbsp;&nbsp;&nbsp;&nbsp; jmp sretcharpop:&nbsp;&nbsp;&nbsp;&nbsp; cmp top, 0&nbsp;&nbsp;&nbsp;&nbsp; je sret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec top&nbsp;&nbsp;&nbsp;&nbsp; mov bx, top&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si][bx]&nbsp;&nbsp;&nbsp;&nbsp; jmp sret&nbsp;&nbsp;&nbsp;&nbsp;charshow:&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; mov al, 160&nbsp;&nbsp;&nbsp;&nbsp; mul dh&nbsp;&nbsp;&nbsp;&nbsp; ;dh：显示在第几行&nbsp;&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add dl, dl&nbsp;&nbsp;&nbsp;&nbsp; ;dl：显示在第几列&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 0&nbsp;&nbsp;&nbsp;&nbsp; add di, dx&nbsp;&nbsp;&nbsp;&nbsp; ;di：对应的显示缓冲区的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;charshows:&nbsp;&nbsp;&nbsp;&nbsp; cmp bx, top&nbsp;&nbsp;&nbsp;&nbsp; jne not_empty&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; jmp sretnot_empty:&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si][bx]&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], al&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di + 2], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; ;设置下一个显示位为空&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; jmp charshowssret:&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp; pop dx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十七章17.3例.asm17.4 应用 int 13h 中断例程对磁盘进行读写以3.5英寸软盘为例讲解（无法测试，只能做简单的笔记）。3.5英寸软盘：2面 * 80磁道 * 18扇区 * 512字节 = 1440KB ≈ 1.44MBint 13h 入口参数：(ah)=int 13h的功能号&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2：读扇区；3：写扇区(al)=读/写的扇区数(ch)=磁道号(cl)=扇区号(dh)=磁头号（对于软盘即面号,因为一个面用一个磁头来读写）(dl)=驱动器号 &nbsp; &nbsp; 软驱从0开始，0：软驱A，1：软驱B；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;硬盘从80h开始，80h：硬盘C，81h：硬盘Des:bx 指向接受从扇区读入数据的内存区。返回参数：操作成功：(ah)=0，(al)=读/写的扇区数操作失败：(ah)=出错代码实验17 编写包含多个功能子程序的中断例程以3.5英寸软盘为对象编写（无法测试，只能简单描述题目）。课程设计2(完成并不现实：因为当前使用电脑CPU为64位，&nbsp; &nbsp; &nbsp;而非16位的8086CPU，即使编写的汇编程序也无法测试)]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 13]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2013%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十六、直接定址表16.1 描述了单元长度的标号——数据标号（1）以下程序中，code、a、b、start、s（后面带冒号“:”）都是地址标号，仅表示内存单元的地址。assume cs:codecode segmenta:&nbsp;&nbsp;&nbsp;&nbsp; db 1, 2, 3, 4, 5, 6, 7, 8b:&nbsp;&nbsp;&nbsp;&nbsp; dw 0start:&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset a&nbsp;&nbsp;&nbsp;&nbsp; mov bx, offset b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 8c0:&nbsp;&nbsp;&nbsp;&nbsp; mov al, cs:[si]&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; add cs:[bx], ax&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start（2）另一种——数据标号不但表示内存单元的地址，还表示其长度，无论是byte/word/dword。如以下程序中的a、b标号，后面没跟“:”冒号。assume cs:codecode segmenta&nbsp;&nbsp;&nbsp;&nbsp; db 1, 2, 3, 4, 5, 6, 7, 8b&nbsp;&nbsp;&nbsp;&nbsp; dw 0start:&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 8c0:&nbsp;&nbsp;&nbsp;&nbsp; mov al, cs:[si]&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; add b, ax&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start以上a、b这种标号的使用示例如下：mov ax, b &nbsp; &nbsp; = &nbsp; &nbsp; mov ax, cs:[8]mov b, 2 &nbsp; &nbsp; &nbsp;= &nbsp; &nbsp; mov word ptr cs:[8]inc b &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= &nbsp; &nbsp; inc word ptr cs:[8]mov al, a[si] &nbsp; &nbsp; = &nbsp; &nbsp; mov al, cs:0[si]mov al, a[3] &nbsp; &nbsp; &nbsp;= &nbsp; &nbsp; mov al, cs:0[3]这句会引发编译错误！—— mov al, b 或 mov b, al检测点1.6将a处的8个数据累加，结果存储到b处的双字中，补全程序。assume cs:codecode segmenta&nbsp;&nbsp;&nbsp;&nbsp; dw 0fff1h, 0fff2h, 0fff3h, 0fff4h, 0fff5h, 0fff6h, 0fff7h, 0fff8hb&nbsp;&nbsp;&nbsp;&nbsp; dd 0start:&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 8c0:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, a:[si]&nbsp; &nbsp; &nbsp;;下一句可简化为&nbsp;add word ptr b, ax&nbsp;&nbsp;&nbsp;&nbsp; add word ptr b[0], ax &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc word ptr b[2], 0&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start16.2 在其它段中，使用数据标号地址标号（带冒号后缀）：只能在代码段中使用，不能在其它段使用。&nbsp; &nbsp; &nbsp;&gt;&gt;assume的作用：若想在代码段中直接用数据标号访问数据，则需要用伪指令assume，将标号所在的段和段寄存器联系起来。否则编译时，无法确定标号的段地址在哪一个寄存器中。（下文实例详细说明）此种联系是编译器需要的，但段寄存器实际上不一定会真的存放该段的地址。还要用指令对段寄存器进行设置。（例）assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp; a db 1, 2, 3, 4, 5, 6, 7, 8&nbsp;&nbsp;&nbsp;&nbsp; b dw 0data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 8c0:&nbsp;&nbsp;&nbsp;&nbsp; mov al, a[si]&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; add b, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start已有assume ..., ds:data但是还要mov ax, datamov ds, ax然后以下就是assume ds:data对编译实际的影响：mov al, a[si] 编译为 mov al, [si+0]add b, ax 编译为 add [8], ax当删除以上源程序中assume ..., ds:data中的ds:data后，用masm编译时，会产生错误，报错信息如下：t.asm(14)是这一句：mov al, a[si]编译程序不知道标号在哪里了！当然可将以下语句移到 code segment（段）中，就可顺利编译，但原理必须明白！：&nbsp; &nbsp; &nbsp;a db 1, 2, 3, 4, 5, 6, 7, 8&nbsp;&nbsp;&nbsp;&nbsp; b dw 0标号可以作为数据来定义！data segment&nbsp; &nbsp; &nbsp;a db 1, 2, 3, 4, 5, 6, 7, 8&nbsp;&nbsp;&nbsp;&nbsp; b dw 0&nbsp; &nbsp; &nbsp;c dw a, b &nbsp; &nbsp; ;相当于 c dw offset a, offset b&nbsp; &nbsp; &nbsp;d dd a, b &nbsp; &nbsp; ;相当于 d dw offset a, seg a, offset b, seg bdata ends16.3 直接定址表根据我的理解，就像数组。实例如下：assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 2bh&nbsp;&nbsp;&nbsp;&nbsp; call showbyte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;showbyte:&nbsp;&nbsp;&nbsp;&nbsp; jmp short show&nbsp;&nbsp;&nbsp;&nbsp; table db &apos;0123456890ABCDEF&apos;&nbsp;&nbsp;&nbsp;&nbsp; ;字符表show:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, al;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 4&nbsp;&nbsp;&nbsp;&nbsp; shr ah, cl&nbsp;&nbsp;&nbsp;&nbsp; ;ah得到原al的高4位&nbsp;&nbsp;&nbsp;&nbsp; and al, 00001111b&nbsp;&nbsp;&nbsp;&nbsp; ;al得到原al的低4位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bl, ah&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; mov ah, table[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov es:[160 * 12 + 40 * 2], ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bl, al&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; mov al, table[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:[160 * 12 + 40 * 2 + 2], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; retcode endsend start在以上程序中，我们在（1byte大小的）数值&nbsp;0~15和 字符 “0” ~ “F”（16进制表示法）之间建立的映射关系为：以数值N为table表中的偏移，可以找到对应字符。利用表，建立两个数据集之间的一种映射关系，根据给出的数据，得到另一数据集对应的数据，目的是：（1）为了算法的清晰和简洁；（2）加快运算速度；（3）使程序易于扩充。编程：写一个子程序，计算sin(x)，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x属于{0, 30, 60, 90, 120, 150, 180}集合（单位：度）。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如，sin(30)结果显示为“0.5”。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov al, 255&nbsp;&nbsp;&nbsp;&nbsp; call showsin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;showsin:&nbsp;&nbsp;&nbsp;&nbsp; jmp short show&nbsp;&nbsp;&nbsp;&nbsp; ;字符串偏移地址表&nbsp;&nbsp;&nbsp;&nbsp; table dw s0, s30, s60, s90, s120, s150, s180&nbsp;&nbsp;&nbsp;&nbsp; s0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0.5&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0.866&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db &apos;1&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s120&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0,866&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s150&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0.5&apos;, 0&nbsp;&nbsp;&nbsp;&nbsp; s180&nbsp;&nbsp;&nbsp;&nbsp; db &apos;0&apos;, 0show:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp; push si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;以下用“角度值/30”作为table的偏移，&nbsp;&nbsp;&nbsp;&nbsp; ;取得对应字符串的偏移地址，置于bx中&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp;&nbsp;&nbsp; mov bl, 30&nbsp;&nbsp;&nbsp;&nbsp; div bl&nbsp;&nbsp;&nbsp;&nbsp; mov bl, al&nbsp;&nbsp;&nbsp;&nbsp; ;高字节ah存余，低字节al存商&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; add bx, bx&nbsp;&nbsp;&nbsp;&nbsp; ;偏移地址为word型，以bx * 2以对应地址&nbsp;&nbsp;&nbsp;&nbsp; mov bx, table[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;以下显示sin(x)对应的字符串&nbsp;&nbsp;&nbsp;&nbsp; mov si, 160 * 12 + 40 * 2shows:&nbsp;&nbsp;&nbsp;&nbsp; mov ah, cs:[bx]&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 0&nbsp;&nbsp;&nbsp;&nbsp; je ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:[si], ah&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; jmp short shows&nbsp;&nbsp;&nbsp;&nbsp;ok:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop si&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; retcode endsend start角度值没有检测，可能超范围（0~180），真实编程需要检测。Att - 汇编语言第十六章16.3例.asm16.4 程序入口地址的直接定址表可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。编程：实现一个子程序setscreen，为显示输出提供如下功能：（1）清屏；（2）设置前景色；（3）设置背景色；（4）向上滚动一行。入口参数说明如下：a. 用ah寄存器传递功能号：&nbsp; &nbsp; &nbsp;0表示以上功能（1）清屏，&nbsp; &nbsp; &nbsp;1表示（2），2表示（3），3表示（4）。b. 对于功能（2）、（3），用al传递颜色值，&nbsp; &nbsp; &nbsp;(al)属于{0, 1, 2, 3, 4, 5, 6, 7}范围。下面是实现思路：（1）清屏：将屏幕字符设置为空格；（2）前景色：设置屏幕字符属性字节的第0、1、2位；（3）背景色：设置屏幕字符属性字节的第4、5、6位；（4）向上滚一行：依次将第n + 1行复制到第n行处，最后一行置空。源代码：assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 3&nbsp;&nbsp;&nbsp;&nbsp; mov al, 3&nbsp;&nbsp;&nbsp;&nbsp; call setscreen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;setscreen:&nbsp;&nbsp;&nbsp;&nbsp; jmp short set&nbsp;&nbsp;&nbsp;&nbsp; table dw sub1, sub2, sub3, sub4set:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 3&nbsp;&nbsp;&nbsp;&nbsp; ja sret&nbsp;&nbsp;&nbsp;&nbsp; mov bl, ah&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; add bx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call word ptr table[bx]&nbsp;&nbsp;&nbsp;&nbsp; ;调用对应的功能子程序sret:&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub1:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000sub1c0:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[bx], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub1c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;sub2:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000sub2c0:&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr es:[bx], 11111000b&nbsp;&nbsp;&nbsp;&nbsp; or es:[bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub2c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub3:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 4&nbsp;&nbsp;&nbsp;&nbsp; shl al, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000sub3c0:&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr es:[bx], 10001111b&nbsp;&nbsp;&nbsp;&nbsp; or es:[bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub3c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub4:&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push ds&nbsp;&nbsp;&nbsp;&nbsp; push si&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov ds, si&nbsp;&nbsp;&nbsp;&nbsp; mov es, si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 160&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 24sub4c0:&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 160&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; loop sub4c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 80&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0sub4c1:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[160 * 24 + si], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop sub4c1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop si&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十六章16.4例.asm实验16 编写包含多个功能子程序的中断例程功能：安装一个新的int 7ch 中断例程，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为显示输出提供如下功能子程序：（1）清屏；（2）设置前景色；（3）设置背景色；（4）向上滚动一行。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 入口参数说明如下：（1）用ah寄存器传递功能号：0表示清屏，&nbsp; &nbsp; &nbsp;1表示设置前景色，2表示设置背景色，&nbsp; &nbsp; &nbsp;3表示向上滚动一行；（2）对于2、3号功能，用al传送颜色值，&nbsp; &nbsp; &nbsp;(al)属于{0,1,2,3,4,5,6,7}代码：;安装int 7ch中断例程assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;install int 7ch&nbsp;&nbsp;&nbsp;&nbsp; push cs&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset set_screen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset s_s_end - offset set_screen&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[7ch * 4], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[7ch * 4 + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; sti&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;set_screen:&nbsp;&nbsp;&nbsp;&nbsp; jmp short sel_subtable:&nbsp;&nbsp;&nbsp;&nbsp; dw offset sub0 - offset set_screen + 200h, offset sub1 - offset set_screen + 200h, offset sub2 - offset set_screen + 200h, offset sub3 - offset set_screen + 200hsel_sub:&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, 3&nbsp;&nbsp;&nbsp;&nbsp; ja end_sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; mov bl, ah&nbsp;&nbsp;&nbsp;&nbsp; add bx, bx&nbsp;&nbsp;&nbsp;&nbsp; ;千万记得将bx加倍！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;以对应table中储存子程序入口地址的偏移量cal_add:&nbsp;&nbsp;&nbsp;&nbsp; call word ptr es:[bx][offset table - offset set_screen + 200h]&nbsp;&nbsp;&nbsp;&nbsp;end_sub:&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; iretsub0:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 25 * 80sub0c0:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[bx], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub0c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; retsub1:&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 7&nbsp;&nbsp;&nbsp;&nbsp; ;对于输入的(al)颜色参数，&nbsp;&nbsp;&nbsp;&nbsp; ja sub1_ok&nbsp;&nbsp;&nbsp;&nbsp; ;第一种处理方式，检测范围&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 25 * 80sub1c0:&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr es:[bx], 11111000b&nbsp;&nbsp;&nbsp;&nbsp; or byte ptr es:[bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub1c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bxsub1_ok:&nbsp;&nbsp;&nbsp;&nbsp; retsub2:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and al, 00000111b&nbsp;&nbsp;&nbsp;&nbsp; ;对于输入的(al)颜色参数，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;第二种处理方式，清除超过范围的部分&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 4&nbsp;&nbsp;&nbsp;&nbsp; shl al, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 25 * 80sub2c0:&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr es:[bx], 10001111b&nbsp;&nbsp;&nbsp;&nbsp; or byte ptr es:[bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub2c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; retsub3:&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push ds&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b80ah&nbsp;&nbsp;&nbsp;&nbsp; ;之前错写成0b8a0h了！仔细领悟一下！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;之所以偏移的行数过多，因为ds:[bx] = ds * 16 + bx！&nbsp;&nbsp;&nbsp;&nbsp; mov ds, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, bx&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 24 * 80sub3c0:&nbsp;&nbsp;&nbsp;&nbsp; push ds:[bx]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[bx]&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub3c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 80sub3c1:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[bx], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop sub3c1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;s_s_end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend startAtt - 汇编语言第十六章实验16.asm;测试程序assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;test&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp; &nbsp; &nbsp;;mov al, 3&nbsp;&nbsp;&nbsp;&nbsp; int 7ch&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend startAtt - 汇编语言第十六章实验16测试程序.asm;sub3的更优写法：sub3:&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp; push ds&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp; push si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov ds, si&nbsp;&nbsp;&nbsp;&nbsp; mov es, si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 160&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 24 * 160&nbsp;&nbsp;&nbsp;&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 80sub3c1:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; loop sub3c1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop si&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; ret]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 12]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2012%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十五、外中断15.1 接口芯片和端口外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；CPU向外设输出也不直接送入外设，也是送入端口中。CPU还可以向外设输出控制命令。CPU通过端口和外部设备进行联系。15.2 外中断信息例：外设输入到达时，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断，处理外设输入。外中断源，共有以下两类：可屏蔽中断/不可屏蔽中断1.可屏蔽中断即，CPU可以不响应的外中断。CPU是否响应可屏蔽中断，取决于标志寄存器中IF位。若IF&nbsp;= 1，可屏蔽中断可引发CPU的中断过程；若IF&nbsp;= 0，则不响应可屏蔽中断。回忆内中断引发过程，（1）取中断类型码n（2）标志寄存器入栈，IF=0，TF=0；（3）CS、IP入栈（4）(ip) = (n * 4), (cs) = (n * 4 + 2)然后转去执行中断处理程序（中断例程）。可屏蔽中断所引发的中断过程，除第（1）步的&nbsp;实现与内中断有所不同外，其它与内中断的中断过程基本上相同。之所以第（2）步 IF 置为0，在进入中断处理程序后，禁止其它的可屏蔽中断！2.不可屏蔽中断CPU必须响应的外中断——检测到它的信息时，执行完当前指令后，立即响应。对于8086CPU，不可屏蔽中断的中断类型码固定为2！所以该中断过程中，不需要取中断类型码。（1）标志寄存器入栈，IF=0，TF=0；（2）CS、IP入栈（3）(ip) = (8), (cs) = (0AH)15.3 PC机键盘的处理过程PC机处理外设输入的基本方法：1. 键盘输入键盘每个键相当于一个个开关，键盘有一个芯片对每个键的开关状态进行扫描。（1）按下一个键，开关触发，芯片产生一个扫描码，扫描码说明按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。（2）松开一个键，其它类同上。按下按键产生的扫描码，称为通码；松开按键产生的扫描码，称为断码。扫描码长度为 1 Byte，通码第七位为0，断码的第7位为1。断码 = 通码 + 80h（部分键盘扫描码表见于文末）2. 引发9号中断键盘的输入到达60h端口时，相关芯片就会向CPU发出int 9的可屏蔽中断信息。此时若IF = 1，则响应中断。3. 执行 int 9 中断例程BIOS提供了 int 9 中断例程，处理基本的键盘输入处理。主要工作如下：（1）读出60h端口中的扫描码；（2）a. 若是字符键的扫描码，则将对应的字符码（ASCII）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 送入内存中的BIOS键盘缓冲区。&nbsp; &nbsp; &nbsp; &nbsp; b. 若是控制键（如Ctrl）和切换键（如CapsLock）等的扫描码，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 则将其转为状态字节（用二进制位记录控制键和切换键的字节），&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 写入内存中储存状态字节的单元。（3）对键盘系统进行相关的控制，如，向相关芯片发出应答信息。BIOS键盘缓冲区，是系统启动后，BIOS用于存放 int 9 中断例程所接收的键盘输入的内存区。可以存储15个键盘输入。除了接收扫描码外，还要产生和扫描码对应的字符码，一个键盘输入用 1 word（2 Bytes）存放，高位存放扫描码，低位存放字符码。0040:17单元存储键盘状态字节，记录了控制键和切换键的状态，其中各位记录的信息如下：bit &nbsp; &nbsp;键位 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;置为1表示？0 &nbsp; &nbsp; 右shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;按下1 &nbsp; &nbsp; 左shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;按下2 &nbsp; &nbsp; Ctrl &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;按下3 &nbsp; &nbsp; Alt &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 按下4 &nbsp; &nbsp; ScrollLock &nbsp; &nbsp; Scroll指示灯亮5 &nbsp; &nbsp; NumLock &nbsp; &nbsp; 小键盘输入的是数字6 &nbsp; &nbsp; CapsLock &nbsp; &nbsp; 输入大写字母7 &nbsp; &nbsp; Insert &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;处于删除状态（否则处于插入态）15.4 编写 int 9 中断例程键盘输入处理过程：（1）键盘产生扫描码；（2）扫描码送入60h（3）引发int 9（可屏蔽中断）（9）CPU执行 int 9 中断例程，处理输入编程：在屏幕中间依次显示&quot;a&quot;~&quot;z&quot;，并可以让人看清。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在显示过程中，按下Esc键后，改变显示的颜色。assume cs:codestack segment&nbsp;&nbsp;&nbsp;&nbsp; db 128 dup (0)stack endsdata segment&nbsp;&nbsp;&nbsp;&nbsp; dw 0, 0data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, stack&nbsp;&nbsp;&nbsp;&nbsp; mov ss, ax&nbsp;&nbsp;&nbsp;&nbsp; mov sp, 128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;int 9 键盘输入处理的中断例程&nbsp;&nbsp;&nbsp;&nbsp; ;将它的入口地址保存在ds:0、ds:2单元中&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4]&nbsp;&nbsp;&nbsp;&nbsp; pop ds:[0]&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4 + 2]&nbsp;&nbsp;&nbsp;&nbsp; pop ds:[2]&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;cli &nbsp; &nbsp; ;以防在设置新的中断例程入口地址时，发生中断&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ;以致于产生错误&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[9 * 4], offset int9&nbsp;&nbsp;&nbsp;&nbsp; mov es:[9 * 4 + 2], cs&nbsp; &nbsp; &nbsp;sti &nbsp; &nbsp; ;同上&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov ah, &apos;a&apos;c0:&nbsp;&nbsp;&nbsp;&nbsp; mov es:[160 * 12 + 40 * 2], ah&nbsp;&nbsp;&nbsp;&nbsp; call delay&nbsp;&nbsp;&nbsp;&nbsp; inc ah&nbsp;&nbsp;&nbsp;&nbsp; cmp ah, &apos;z&apos;&nbsp;&nbsp;&nbsp;&nbsp; jna c0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ds:[0]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[9 * 4]&nbsp;&nbsp;&nbsp;&nbsp; push ds:[2]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[9 * 4 + 2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;delay:&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 2&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0c1:&nbsp;&nbsp;&nbsp;&nbsp; sub ax, 1&nbsp;&nbsp;&nbsp;&nbsp; sbb dx, 0&nbsp;&nbsp;&nbsp;&nbsp; cmp ax, 0&nbsp;&nbsp;&nbsp;&nbsp; jne c1&nbsp;&nbsp;&nbsp;&nbsp; cmp dx, 0&nbsp;&nbsp;&nbsp;&nbsp; jne c1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop dx&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;新的 int 9 中断例程int9:&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in al, 60h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; ;bx is flag&nbsp;&nbsp;&nbsp;&nbsp; and bh, 11111100b&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; popf&nbsp;&nbsp;&nbsp;&nbsp; call dword ptr ds:[0]&nbsp;&nbsp;&nbsp;&nbsp; ;注意dword！&nbsp;&nbsp;&nbsp;&nbsp; ;这条指令已经把ds:[0]和ds:[2]两个字都传送过去了&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 1&nbsp;&nbsp;&nbsp;&nbsp; jne int9ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; inc byte ptr es:[160 * 12 + 40 * 2 + 1]&nbsp;&nbsp;&nbsp;&nbsp; ;将属性值加一，改变颜色&nbsp;&nbsp;&nbsp;&nbsp;int9ret:&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp; iret&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十五章15.4例.asm15.5 安装新的int 9中断例程安装新的int 9，使得原有中断例程的功能得到拓展。功能：在DOS下，按F1键后，改变当前屏幕的显示颜色，其它键照常。assume cs:codestack segment&nbsp;&nbsp;&nbsp;&nbsp; db 128 dup (0)stack endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, stack&nbsp;&nbsp;&nbsp;&nbsp; mov ss, ax&nbsp;&nbsp;&nbsp;&nbsp; mov sp, 128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cs&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; ;新int 9的源码地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; ;存放的目标地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset int9&nbsp;&nbsp;&nbsp;&nbsp; mov di, 204h&nbsp;&nbsp;&nbsp;&nbsp; ;预留前四字节，放原来的int9的入口地址&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset int9end - offset int9&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;将旧的int 9中断例程入口地址“偏移/段地址”暂存于0:200~0:203&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[200h]&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4 + 2]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[202h]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;安全设置新的int 9入口地址&nbsp;&nbsp;&nbsp;&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[9 * 4], 204h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[9 * 4 + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; sti&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;int9:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in al, 60h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; call dword ptr cs:[200h]&nbsp;&nbsp;&nbsp;&nbsp; ;执行中断例程时，(CS)=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 3bh&nbsp;&nbsp;&nbsp;&nbsp; jne int9ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000r0:&nbsp;&nbsp;&nbsp;&nbsp; inc byte ptr es:[bx]&nbsp;&nbsp;&nbsp;&nbsp; add bx, 2&nbsp;&nbsp;&nbsp;&nbsp; loop r0int9ret:&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp; iretint9end:&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十五章15.5例.asm实验15 安装新的int 9 中断例程功能：在DOS下，按下“A”键后，除非不再松开，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果松开，就显示满屏幕的“A”；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 其它键照常处理。提示：按下一个键产生的扫描码为通码，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 松开时产生的是断码，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 断码 = 通码 + 30hassume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; ;无法将idata直接push到stack中&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 204h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;0:200~203存储原有 int 9 中断例程的入口地址&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[200h]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push es:[9 * 4 + 2]&nbsp;&nbsp;&nbsp;&nbsp; pop es:[202h]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;install the new int 9 routine&nbsp;&nbsp;&nbsp;&nbsp; push cs&nbsp;&nbsp;&nbsp;&nbsp; pop ds&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset fill_a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset f_a_end - offset fill_a&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;避免设置新中断程序中途，&nbsp;&nbsp;&nbsp;&nbsp; ;可屏蔽中断导致入口地址的设置不正确&nbsp;&nbsp;&nbsp;&nbsp; cli&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[9 * 4], 204h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[9 * 4 + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; sti&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;fill_a:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in al, 60h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; call dword ptr cs:[200h]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 9eh&nbsp;&nbsp;&nbsp;&nbsp; ;A的断码&nbsp;&nbsp;&nbsp;&nbsp; jne ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, &apos;A&apos;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 2000c0:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], al&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; loop c0&nbsp;&nbsp;&nbsp;&nbsp;ok:&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iretf_a_end:&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十五章实验15.asm8086CPU指令系统总结：若想了解详情，自行查阅相关指令手册。提供以下几大类指令：1. 数据传输指令：如，mov、push、pop、pushf、popf、xchg等。实现寄存器、内存等之间的单个数据传送。*.&nbsp;XCHG交换指令：两个寄存器，寄存器和内存变量之间内容的交换指令，两个操作数的数据类型要相同，可以是一个字节，也可以是一个字，也可以是双字。2. 算术运算指令如，add、sub、adc、sbb、inc、dec、cmp、imul、idiv、mul、div、aaa等。执行结果影响标志寄存器。*. aaa -&nbsp;ASCII Adjust After Addition，非压缩、非组合的BCD码调整指令；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AAA指令将AL调整为一个非压缩BCD格式的数字，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;AL是两个非压缩BCD数字相加后的结果；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果AL(3~0位)大于9或辅助进位AF=1则AH=AH+01HAL=AL+06H&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;且置AF和CF为1否则置AF和CF为零AL(7~4位)=0imul 有符号乘法，将被乘数与乘数均作为有符号数。mul 无符号乘法，将被乘数及乘数均作为无符号数。idiv同理。3. 逻辑指令如，and、or、not、xor、test、shl、shr、 rol、ror、rcl、rcr等。除了not外，其它指令的结果影响标志寄存器。*. test 指令，将两操作数作与and运算，仅修改标志位，不回送结果。sal / sar 指令，Shift Arithmetic Left / Right，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;算术左/右移，执行时将操作数看成带符号数进行移位；&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;算术右移时，最高位保持不变；算术左移和逻辑左移一致。rol / ror 指令，Rotate Left / Right ，左/右循环移位。&nbsp;rcl / rcr 指令，Rotate Left / Right Through Carry，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;带进位左/右循环移位，以右移为例：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;标志位CF移入操作数最高位，操作数最低位进入标志位CF。4. 转移指令可以修改IP，或同时修改CS和IP的指令。分以下几类：（1）无条件转移指令，如jmp（2）条件转移指令：如jcxz、je、jne、jb、jnb、ja、jna等（3）循环指令：如loop（4）过程，如call、ret、retf（5）中断，如int、iret5.&nbsp;处理控制指令对标志寄存器，或其它处理机状态进行设置。如cld / std、cli / sti、nop、clc / stc、cmc、hlt、wait、esc、lock等。*. cmc&nbsp;(CoMplement Carry) 进位位求反指令：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行操作后CF=!CF 即CF=1执行CMC操作后 CF=0；反之相反。wait/fwait 同步FPU与CPU：停止CPU的运行，直到FPU完成当前操作码。hlt (halt) ：停止，无操作数。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 使程序停止运行，处理器进入暂停状态，不执行任何操作，不影响标志。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 当复位（外语：RESET）线上有复位信号、CPU响应非屏蔽中断、&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CPU响应可屏蔽中断3种情况之一时，CPU脱离暂停状态，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 执行HLT的下一条指令。esc，指令助记符，交权给外部协处理器。（意义暂不明晰）lock（意义暂不明晰）6. 串处理指令对内存中的批量数据进行处理。如movsb、movsw、cmps、scas、lods、stos等。若要使用它们方便进行批量数据处理，则需要与rep、repe、repne等前缀指令配合使用。*.&nbsp;repe / repne，即是&nbsp;repeat equal /&nbsp;repeat not equal，意思是：相等时重复 / 不相等时重复。*.完整键盘扫描码表：键盘扫描码。部分如下：键位&nbsp;/ 通码 / 断码ESC&nbsp;&nbsp;&nbsp;01H, 81H&nbsp;!1&nbsp;&nbsp;&nbsp;02H, 82H@2&nbsp;&nbsp;&nbsp;03H, 83H#3&nbsp;&nbsp;&nbsp;04H, 84H$4&nbsp;&nbsp;&nbsp;05H, 85H%5&nbsp;&nbsp;&nbsp;06H, 86H^6&nbsp;&nbsp;&nbsp;07H, 87H&amp;7&nbsp;&nbsp;&nbsp;08H, 88H*8&nbsp;&nbsp;&nbsp;09H, 89H(9&nbsp;&nbsp;&nbsp;0AH, 8AH)0&nbsp;&nbsp;&nbsp;0BH, 8BH_-&nbsp;&nbsp;&nbsp;0CH, 8CH+=&nbsp;&nbsp;&nbsp;0DH, 8DHERASE&nbsp;0EH, 8EHTAB&nbsp;&nbsp;&nbsp;0FH, 8FHQ&nbsp;&nbsp;&nbsp;10H, 90HW&nbsp;&nbsp;&nbsp;11H, 91HE&nbsp;&nbsp;&nbsp;12H, 92HR&nbsp;&nbsp;&nbsp;13H, 93HT&nbsp;&nbsp;&nbsp;14H, 94HY&nbsp;&nbsp;&nbsp;15H, 95HU&nbsp;&nbsp;&nbsp;16H, 96HI&nbsp;&nbsp;&nbsp;17H, 97HO&nbsp;&nbsp;&nbsp;18H, 98HP&nbsp;&nbsp;&nbsp;19H, 99H{[&nbsp;&nbsp;&nbsp;1AH, 9AH}]&nbsp;&nbsp;&nbsp;1BH, 9BHENTER&nbsp;1CH, 9CHL_CTRL&nbsp;1DH, 9DH&nbsp;///左CTRLA&nbsp;&nbsp;&nbsp;1EH, 9EHS&nbsp;&nbsp;&nbsp;1FH, 9FHD&nbsp;&nbsp;&nbsp;20H, A0HF&nbsp;&nbsp;&nbsp;21H, A1HG&nbsp;&nbsp;&nbsp;22H, A2HH&nbsp;&nbsp;&nbsp;23H, A3HJ&nbsp;&nbsp;&nbsp;24H, A4HK&nbsp;&nbsp;&nbsp;25H, A5HL&nbsp;&nbsp;&nbsp;26H, A6H:;&nbsp;&nbsp;&nbsp;27H, A7H&quot;&apos;&nbsp;&nbsp;&nbsp;28H, A8H~`&nbsp;&nbsp;&nbsp;29H, A9HL_SHIFT&nbsp;2AH, AAH&nbsp;///左SHIFT|\&nbsp;&nbsp;&nbsp;2BH, ABHZ&nbsp;&nbsp;&nbsp;2CH, ACHX&nbsp;&nbsp;&nbsp;2DH, ADHC&nbsp;&nbsp;&nbsp;2EH, AEHV&nbsp;&nbsp;&nbsp;2FH, AFHB&nbsp;&nbsp;&nbsp;30H, B0HN&nbsp;&nbsp;&nbsp;31H, B1HM&nbsp;&nbsp;&nbsp;32H, B2H&lt;,&nbsp;&nbsp;&nbsp;33H, B3H&gt;.&nbsp;&nbsp;&nbsp;34H, B4H?/&nbsp;&nbsp;&nbsp;35H, B5H]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 11]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2011%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十四、端口PC系统中，和CPU通过总线项链的芯片除存储器外，还有：（1）各种接口卡（如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作（2）主板上的接口芯片，CPU通过它们对部分外设进行访问（3）其它芯片，用来存储相关的系统信息，或进行相关的IO处理这些芯片中，都有一组可以由CPU读写的寄存器。物理上它们在不同芯片中，但在以下两点上相同：（1）都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的（2）CPU对它们进行读写时，都通过控制线向它们所在的芯片发出端口读写命令可见，CPU将这些寄存器当作端口，对其统一编址，建立统一的地址端口空间。CPU可直接读写以下3个地方的数据：（1）CPU内部的寄存器（2）内存单元（3）端口14.1 端口的读写PC系统中，CPU最多可以定位64K个不同的端口，0~65535对端口的读写指令只有两条：in、out而无push、pop、mov等指令访问端口：in al, 60h（1）CPU通过地址线将地址信息60h发出（2）CPU通过控制线发出端口读命令，选中端口所在的芯片，&nbsp; &nbsp; &nbsp;并通知它，将要从中读取数据（3）端口所在的芯片将60h端口中的数据通过数据线送入CPU写入端口：out 20h, al类同上一条14.2 CMOS &nbsp;RAM 芯片CMOS &nbsp;RAM&nbsp;芯片 一般简称 CMOS。特征如下：（1）包含一个实时钟，和一个128个存储单元的RAM存储器。&nbsp; &nbsp; &nbsp;（早期计算机为64Bytes）（2）靠电池供电，关机后其内部实时钟仍可正常工作，RAM中的信息不丢失。（3）128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间，&nbsp; &nbsp; &nbsp;其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。&nbsp; &nbsp; &nbsp;BIOS也提供了相关程序，使开机时可配置CMOS &nbsp;RAM中的系统信息。（4）该芯片内部有两个端口，地址分别为70h、71h。通过它们读写CMOS RAM。（5）70h为地址端口，存放要访问的CMOS RAM单元的地址；&nbsp; &nbsp; &nbsp;71h为数据端口，存放从选定的CMOS RAM单元中读取的数据。&nbsp; &nbsp; &nbsp;如读取CMOS的2号存储单元：&nbsp; &nbsp; &nbsp;a. 将 2 送入端口 70h&nbsp; &nbsp; &nbsp;b. 从端口 71h 读 2 号单元的内容检测点14.1编程：读取CMOS RAM的2号单元的内容 / 将0写入该单元assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;read CMOS RAM unit2&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp; out 70h, al&nbsp;&nbsp;&nbsp;&nbsp; in al, 71h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;write unit2&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp; out 70h, al&nbsp;&nbsp;&nbsp;&nbsp; mov al, 0&nbsp;&nbsp;&nbsp;&nbsp; out 71h, al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;;in/out指令，好像只能凭借al寄存器来做参数中转&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;;test operator&apos;s result&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp; out 70h, al&nbsp;&nbsp;&nbsp;&nbsp; in al, 71h&nbsp; &nbsp; &nbsp;;大概是CMOS的2单元一直在变&nbsp; &nbsp; &nbsp;;从&nbsp;71h&nbsp;读到 al 的数据并不是预想中的 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start14.3 shl 和 shr 指令它们是逻辑移位指令shl —— 逻辑左移：（1）将一个寄存器或内存单元中的数据向左移位（2）将最后移出的一位写入CF中（3）低位用0补充指令：mov al, 10000001bshl al, 1 &nbsp; &nbsp; ;左移一位shr —— 逻辑右移：（1）将一个寄存器或内存单元中的数据向右移位（2）将最后移出的一位写入CF中（3）高位用0补充检测点14.2计算 (ax) = (ax) * 10（1）第一版assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl ax, 1&nbsp;&nbsp;&nbsp;&nbsp; ; ax * 2&nbsp;&nbsp;&nbsp;&nbsp; mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;;shl/shr指令，若用立即数作为参数时，&nbsp; &nbsp; &nbsp;;立即数必须为1（每次仅允许移一位！）&nbsp;&nbsp;&nbsp;&nbsp; shl ax, 1&nbsp;&nbsp;&nbsp;&nbsp; ; ax * 4&nbsp;&nbsp;&nbsp;&nbsp; shl ax, 1&nbsp;&nbsp;&nbsp;&nbsp; ; ax * 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start（2）第二版assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shl ax, 1&nbsp;&nbsp;&nbsp;&nbsp; ; ax * 2&nbsp;&nbsp;&nbsp;&nbsp; mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;当移位数大于1时，要先将移位数置于CL中，然后再用CL移位。&nbsp;&nbsp;&nbsp;&nbsp; ;可以使用8位立即数指定范围从1到31的移位次数&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 2&nbsp;&nbsp;&nbsp;&nbsp; shl ax, cl&nbsp;&nbsp;&nbsp;&nbsp; ; ax * 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ax, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start14.4 CMOS &nbsp;RAM 中存储的时间信息CMOS RAM 存着当前的时间：年、月、日、时、分、秒。信息的长度均为 1 Byte。存放单元为：秒0 分2 时4 日7 月8 年9这些数据以BCD码的方式存放。BCD码：以4位二进制数，表示十进制数码的编码方式，如下：0-0000，1-0001，2-0010，3-0011，4-0100，5-0101，6-0110，7-0111，8-1000，9-1001。1 Byte 可表示 2个BCD码，如 0001 0100b 表示 14。（以上为BCD码中的8421版本，其它详情请看百度百科）在屏幕中间显示当前‘分钟’：assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp; ;如上文，单元2 存放着‘分钟’信息&nbsp;&nbsp;&nbsp;&nbsp; out 70h, al&nbsp;&nbsp;&nbsp;&nbsp; in al, 71h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, al&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 4&nbsp;&nbsp;&nbsp;&nbsp; shr ah, cl&nbsp;&nbsp;&nbsp;&nbsp; ;右移4位，取高四位&nbsp;&nbsp;&nbsp;&nbsp; and al, 00001111b&nbsp;&nbsp;&nbsp;&nbsp; ;保留低四位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add ah, 30h&nbsp;&nbsp;&nbsp;&nbsp; ;+30h 转换为对应数字的ascii&nbsp;&nbsp;&nbsp;&nbsp; add al, 30h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; ;输出到屏幕&nbsp;&nbsp;&nbsp;&nbsp; mov ds, bx&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr ds:[160 * 12 + 40 * 2], ah&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr ds:[160 * 12 + 40 * 2 + 2], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start实验14 访问CMOS RAM编程：以“年/月/日 时:分:秒”的格式，显示当前的日期、时间。注意：CMOS RAM 中存储着系统的配置信息，除了保存时间信息的单元外，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不要向其它单元写内容，否则将引起一些系统错误。assume cs:codetime_pos segment&nbsp;&nbsp;&nbsp;&nbsp; db 9, 8, 7, 4, 2, 0time_pos ends;上一个段不满 16 Bytes (8 Words);新起的段也只从 下一个 16Bytes * n 的内存位置开始（见上图）;16Bytes * n 即 10h * ntime_delimiter segment&nbsp;&nbsp;&nbsp;&nbsp; db &apos;/&apos;, &apos;/&apos;, &apos; &apos;, &apos;:&apos;, &apos;:&apos;, &apos;$&apos;time_delimiter endstime_str segment&nbsp;&nbsp;&nbsp;&nbsp; db 18 dup (0)time_str endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, time_pos&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, time_str&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 6circle:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;从端口获取当前时间&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp; out 70h, al&nbsp;&nbsp;&nbsp;&nbsp; in al, 71h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;切分当前时间的CBD码，存到不同的存储单元中&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp; mov ah, al&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 4&nbsp;&nbsp;&nbsp;&nbsp; shr ah, cl&nbsp;&nbsp;&nbsp;&nbsp; and al, 00001111b&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;将BCD码转换为，对应数字的ASCII码&nbsp;&nbsp;&nbsp;&nbsp; add ah, 30h&nbsp;&nbsp;&nbsp;&nbsp; add al, 30h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;将时间拼接成字符串，暂存到指定内存中&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], ah&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; ;es:[di]访问的是段time_str&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], al&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; ;ds:16[si]访问的是段time_delimiter&nbsp;&nbsp;&nbsp;&nbsp; mov bl, ds:16[si]&nbsp;&nbsp;&nbsp;&nbsp; ;为什么idata（直接数/常量）偏移量是16而非6？&nbsp;&nbsp;&nbsp;&nbsp; ;答：段time_str只用db指令声明了6Bytes的数据，&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; 但紧邻的段time_delimiter并非从上一个段&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; time_str的第7字节开始的，而是从下一个&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp; 16Bytes * n的内存位置开始的！&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], bl&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; loop circle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;locate cursor&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; ;第0页&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 12&nbsp;&nbsp;&nbsp;&nbsp; ;第12行&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 30&nbsp;&nbsp;&nbsp;&nbsp; ;第30列&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; ;设置光标位置，int 10h的2号子程序&nbsp;&nbsp;&nbsp;&nbsp; int 10h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;print time_str&nbsp;&nbsp;&nbsp;&nbsp; mov ax, time_str&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp; ;ds:dx指向字符串，&apos;$&apos;作为结束符&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 9&nbsp;&nbsp;&nbsp;&nbsp; ;在光标位置处显示字符串，int 21h的9号子程序&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend startAtt - 汇编语言第十四章实验14.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 10]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%2010%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十三、int 指令本章介绍 由int指令引发的中断13.1 int 指令没有做除法，也可以直接使用&nbsp;int 0&nbsp;指令引发除法溢出中断。中断处理程序&nbsp;—— 简称：中断例程13.2 编写供应用程序调用的中断例程实例1：实现2 * 2456^2使用中断处理程序实现平方assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset sqr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset sqrend - offset sqr&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch + 2], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;test sqr&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 3456&nbsp;&nbsp;&nbsp;&nbsp; int 7ch&nbsp;&nbsp;&nbsp;&nbsp; add ax, ax&nbsp;&nbsp;&nbsp;&nbsp; adc dx, dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;sqr:&nbsp;&nbsp;&nbsp;&nbsp; mul ax&nbsp;&nbsp;&nbsp;&nbsp; iretsqrend:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend start实例2：将一个全是字母，以0结尾的字符串，转化为大写。把终端程序当作子程序来使用。assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp; db &apos;conversion&apos;, 0data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;install int 7ch&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset capital&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset cap_end - offset capital&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;set int 7ch&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch + 2], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;test int 7ch&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 7ch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;capital:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ch, 0r0:&nbsp;&nbsp;&nbsp;&nbsp; mov cl, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp; jcxz ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp cl, 61h&nbsp;&nbsp;&nbsp;&nbsp; jb next&nbsp;&nbsp;&nbsp;&nbsp; cmp cl, 7ah&nbsp;&nbsp;&nbsp;&nbsp; ja next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr ds:[si], 11011111bnext:&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; jmp r0ok:&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp; popf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iret&nbsp;&nbsp;&nbsp;&nbsp;cap_end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend start13.3 对int、iret 和 栈的深入理解目的：用7ch中断例程实现loop指令的功能实例：在屏幕中间显示80个感叹号“！”。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;install&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset lop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset lop_end - offset lop&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; ;test&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 12 * 160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, offset s - offset se&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 80s:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], &apos;!&apos;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; int 7ch&nbsp;&nbsp;&nbsp;&nbsp; ;loop sse:&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hlop:&nbsp;&nbsp;&nbsp;&nbsp; dec cx&nbsp;&nbsp;&nbsp;&nbsp; ;想想这句可置于jcxz后吗？&nbsp;&nbsp;&nbsp;&nbsp; jcxz ed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; push bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bp, sp&nbsp;&nbsp;&nbsp;&nbsp; add ss:[bp + 2], bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; pop bped:&nbsp;&nbsp;&nbsp;&nbsp; iret&nbsp;&nbsp;&nbsp;&nbsp;lop_end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend start13.14&nbsp;BIOS&nbsp;和&nbsp;DOS&nbsp;所提供的中断例程在系统板的ROM中存放着一套程序，称为&nbsp;BIOS（基础输入输出系统），主要包含以下几部分内容：（1）硬件系统的监测和初始化程序（2）外部中断（15章中详解）和内部中断的中断例程（3）用于对硬件设备进行I/O操作的中断例程（4）其它和硬件系统相关的中断例程从OS（操作系统）的角度看，DOS的中断例程 就是 OS向coder提供的编程资源。BIOS和DOS在所提供的中断例程中提供了许多实现了程序员在编程时所需功能的子程序。可以用&nbsp;int 指令可直接调用它们。和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。13.5&nbsp;BIOS&nbsp;和&nbsp;DOS 中断例程的安装过程：（1）开机，CPU加电，初始化(CS)=0FFFFH，(IP)=0。自动从FFFF:0单元执行程序，此处有一条跳转指令，然后将跳转到BIOS中的硬件系统检测和初始化程序。（2）初始化程序建立BIOS所支持的中断变量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。*. 注意：对于BIOS所提供的中断例程，只需将入口地址登记入中断向量表即可，因为它们具体程序已被固化在ROM中，在内存中一直存在。（3）硬件系统检测和初始化完成后，调用&nbsp;int 19h&nbsp;进行操作系统的引导。自此计算机交给操作系统控制。（4）DOS启动后，除完成其它工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。13.6 BIOS 中断例程应用（例子）&nbsp;int 10h 中断例程是 BIOS 提供的，其中包含多个和屏幕输出相关的子程序。一般，供程序员调用的中断例程往往包括多个子程序，其内部用传递进来的参数决定执行哪个子程序。都用 ah 来传递内部子程序的编号。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;指使用 int 10h 中断例程的2号子程序——&nbsp;&nbsp;&nbsp;&nbsp; ;置光标&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; ;第0页，bh：页号&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 5&nbsp;&nbsp;&nbsp;&nbsp; ;第5行，dh：行号&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 12&nbsp;&nbsp;&nbsp;&nbsp; ;第12列，dl：列号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 10h&nbsp;&nbsp;&nbsp;&nbsp; ;调用10h号中断例程&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;int 10h 9号子程序——&nbsp;&nbsp;&nbsp;&nbsp; ;在光标位置显示字符&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, &apos;a&apos;&nbsp;&nbsp;&nbsp;&nbsp; ;al：显示的字符&nbsp;&nbsp;&nbsp;&nbsp; mov bl, 7&nbsp;&nbsp;&nbsp;&nbsp; ;bl：颜色属性&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; ;bh：第0页&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 3&nbsp;&nbsp;&nbsp;&nbsp; ;cx：字符重复个数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 10h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start显示缓冲区分为8页，每页4KB，显示器可以显示任一页内容。一般，显示第0页，即是内存B8000H~B8F9FH的内容。关于显示缓冲区，详细参考：Assembly Language - Note 6&nbsp;文末的图13.7 DOS 中断例程的应用int 21h 中断例程是 DOS 提供的，其中包含了供程序员编程时调用的子程序。之前的程序一直以以下语句结尾：mov ax, 4c00hint 21h使用的是 int 21h 中断例程的 4ch 号子程序，功能为 程序返回，可提供返回值作为参数。mov ah, 4ch &nbsp; &nbsp; ;4ch号子程序，功能：程序返回mov al, 0 &nbsp; &nbsp; ;al——返回值int 21hint 21h 的 9 号子程序 —— 在光标位置显示字符串ds:dx ;指向字符串，要显示的字符串需用“$”作为结束符mov ah, 9int 21h（完整程序）assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Welcome to masm!&apos;, &apos;$&apos;data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; ;置光标&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 0&nbsp;&nbsp;&nbsp;&nbsp; ;第0页&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 5&nbsp;&nbsp;&nbsp;&nbsp; ;第5行&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 12&nbsp;&nbsp;&nbsp;&nbsp; ;第12列&nbsp;&nbsp;&nbsp;&nbsp; int 10h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 9&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start实验13 编写、应用中断例程（1）编写并安装 int 7ch中断例程，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 功能为显示一个用0结束的字符串，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 中断例程安装在0:200处。参数：(dh)=行号，(dl)=列号，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cl)=颜色，ds:si指向字符串首地址assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Welcome to masm!&apos;, 0data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;install&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset show_end - offset show_str&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch + 2], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;test&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 10&nbsp;&nbsp;&nbsp;&nbsp; ;row&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 10&nbsp; ;col&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 15&nbsp;&nbsp;&nbsp;&nbsp; ;color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 7ch&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;show_str:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 80 * 2&nbsp;&nbsp;&nbsp;&nbsp; mul dh&nbsp;&nbsp;&nbsp;&nbsp; add al, dl&nbsp;&nbsp;&nbsp;&nbsp; ;ax + dl * 2&nbsp;&nbsp;&nbsp;&nbsp; adc ah, 0&nbsp;&nbsp;&nbsp;&nbsp; add al, dl&nbsp;&nbsp;&nbsp;&nbsp; adc ah, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ch, clr0:&nbsp;&nbsp;&nbsp;&nbsp; cmp byte ptr ds:[si], 0&nbsp;&nbsp;&nbsp;&nbsp; je ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp; ;此时 ch &amp; cl = color &amp; char&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], cx&nbsp;&nbsp;&nbsp;&nbsp; ;此时 es:[di] 内存 为 char &amp; color&nbsp;&nbsp;&nbsp;&nbsp; ;在寄存器cx中，低字节的char，放在了内存的低地址中&nbsp;&nbsp;&nbsp;&nbsp; ;即8086CPU是小端模式的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc&nbsp;&nbsp;&nbsp;&nbsp; si&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; jmp r0ok:&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iretshow_end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend startAtt - 汇编语言第十三章实验13 (1).asm（2）编写并安装 int 7ch 中断例程，功能为完成loop指令的功能参数：(cx)=循环次数，(bx)=位移实现：在屏幕中间显示80个 “！”感叹号。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; ;install&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset lop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset lop_end - offset lop&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch], 200h&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[4 * 7ch + 2], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;test&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 12 * 160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, offset r0 - offset r0_end&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 80r0:&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr es:[di], &apos;!&apos;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp; int 7chr0_end:&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;lop:&nbsp;&nbsp;&nbsp;&nbsp; dec cx&nbsp;&nbsp;&nbsp;&nbsp; jcxz ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp; push bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;因为sp不是基址寄存器之一，&nbsp;&nbsp;&nbsp;&nbsp; ;不能靠直接写ss:[sp]来操作它&nbsp;&nbsp;&nbsp;&nbsp; ;才让sp传值给bp，用ss:[bp + n]……&nbsp;&nbsp;&nbsp;&nbsp; mov bp, sp&nbsp;&nbsp;&nbsp;&nbsp; mov ax, ss:4[bp]&nbsp;&nbsp;&nbsp;&nbsp; add ax, bx&nbsp;&nbsp;&nbsp;&nbsp; mov ss:4[bp], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bp&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;ok:&nbsp;&nbsp;&nbsp;&nbsp; iretlop_end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend startAtt - 汇编语言第十三章实验13 (2).asm（3）下面的程序，分别在屏幕的第2、4、6、8行&nbsp; &nbsp; &nbsp;显示4句英文诗，补全程序：assume cs:codecode segments1:&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Good,better,bset,&apos;, &apos;$&apos;s2:&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Never let it rest,&apos;, &apos;$&apos;s3:&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Till good is better,&apos;, &apos;$&apos;s4: db &apos;And better,best.&apos;, &apos;$&apos;s:&nbsp;&nbsp;&nbsp;&nbsp; dw offset s1, offset s2, offset s3, offset s4row:&nbsp;&nbsp;&nbsp;&nbsp; db 2, 4, 6, 8start:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov bx, offset s&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset row&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 4&nbsp;&nbsp;&nbsp;&nbsp;ok:&nbsp;&nbsp;&nbsp;&nbsp; ;int 10h中断例程的2号子程序，置光标&nbsp;&nbsp;&nbsp;&nbsp; ;bh：页号&nbsp;&nbsp;&nbsp;&nbsp; ;dh：行号&nbsp;&nbsp;&nbsp;&nbsp; ;dl：列号&nbsp;&nbsp;&nbsp;&nbsp; mov dh, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 0&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 2&nbsp;&nbsp;&nbsp;&nbsp; int 10h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;int 21h的9号子程序，在光标位置显示字符串&nbsp;&nbsp;&nbsp;&nbsp; ;ds:dx 指向字符串，要显示的字符串需用“$”作为结束符&nbsp;&nbsp;&nbsp;&nbsp; mov dx, ds:[bx]&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 9&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; add bx, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend startAtt - 汇编语言第十三章实验13 (3).asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 9]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%209%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十二、内中断中断：CPU不再接着（刚执行完的指令）向下执行12.1 内中断的产生当8086 CPU发生以下情况时，将产生马上处理的中断信息：&nbsp; &nbsp; &nbsp;*. 右边数字为中断类型码（1）除法错误（执行div时产生溢出） - 0（2）单步执行 - 1（3）执行into指令 - 4（4）执行int指令 - 该指令的格式为 int n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 指令中n为byte型立即数，是提供给CPU的中断类型码12.2&nbsp;中断处理程序根据中断类型码，定位相应中断处理程序12.3&nbsp;中断向量表中断向量表，存储256个中断处理程序的&nbsp;入口地址（CS:IP）它在内存中存放，对于8086PC机，放在内存地址0处（在0000:0000~0000:03FF，CS、IP地址分别都是dword，共占4B）12.4 中断过程：（1）从中断信息中，取得中断类型码 N（2）标志寄存器的值入栈，pushf&nbsp; &nbsp; &nbsp;（因为中断过程中要改变标志寄存器的值，要先将其保存在栈中）（3）将标志寄存器的第8位 TF 和 第9位 IF&nbsp;的值 设置为 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TF = 0， IF = 0（目的日后详述）（4）CS 的内容 入栈，push cs（5）IP&nbsp;的内容&nbsp;入栈，push ip（6）设置中断处理程序的入口地址&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IP = (中断类型码 * 4) &nbsp; &nbsp; ; 用地址为&nbsp;中断类型码 * 4 的内存内容 设置IP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CS = (中断类型码 * 4 + 2) &nbsp; &nbsp; ; 类上然后执行中断处理程序12.5&nbsp;中断处理程序 使用 iret 指令返回iret 功能：&nbsp;pop ip &nbsp; &nbsp;&nbsp;pop cs &nbsp; &nbsp;&nbsp;popf12.6 除法错误中断的处理12.7 编程处理 0 号（除法错误）中断12.8 安装12.9 do112.10设置中断向量assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset do0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp; ;0000:0000~0000:03FF 为中断向量表&nbsp;&nbsp;&nbsp;&nbsp; ;而0200~02FF还不被其它程序包括OS等使用&nbsp;&nbsp;&nbsp;&nbsp; ;可以安全使用&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;传输长度&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset do0end - offset do0&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; ;设置传输方向为正&nbsp;&nbsp;&nbsp;&nbsp; rep movsb &nbsp; &nbsp; ;安装程序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;设置中断向量表&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[0 * 4], 200h&nbsp;&nbsp;&nbsp;&nbsp; ;ip&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[0 * 4 + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; ;cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;do0:&nbsp;&nbsp;&nbsp;&nbsp; jmp short do0start&nbsp;&nbsp;&nbsp;&nbsp; db &apos;Overflow!&apos;do0start:&nbsp;&nbsp;&nbsp;&nbsp; ;指向上面定义的那串字符&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 202h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;指向显示空间的中间位置&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 12 * 160 + 36 * 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 9s:&nbsp;&nbsp;&nbsp;&nbsp; mov al, [si]&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], al&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; add di, 2&nbsp;&nbsp;&nbsp;&nbsp; loop s&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hdo0end:&nbsp;&nbsp;&nbsp;&nbsp; nopcode endsend startAtt - 汇编语言第十二章安装关于除法溢出的中断程序的实例.asm12.11 单步中断使&nbsp;TF = 1，CPU将工作于 单步中断 方式下，执行完这条指令后，就引发单步中断当然，进入中断处理程序前，设置TF = 0，避免在中断处理程序执行中发生单步中断12.12 响应中断的特殊情况在执行完向 ss 寄存器传送数据的指令后，即便发生中断，CPU也不会响应主要原因：ss:sp 联合指向栈顶，而对它们的设置应该连续完成。因为假如设置完ss后被中断，需要压栈保存数据，此时后续设置sp的语句没有执行，于是中断处理保存了错误的sp。中断恢复后，会导致sp没有指向正确的栈顶！所以设置sp的语句，紧跟设置ss的语句！实验12 编写0号中断的处理程序编写0号中断的处理程序，使得在出发溢出发生时，在屏幕中间显示字符串“divide error！”，然后返回到DOS。类同12.10小节下的程序assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; ;cs 曾错写为 offset do&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset do&nbsp;&nbsp;&nbsp;&nbsp; ;offset do 曾错写为 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 200h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset do_end - offset do&nbsp;&nbsp;&nbsp;&nbsp; cld&nbsp;&nbsp;&nbsp;&nbsp; rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[0 * 4], 200h&nbsp;&nbsp;&nbsp;&nbsp; ;ip&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr es:[0 * 4 + 2], 0&nbsp;&nbsp;&nbsp;&nbsp; ;cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 1000&nbsp;&nbsp;&nbsp;&nbsp; mov bh, 1&nbsp;&nbsp;&nbsp;&nbsp; div bh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;do:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 200h + offset msg - offset do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov di, 12 * 160 + 2 * (40 - (offset do_end - offset msg) / 2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, offset do_end - offset msgs:&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp; mov es:[di], al&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp; add di, 2&nbsp;&nbsp;&nbsp;&nbsp; loop s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hmsg:&nbsp;&nbsp;&nbsp;&nbsp; db &quot;divide error!&quot;&nbsp;&nbsp;&nbsp;&nbsp; ;13字do_end:&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;code endsend start后记：1. 趁着对12.10小节的中断处理程序的安装程序还有印象时，重写的。不够独立。2.竟然对照12.10小节的程序来debug！不能容忍有下次！Att - 汇编语言第十二章实验10.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 8]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%208%2F</url>
    <content type="text"><![CDATA[Created on 2014-11教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十一、标志寄存器CPU内部有一种特殊的寄存器，具有以下3个作用：（1）存储相关指令的某些执行结果；（2）为CPU执行相关指令提供行为依据；（3）控制CPU的相关工作方式。flag：标志寄存器，16位，按位起作用。15 14 13 12 11 &nbsp;10 &nbsp; 9 &nbsp; 8 &nbsp; &nbsp;7 &nbsp; &nbsp;6 &nbsp; &nbsp;5 &nbsp; 4 &nbsp; 3 &nbsp; 2 &nbsp; 1 &nbsp; 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OF &nbsp;DF &nbsp;IF &nbsp;TF &nbsp;SF &nbsp;ZF &nbsp; &nbsp; &nbsp; AF &nbsp; &nbsp; &nbsp;PF &nbsp; &nbsp; &nbsp;CF空出的都是在8086CPU中没有被使用，不具有含义。11.1 ZF&nbsp;标志Zero 零标志位：记录相关指令执行后，其结果是否为0。若结果为0，则 zf = 1 ；若结果不为0，则 zf = 0 。注意：8086CPU的指令集中，有的指令的执行是影响标志寄存器的，它们大都是运算指令（逻辑或算术运算）。有的则没有影响，如mov、push、pop等，它们大都是传送指令。11.2 PF 标志Parity 奇偶标志位：记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。若1的个数为偶数，则&nbsp;pf = 1&nbsp;；若为奇数，pf = 0&nbsp;。11.3 SF 标志Sign 符号标志位：记录相关指令执行后，其结果是否为负。若结果为负，则 SF = 1 ；若结果为正，则 SF = 0 。11.4 CF&nbsp;标志Carry 进位标志位：一般情况下，在无符号数运算时，记录运算结果的最高有效位向更高位的进位值（add），或从更高位的借位值（sub）。11.5 OF 标志Overflow 溢出标志：在进行有符号数运算时，若结果超过了及其所能表示的范围称为溢出。若发生溢出，则 OF = 1 ；若没有，则 OF = 0 。CF 和 OF 的区别：CF是对无符号数运算有意义的标志位；OF是对有符号数(同上)……例子：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov al, 98 &nbsp; &nbsp; add al, 99 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;即98+99对于无符号数（8bits，0~255）没有进位，CF = 0 ；对于有符号数（8bits，-128~127）有溢出，OF = 1 。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov al, 0F0H &nbsp; &nbsp; add al, 88H对于unsigned number，即是 240 + 136 ，有进位，CF = 1&nbsp;；对于signed，有溢出，即是 -16 + (-120)，OF = 1 。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov al, 0F0H &nbsp; &nbsp; add al, 78H对于unsigned&nbsp;number，即是 240 + 120 ，有进位，CF = 1&nbsp;；对于signed，有溢出，即是 -16 + 120 ，OF = 0 。怎么查看标志寄存器请看见本文文末的11.12节11.6&nbsp;adc&nbsp;指令：带进位加法指令，利用CF位上记录的进位值。指令格式：同add。功能：operand1 =&nbsp;operand1 + operand2 + CFadc 指令的用途解析：加法分两步来进行：（1）低位相加；（2）高位相加再加上低位相加产生的进位值。例子： 1EF000H + 201000H因为操作数都超过了16位，无法将它完整放到一个16位大小的寄存器中，无法通过add一次得到结果，所以——mov ax, 001EH &nbsp; &nbsp; ;ax放高16位mov bx, F000H &nbsp; &nbsp; ;bx放低16位add &nbsp;bx, 1000H &nbsp; &nbsp; ;低位相加adc &nbsp;ax, 0020H &nbsp; &nbsp; ;高位相加，再加CF（即低位的进位值）11.7 sbb&nbsp;指令：带借位减法指令，利用CF位上记录的借位值。borrow借位。指令格式：同sub。功能：operand1 =&nbsp;operand1 - operand2 - CF其用途和意义类似于adc！11.8 cmp 指令：比较指令。功能相当于减法指令，只是不保存结果。cmp指令执行后，根据计算结果来设置标志寄存器(主要是&nbsp;zf&nbsp;和 cf&nbsp;)。格式：cmp oper1, oper2例子：cmp ax, bx|情况 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;|(ax)-(bx)的结果 &nbsp; |标志位情况(ax)&nbsp;==&nbsp;(bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;zf = 1(ax)&nbsp;!=&nbsp;(bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;!= 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zf != 0(ax)&nbsp;&lt;&nbsp;(bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cf = 1(ax) &lt;= (bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;= 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cf = 1&nbsp;or&nbsp;zf = 1(ax) &gt; (bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt; 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cf = 0&nbsp;and zf = 0(ax) &gt;= (bx) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;= 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cf = 0为什么判断(ax)和(bx)的大小关系，看的是 cf 标志位，而不是 sf 呢？因为一般情况下&nbsp;(ax) - (bx) &lt; 0，即是(ax) &lt; (bx)，sf = 1 ；但是当涉及有符号数的对比时，如34 - (-96) = 130 发生了溢出，结果82H，即-126！sf = 1，但是 (ax) &gt; (bx)。不过 sf 结合 of 还是可以判断(ax)和(bx)的大小关系的。sf = 0 and of = 0 —— (ax) &gt;= (bx)&nbsp;sf = 1 and of = 0 —— (ax) &lt;= (bx)sf = 0 and of = 1 —— (ax) &lt;= (bx)sf = 1 and of = 1&nbsp;—— (ax) &gt;= (bx)&nbsp;如果溢出，逻辑上的真正结果必然和实际结果“相反”！11.9 检测比较结果的条件转移指令条件转移指令通常和cmp相配合使用。指令 &nbsp; &nbsp; &nbsp;含义 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;检测相关标志位je &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;== 等于则转移 &nbsp; &nbsp; &nbsp;zf = 1jne &nbsp; &nbsp; &nbsp; &nbsp;!=&nbsp;不等于则.. &nbsp; &nbsp; &nbsp; &nbsp; zf = 0jb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&nbsp;低于则.. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cf = 1jnb &nbsp; &nbsp; &nbsp; &nbsp;&gt;= 不低于.. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cf = 0ja &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&gt; 高于.. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cf = 0 and zf = 0jna &nbsp; &nbsp; &nbsp; &nbsp;&lt;= 不高于.. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cf = 1 or zf = 0e —— equalb —— belowa —— above在使用这些跳转指令前，先用不用cmp指令，由我们决定。例子：编程统计data段中，数值大于8的字节的个数，用ax保存统计结果。assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 0, 2, 1, 4, 7, 3, 5, 9, 6, 8, 10, 12, 15, 14, 13, 11data endscode segmentstart:&nbsp;&nbsp;mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 16s: &nbsp; &nbsp; &nbsp;cmp byte ptr [bx], 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jna next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc axnext:&nbsp;&nbsp;&nbsp;inc bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21hcode endsend start11.10 DF 标识 和 串传送指令DF ：方向标志位。它在串处理指令中，控制每次操作后si、di是增是减。串传送指令： movsb、movsw —— moving string byte / wordmovsb&nbsp;(无参数)功能：相当于以下几步操作。（1）((es) * 16 + (di)) = ((ds) * 16 + (si))（2）若df = 0，则 (si) = (si) + 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (di) = (di) + 1&nbsp; &nbsp; &nbsp;若df = 1，则&nbsp;(si) = (si) - 1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (di) = (di) - 1&nbsp;用汇编语言描述则是：mov es:[di], byte ptr ds:[si] &nbsp; &nbsp; ;8086CPU并不支持这样的指令，这里仅仅为描述if df = 0 &nbsp; &nbsp; inc si &nbsp; &nbsp; inc diif df = 1 &nbsp; &nbsp; dec si &nbsp; &nbsp; dec dimovsw (无参数)功能&nbsp;用汇编语言描述则是：mov es:[di], word ptr ds:[si]&nbsp;&nbsp; &nbsp; ;8086CPU并不支持这样的指令，这里仅仅为描述if df = 0 &nbsp; &nbsp; add si, 2 &nbsp; &nbsp; add di, 2if df = 1 &nbsp; &nbsp; sub si, 2 &nbsp; &nbsp; sub di, 2一般 movsb / movsw 都和 rep 配合使用：rep movsbrep movsw用汇编描述就是：s: &nbsp; movsb&nbsp; &nbsp; &nbsp;loop ss: &nbsp; movsw&nbsp; &nbsp; &nbsp;loop srep 指令的作用：根据cx的值，重复执行后面的串传送指令。然后可以根据flag寄存器的 df 标志，决定传送方向：df = 0 &nbsp; &nbsp; 从前向后 传送df = 1 &nbsp; &nbsp; 相反cld 指令 ——&nbsp;clear df &nbsp; ：将标志寄存器的df位，置为0。std 指令 ——&nbsp;set df &nbsp; &nbsp; ：将标志寄存器的df位，置为1。原书P233（2）编程：用串传送指令，将F000H段的最后16个字符复制到data段中。assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 16 dup (0)data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 0f000h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0ffffh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov di, 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rep movsb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21hcode endsend start11.11 pushf 和 popfpushf 指令：将标志寄存器的值压栈。popf &nbsp;指令：从栈中弹出数据，送入标志寄存器中。11.12 标志寄存器在Debug中的表示用debug.exe查看当前标志寄存器的标志位值？用R指令，得到的信息右下角： NV&nbsp;&nbsp; UP&nbsp;&nbsp; EI&nbsp;&nbsp; PL&nbsp;&nbsp; NZ&nbsp;&nbsp; NA&nbsp;&nbsp; PO&nbsp;&nbsp; NC这些符号代表的就是标志寄存器里常用标志位的值。标志位寄存器，符号值对应表标志 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 值为1的标记 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;值为0的标记溢出标志OF(Over flow flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OV &nbsp;overflow&nbsp; &nbsp; &nbsp; &nbsp;NV方向标志DF(Direction flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;DN&nbsp; down&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;UP中断标志IF(Interrupt flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EI&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DI符号标志SF(Sign flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NG&nbsp; negative &nbsp; &nbsp; &nbsp; PL positive零标志ZF(Zero flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ZR&nbsp; zero&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NZ not zero辅助标志AF(Auxiliary carry flag) &nbsp; &nbsp; &nbsp; AC&nbsp; assist&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NA奇偶标志PF(Parity flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PE&nbsp;even &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PO odd进位标志CF(Carry flag) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CY carry &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;NC not carry实验11 编写子程序名称：letterc功能：将以0结尾的字符串中的小写字母转变成大写字母。参数：ds:si指向字符串首地址。源码：assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp; db &quot;Beginner&apos;s All-purpose Symbolic Instruction Code.&quot;, 0data endscode segment;letterc：&nbsp;&nbsp;&nbsp;&nbsp; 将以 0 结尾的字符串中的小写字母转换成大写;参数：ds:di 指向字符串首地址;返回：无letterc:&nbsp;&nbsp;&nbsp;&nbsp; ;暂存寄存器&nbsp;&nbsp;&nbsp;&nbsp; pushf&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, 0&nbsp;&nbsp; &nbsp;&nbsp;;!!!错误，jcxz测试的是cx是否为0！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[di] &nbsp; &nbsp; ;!!!错误，jcxz测试的是cx是否为0！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ascii: 61h - a, 7ah - z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 61h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jb next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp al, 7ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and byte ptr ds:[di], 11011111b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp r0&nbsp;&nbsp;&nbsp;&nbsp; ok:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp; popf&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call letterc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;code endsend startAtt - 汇编语言第十一章实验9.asm实验asm中有错：;jcxz测试的是cx是否为0！;实验代码中，ah/al应改为ch/cl！]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 7.5]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%207%20extra%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社课程设计1任务：将第八章的实验7的公司数据按照（原书的）图示10.2的格式，在屏幕上显示出来。参照：《Assembly Language》 Note 5&nbsp;实验7因为程序要显示的数据有些已经大于65535（16位word型能存的最大数），所以要编写一个新的数据转化为字符串的程序，dtoc的改进版，即第十章实验10.3的数字显示《Assembly Language》 Note 7。功能：将dword型数据转变成为表示十进制数的字符串，字符串以0为结尾符。参数：(ax)=dword型数据的低16位&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dx)=dword型数据的高16位&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ds:si指向字符串的首地址返回：无assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db 10 dup (0)data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 显示&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 614eh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 0bch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dtoc32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dh, 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dl, 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtoc32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s3: &nbsp; &nbsp; mov cx, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call divdw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 调用无溢出除法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add cx, 30h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 转换为ASCII码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存入栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 统计要显示几个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne s3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss3:pop ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop ss3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr ds:[si], 0 ; 写入字符串的结尾符e3:&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_str:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 0a0h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;bx 目标行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;di 目标列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;es 显示区内存位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah 另存颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2:&nbsp;&nbsp;&nbsp;&nbsp; cmp byte ptr ds:[si], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je e2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:[bx][di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp s2e2:&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 计算/10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4240h&nbsp;&nbsp; ;10000 = F4240H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 0fh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 0ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;10 = 0AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call divdw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divdw:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X/N = int(H/N) * FFFFH + [rem(H/N) * FFFFH + L] / N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X 是被除数， N是除数，H是被除数高位， L是被除数低位；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; * FFFFH 是左移位， int(x/n)是商，rem(x/n) 是余数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push ax ; 暂存被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;dx 被除数高位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存被除数高位被除的商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;dx 被除数高位被除的余数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存最后的余数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复被除数高位被除的商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 余数放在指定位置 cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retcode endsend startAtt - 汇编语言第十章实验10.3改进版.asm完整的解法：assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1975&apos;, &apos;1976&apos;, &apos;1977&apos;, &apos;1978&apos;, &apos;1979&apos;, &apos;1980&apos;, &apos;1981&apos;, &apos;1982&apos;, &apos;1983&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1984&apos;, &apos;1985&apos;, &apos;1986&apos;, &apos;1987&apos;, &apos;1988&apos;, &apos;1989&apos;, &apos;1990&apos;, &apos;1991&apos;, &apos;1992&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1993&apos;, &apos;1994&apos;, &apos;1995&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年的个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年公司总收入的 dword型数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw 11542, 14430, 15257, 17800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年公司雇员人数的个 word数据data endssbuf segment&nbsp;&nbsp;&nbsp; db 10 dup (0)sbuf endsemp_row segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 80 dup (&apos; &apos;)emp_row endstable segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 21 dup (&apos;year summ ne ?? &apos;)table endscode segmentstart:&nbsp;&nbsp;mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 21s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:2[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:2[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:84[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:5[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:86[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:7[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:168[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:10[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, es:5[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, es:7[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div word ptr es:10[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:13[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 数据间的间隔设为&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov al, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:4[di], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:9[di], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:12[di], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:16[di], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add bx, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add di, 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 刷新整个显示区域&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 80 * 24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov byte ptr ds:[di], &apos; &apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov byte ptr ds:[di+1], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 暂存循环计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;mov cl, 7h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 设置默认字体样式：黑底白字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cl, 42h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 为方便查看，改为更鲜艳的颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 求出目的行的偏移量&nbsp;&nbsp;&nbsp; mov al, 10h&nbsp;&nbsp;&nbsp; mul dl&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;;bx 目标行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;; 保存寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 显示年份&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dh, dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dl, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以下两行是：重点中的重点！很隐蔽的错误，我找了很久才发现……&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 要想想怎么避免这种错误。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop dx&nbsp;&nbsp;; 这句和下面那句都不能删掉！注意看，前四行修改了 dx！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;; 因为之后四行要用到原来的 dx，但又修改了dx，必须先恢复，再压栈一次！&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 显示收入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bh, dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bl,&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, ds:7[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:5[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_block32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop dx ; 恢复寄存器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 显示雇员数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bh, dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bl,&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:10[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_block16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 显示收入&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bh, dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bl,&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:13[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_block16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复循环计数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop s0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;参数：(ax)=dword 型数据的低位，;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dx)=dword 型数据的高位，;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (bh)= 行号0~24， (bl)=列号0~79 ，;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cl)= 颜色，ds:di指向字符串的首地址。;返回：无show_block32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 要显示的dword型数据已经放在 dx（高位），ax（低位）中&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, sbuf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dtoc32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 要显示的颜色已经放在 cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 显示的位置放在 bx中，bh 放行，bl放列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dh, bh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dl, bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret;参数：(ax)=dword 型数据的低位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dx)=dword 型数据的高位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ds:si 指向字符串的首地址;返回：无&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtoc32:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s32:&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 设置除数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call divdw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 调用无溢出除法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add cx, 30h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 转换为ASCII码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存入栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 统计要显示几个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne s32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne s32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss32:&nbsp;&nbsp;&nbsp;pop ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop ss32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr ds:[si], 0 ; 写入字符串的结尾符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;参数：(ax)=word 型数据，(bh)=行号 0~24，(bl)= 列号0~79，;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cl)= 颜色，ds:di指向字符串的首地址。;返回：无show_block16:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 要显示的word型数据已经放在 ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;;cx 已存放颜色的数据，所以暂存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, sbuf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call dtoc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;; 恢复cx原有数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 要显示的颜色已经放在 cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 显示的位置放在 bx中，bh 放行，bl放列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dh, bh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dl, bl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret;参数：(ax)=word 型数据，ds:si指向字符串的首地址。;返回：无dtoc:&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s3:&nbsp;&nbsp;&nbsp;&nbsp; mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add dx, 30h ; 转换为ASCII码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存入栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 统计要显示几个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmp ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jne s3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss3:&nbsp;&nbsp;&nbsp;&nbsp;pop ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop ss3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov byte ptr ds:[si], 0 ; 写入字符串的结尾符e3:&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;参数：(dh)= 行号0~24， (dl)=列号0~79 ，(cl)=颜色， ds:di指向字符串的首地址。;返回：无&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_str:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 因为dos自动刷新，会产生新行，刷掉顶端的一两行结果，所以最好&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 将显示区下移一行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add dh, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 0a0h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;bx 目标行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;di 目标列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;es 显示区内存位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah 另存颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2:&nbsp;&nbsp;&nbsp;&nbsp; cmp byte ptr ds:[si], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je e2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:[bx][di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp s2e2:&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;参数：(ax)=dword 型数据的被除数的低位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dx)=dword 型数据的被除数的高位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cx)=word 型除数;返回：(dx)= 结果的高位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ax)= 结果的低位;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (cx)= 余数&nbsp;divdw:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X/N = int(H/N) * FFFFH + [rem(H/N) * FFFFH + L] / N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X 是被除数， N是除数，H是被除数高位， L是被除数低位；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; * FFFFH 是左移位， int(x/n)是商，rem(x/n) 是余数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push ax ; 暂存被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; dx 被除数高位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存被除数高位被除的商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; dx 被除数高位被除的余数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 暂存最后的余数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复被除数高位被除的商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 余数放在指定位置 cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retcode endsend startAtt - 汇编语言第十章课程设计1.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 7]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%207%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章十、CALL和RET指令10.1 ret和retfret指令：用栈中的数据，修改IP的内容，从而实现近转移。retf指令：用栈中的数据，修改CS和IP的内容，从而实现远转移。执行ret指令的两步操作：（1）(IP) = &nbsp;((SS) * 16 + (SP))（2）(SP) = (SP) + 2相当于：pop IP执行retf指令的四步操作：（1）(IP) = ((SS) * 16 + (SP))（2）(SP) = (SP) + 2（3）(CS) = ((SS) * 16 + (SP))（4）(SP) = (SP) + 2相当于：pop ip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop cs10.2 call指令CPU执行call指令时，进行两步操作：（1）将当前的 “IP” 或者 “CS和IP同时” &nbsp;压入栈中。（2）转移。call指令不能实现短转移。它实现转移的方法与jmp原理相同。10.3 依据位移进行转移的call指令call 标号（将当前的IP压栈后，转到标号处执行指令）使用该指令时，CPU进行如下操作：（1）(sp) = (sp) - 2&nbsp; &nbsp; &nbsp; &nbsp; ((ss) * 16 + (sp)) = (ip)（2）(ip) = (ip) + 16位位移16位位移 = 标号处的地址 - call指令后的第一个字节的地址16位位移的范围：-32768~32767，用补码表示它由编译程序在编译时算出。相当于：pop IP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp near ptr 标号10.4 转移的（根据）目的地址在指令中的call指令“call far ptr 标号”实现的是段间转移。使用该指令时，CPU进行如下操作：（1）(sp) = (sp) - 2&nbsp; &nbsp; &nbsp; &nbsp; ((ss) * 16 + (sp)) = (cs)&nbsp; &nbsp; &nbsp; &nbsp; (sp) = (sp) - 2&nbsp; &nbsp; &nbsp; &nbsp; ((ss) * 16 + (sp)) = (ip)（2）(ip) = 标号所在段的段地址&nbsp; &nbsp; &nbsp; &nbsp; (cs) = 标号所在段中的偏移地址相当于：push cs&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push ip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp far ptr 标号（以上的两个自然段，之后不会再记这么拖拉重复的笔记方式，要更精简一点）10.5 转移地址在寄存器中的call指令call 16位reg相当于：push ip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp 16位reg10.6转移地址在内存中的call指令（1）call word ptr 内存单元地址相当于：push ip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp word ptr 内存单元地址（2）call dword ptr 内存单元地址相当于：push cs&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push ip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp word ptr 内存单元地址10.7 call 和 ret 的配合使用具有子程序的源程序的框架如下：assume cs:codecode segmentmain:&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call sub1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub1:&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call sub2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub2:&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retcode endsend main10.8 mul&nbsp;指令MUL 乘法指令, 使用它时请注意：（1）两个相乘的数：都是8位的长度，或都是16位的。如果是8位，一个默认放在AL中，另一个放在8位reg或内存byte字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存word字单元中。（2）乘积：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果的高位放在DX中，低位放在AX中。例：mul regmul 内存单元mul byte ptr ds:[0]mul word ptr [bx+si+8]10.9 模块化程序设计由call和ret支持10.10 参数和结果传递的问题10.11 批量数据的传递10.12 寄存器冲突的问题（这一节的书本内容不错，看原书方便，做笔记不便利。）其本质：&nbsp; &nbsp; &nbsp;用栈保存子程序要使用的寄存器。&nbsp; &nbsp; &nbsp;先push该子程序要使用的寄存器的内容，用完后再pop回原寄存器处。例：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;&nbsp;保存子程序要使用的寄存器的原内容capital: push cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;push si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;; 将以&apos;0&apos;为终结符的字符串的每个字符转换为大写change: &nbsp;mov cl, [si]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov ch, 0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jcxz ok&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;and byte ptr [si], 11011111b&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;inc si&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;jmp short change&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;;&nbsp;恢复子程序使用过的寄存器的原内容ok: &nbsp; &nbsp; &nbsp;pop si&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;pop cx&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ret实验10 编写子程序1.显示字符串（指定位置、颜色）功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。参数：(dh)=行号 0~24，(dl)=列号 0~79，(cl)=颜色，ds:di指向字符串的首地址。返回：无assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;Welcome to masm!&apos;,0data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 数据段位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 字符串首地址&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dh, 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 行&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dl, 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 列&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cl, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_str:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 求出目的行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov al, 0a0h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mul dh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;bx 目标行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 求出目的列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov al, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mul dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;di 目标列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;es 显示区内存位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ah, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;ah 另存颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp byte ptr ds:[si], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;je e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:[bx][di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jmp se:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retcode endsend start参照了：《Assembly Language》 Note 6&nbsp;的实验9Att - 汇编语言第十章实验10.1.asm2.解决除法溢出的问题功能：进行不会产生溢出的除法运算，&nbsp; &nbsp; &nbsp; 被除数为dword型，除数为word型，结果为dword型。参数：(ax)=dword型数据的被除数的低16位&nbsp; &nbsp; &nbsp; (dx)=dword型数据的被除数的高16位&nbsp; &nbsp; &nbsp; (cx)=word型除数返回：(dx)=结果的高16位&nbsp; &nbsp; &nbsp; (ax)=结果的低16位&nbsp; &nbsp; &nbsp; (cx)=余数例如：1000/1 的8位除法 或 11000/1 的16位除法&nbsp; &nbsp; &nbsp; 它们的商无法放入 al 或 ax 中，导致溢出。解法：assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 计算10000/10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4240h&nbsp;&nbsp;&nbsp;;10000 = F4240H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0fh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 0ah&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;10 = 0AH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call divdw&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;divdw:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X/N = int(H/N) * FFFFH + [rem(H/N) * FFFFH + L] / N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;X 是被除数， N是除数，H是被除数高位， L是被除数低位；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; * FFFFH 是左移位， int(x/n)是商，rem(x/n) 是余数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push ax&nbsp;; 暂存被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;dx 被除数高位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 暂存被除数高位被除的商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;dx 被除数高位被除的余数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复被除数低位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; mov cx, dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 余数放在指定位置 cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复被除数高位被除的商&nbsp; &nbsp; &nbsp; &nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retcode endsend startAtt - 汇编语言第十章实验10.2.asm3.数值显示功能：将word型数据转变成表示十进制数的字符串，字符串以0为结尾符。参数： (ax)=word型数据，ds:si指向字符串的首地址。返回：无应用：编程，将数据12666以十进制的形式在屏幕的8行3列，用绿色显示出来。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 显示时，使用本次实验的第一个子程序 show_ptr（见上文）。assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 10 dup (0)data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 显示&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 12666&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call dtoc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dh, 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dl, 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cl, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call show_str&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dtoc:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add dx, 30h ; 转换为ASCII码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 暂存入栈&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 统计要显示几个字符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmp ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jne s3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ss3:pop ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop ss3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov byte ptr ds:[si], 0&nbsp;; 写入字符串的结尾符e3:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop dx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_str:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 保存寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 0a0h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;bx 目标行的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 求出目的列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mul dl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;di 目标列的偏移量&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;es 显示区内存位置&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ah, cl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;ah 另存颜色&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2:&nbsp;&nbsp;&nbsp;&nbsp; cmp byte ptr ds:[si], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; je e2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:[bx][di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp s2e2:&nbsp;&nbsp;&nbsp;&nbsp; ; 恢复寄存器的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retcode endsend startAtt - 汇编语言第十章实验10.3.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 6]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%206%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章九、转移指令的原理可以修改IP，或同时修改CS和IP的指令统称为转移指令。8086CPU的转移行为有以下几类：（1）只修改IP时，称为段内转移。如，jmp ax。（2）同时修改CS和IP时，称为段间转移。如，jmp 1000:0。由于转移指令对IP的修改范围不同，段内转移又分为：（1）短转移：IP的修改范围为-128~127。（2）近转移：IP的修改范围为-32768~32767。（2的15次方=32768）8086CPU的转移指令分为以下几类：（1）无条件转移指令 （如：jmp）（2）条件转移指令（3）循环指令（如：loop）（4）过程（5）中断9.1 操作符offsetoffset是由编译器处理的符号，功能是取得标号的偏移地址。如：start:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, offset startextra：nop指令nop指令即“空指令”，在x86的CPU中机器码为0x90(144)。执行到NOP指令时，CPU什么也不做，仅仅当做一个指令执行过去并继续执行NOP后面的一条指令。所以NOP指令自然也会占用执行一个指令的CPU时间片，其机器码占 1 byte。常用于程序延时或精确计时，不过在较快的CPU上不明显。主要作用：（1）字节填充对齐（2）精确延时和计时（3）破解程序的call验证（4）等待其他设备执行完毕（5）清除由上一个算术逻辑指令设置的flag位（6）辅助jmp、call等指令9.2 jmp 指令它需要给出两种信息：（1）转移的目的地址；（2）转移的距离（段间转移、段内短转移、段内近转移）。9.3 依据位移进行转移的jmp指令CPU执行jmp short指令的时候，并不需要转移的目的地址，而是要转移的位移，就是执行此指令时的ip，到所要转移到的指令的内存地址的距离。例：jmp short start段内短转移： jmp short&nbsp; 标号（跳转到标号处执行指令）功能为：( IP ) = ( IP ) + 8位位移（1）8位位移 = 标号处的地址 - jmp short 指令后的第一个字节的地址；（标号，即如，之前常用start）（2）short指明此处的位移为8位位移（3）8位位移范围：-128~127；用补码表示。（4）8位位移由编译程序在编译时算出。段内近转移：jmp near ptr 标号（跳转到标号处执行指令）功能为：（IP）=（IP）+ 16位位移（1）（2）（4）等的特征，类同上（3）范围为-32768~32767，…9.4 转移的目的地址在指令中的jmp指令（CS）= 标号所在段的段地址；（IP）= 标号所在段的偏移地址far ptr指明用标号的段地址和偏移地址修改CS和IP。例：-u...00BD:0005 EB03&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMP&nbsp;&nbsp;&nbsp;&nbsp; 0008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // jmp short 标号，用相对位移00BD:0006 EA0B01BD0B&nbsp;&nbsp;&nbsp;&nbsp; JMP&nbsp;&nbsp;&nbsp;&nbsp; 0BBD:010B&nbsp;&nbsp;&nbsp;&nbsp; // jmp far ptr 标号，用内存地址... // 上一条指令的低地址存偏移地址，高地址存段地址9.5 转移地址在寄存器中的jmp指令格式：jmp 16位reg功能：（IP） = （16位reg），根据16位reg修改IP寄存器（reg）的内容例子：jmp ax含义：mov IP, ax9.6 转移地址在内存中的jmp指令有两种类型：（1）jmp word ptr 内存单元地址（段内转移）内存单元地址处，存放着一个word，是转移的目的偏移地址。例：jmp word ptr ds:[0]（2）jmp dword ptr 内存单元地址（段间转移）内存单元地址处，存放着一个dword（两个word），低地址存偏移地址，高地址存段地址。检测点9.1：（1）要使jmp指令之后，CS:IP指向程序的第一条指令，该在data段定义什么数据assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db 0 // 在测试时，此处是078A:0000data endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp; // 在测试时，此处是078B:0010 = 078A:0000，因为078BH * 10H = 078AH * 10H + 10H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp word ptr 1[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start（2）要使jmp指令之后，CS:IP指向程序的第一条指令，该在MOV [BX]和MOV 2[BX]处补全些什么。assume cs:codedata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dd 12345678Hdata endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr [bx], 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov word ptr 2[bx], cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp dword ptr ds:[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start检测点9.2：补全程序（补全位置为s标号紧接着的四行），利用jcxz指令，实现在内存2000H段中寻找第一个值为0的字节。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 2000H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ch, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, [bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jcxz ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp short sok:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start9.7 jcxz指令： 有条件转移指令。所有有条件转移指令，都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是-128~127。指令格式：jcxz 标号功能：当（cx）= 0时，（IP）=（IP）+ 8位位移。其它：类同jmp short。9.8 loop指令：循环指令，所有的循环指令都是短转移，其它说明类同上。指令格式：loop 标号功能：（1）（cx）=（cx）- 1（2）当（cx）!= 0时，（IP）=（IP）+ 8位位移。其它：类同jmp short。dec指令：与inc指令相反，dec bx功能为(bx) = (bx) - 1检测点9.3：补全程序（加粗的那一行），利用loop指令，实现在内存2000H段中寻找第一个值为0的字节。assume cs:codecode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 2000H&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ch, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cl, [bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop sok:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dec bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx, bx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend start9.9 根据位移进行转移的意义因为这样做，程序无论放在内存哪里，都可以根据相对位移去执行jmp；一旦写死了跳转地址，那么程序就必须放在指定位置才能正常执行了！9.10&nbsp; 编译器对转移位移的超界检测根据位移进行转移的指令，它们转移范围有限制，如-128~127。如果源程序中出现了转移范围超界的问题，编译器会报错。例：start:&nbsp; jmp short s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db 128 dup (0)s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0ffffh实验8 分析一个奇怪的程序assume cs:codecode segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hstart:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, offset s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, offset s2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs:[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cs:[di], axs0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp short ss1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0s2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp short s1&nbsp;&nbsp; // jmp short使用的是相对位移。二进制编码为：EBF6。F6表示-10的位移。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nop&nbsp; // 当上一句指令被拷贝到标号s处时，意义就不同了，变成了跳到cs:[0]处了！code ends&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 8位位移 = 标号处的地址 - jmp short 指令后的第一个字节的地址end start实验9 根据材料编程材料比较繁多，最好阅读原书题目。可以增进知识。（后来，下文增加原书材料的相片）任务：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串‘welcome to masm!’。assume cs:code, ds:data, ss:stackdata segment&nbsp;&nbsp;&nbsp;&nbsp; db &apos;welcome to masm!&apos;&nbsp;&nbsp;&nbsp;&nbsp; db 27h, 42h, 01h, 13 dup (0)data endsstack segment&nbsp;&nbsp;&nbsp;&nbsp; dw 8 dup (0)stack endscode segmentstart:&nbsp;&nbsp;&nbsp;&nbsp; mov ax, stack&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ss, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov sp, 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 0b800h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 6e0h ;1760bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 3s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bp, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s0:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:[bp]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:40h[di][bx], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al, ds:10h[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov es:41h[di][bx], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc di&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc bp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop s0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add bx, 0a0h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; loop s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend startAtt - 汇编语言第九章实验9.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 5]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%205%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章八、数据处理的两个基本问题（1）处理的数据在什么地方？（2）要处理的数据有多长？reg寄存器：ax、bx、cx、dx，ah、al、bh、bl、ch、cl、dh、dl，sp、bp、si、di。sreg（segment register）段寄存器：ds、ss、cs、esreg、sreg详见：《Assembly Language》 Note 28.1 bx，si，di 和 bp（1）8086CPU中，只有这4个寄存器可以用在”[...]“中来进行内存单元的寻址。（2）在 [...] 中，这4个寄存器可以单个出现，或只能以4种组合出现：bx + si、bx + di、bp + si 和 bp + di。（3）只要在 [...] 中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。8.2 机器指令处理的数据在什么地方绝大部分的机器指令都是进行数据处理的指令，大致可分为 3 类：读取、写入、运算。机器指令不关心数据的值，而关心指令执行前一刻，它要处理的数据的位置。数据可以在 3 个地方：CPU内部、内存、端口（端口以后详述）。8.3 汇编语言中数据位置的表达（1）立即数（idata）即是，直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）。例： 1 &nbsp; &nbsp; 2000h &nbsp; &nbsp; 00010000b &nbsp; &nbsp; ‘abc’（2）寄存器：ax、ss（3）段地址（SA）和 偏移地址（EA）例：[0] &nbsp; &nbsp; [bx] &nbsp; &nbsp; [bx+si] &nbsp; &nbsp; [bp+di+8]8.4 寻址方式上一篇笔记的7.5处开始：《Assembly Language》 Note 48.5 指令要处理的数据有多长8086CPU的指令，可以处理两种尺寸的数据，byte和word。机器指令中，要指明是 字操作 或 字节操作。汇编语言判断操作数据长度的办法如下：（1）通过寄存器名指明：mov bx, ds:[0] &nbsp; &nbsp; // bx寄存器是两字节的，字操作mov al, 1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // al寄存器是一字节的，字节操作（2）没有寄存器名的情况下，用操作符 “&nbsp;X ptr&nbsp;”指明内存单元的长度，在汇编指令中，X可以为word或byte。mov word ptr ds:[0], 1inc byte ptr ds:[0]add byte ptr [bx], 8（3）其它有些指令默认了访问的是word字单元还是byte字节单元。push [1000h] 操作的是word字单元，因为push指令只进行word字操作8.7 div指令：除法指令。（1）除数：有8位和16位两种，在一个reg或内存单位中。（2）被除数：默认 只放在AX&nbsp;或 放在DX和AX&nbsp;中。如果除数为8位，则被除数为16位，且默认在AX中存放；如果除数为16位，则被除数为32位，且在DX和AX中存放，DX放高16位，AX放低16位。（3）计算结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。例：100001 除以 100—— 因为被除数大于65535=2^16，那么除数100要用16位来存：mov dx, 1mov ax, 86a1h &nbsp; &nbsp; // dx * 10000H + ax = 186A1H = 10001mov bx, 100div bx &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // div 指令跟着的只有一个参数，是除数8.8 伪指令 dddb 定义byte字节型数据。dw 定义word字型数据。dd 定义dword双字型数据。（double word）8.9 dup操作符在汇编语言中，dup同db，dw，dd等一样，也是由编译器识别处理的符号。例：db 3 dup (0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;定义3个字节，每个都是0，相当于 db 0, 0, 0db 3 dup (0, 1, 2) &nbsp; 定义9个字节，它们是0, 1, 2,&nbsp;0, 1, 2,&nbsp;0, 1, 2。n为重复的次数db &nbsp;n &nbsp;dup （重复的byte型data）dw &nbsp;n &nbsp;dup （重复的word型data）dd &nbsp;n &nbsp;dup &nbsp;（重复的dword型data）实验7 寻址方式在结构化数据访问中的应用题目要求请看原书：assume cs:code, ds:datadata segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1975&apos;, &apos;1976&apos;, &apos;1977&apos;, &apos;1978&apos;, &apos;1979&apos;, &apos;1980&apos;, &apos;1981&apos;, &apos;1982&apos;, &apos;1983&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1984&apos;, &apos;1985&apos;, &apos;1986&apos;, &apos;1987&apos;, &apos;1988&apos;, &apos;1989&apos;, &apos;1990&apos;, &apos;1991&apos;, &apos;1992&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db &apos;1993&apos;, &apos;1994&apos;, &apos;1995&apos;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年的个字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年公司总收入的 dword型数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dw 11542, 14430, 15257, 17800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; 以上是表示年公司雇员人数的个 word数据data endstable segment&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db 21 dup (&apos;year summ ne ?? &apos;)table endscode segmentstart:&nbsp;&nbsp;mov ax, data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es, ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov di, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov si, 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov cx, 21s:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:2[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:2[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:84[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:5[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:86[bx]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:7[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, ds:168[si]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:10[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, es:5[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov dx, es:7[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;div word ptr es:10[di]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov es:13[di], ax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add bx, 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add di, 16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inc si&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loop s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 21hcode endsend startAtt - 汇编语言第八章实验7.asm]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 4]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%204%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章六、包含多个段的程序程序取得所需空间的方法：（1）在加载程序的时候为程序分配。（2）在执行过程中向系统申请。（本教材不讨论该方法）6.1 在代码段中使用数据assume cs:codecode segment&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...start: &nbsp;program&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...code endsend start末尾指定程序入口——加载者从程序的可执行文件的描述信息中读到程序的入口地址。&nbsp;指令：dw 0123h, 0456h, ..., 0987hdw的含义——定义字型数据，即define word。assume cs:codecode segment&nbsp; &nbsp; &nbsp;dw 0123h, 0456h, ..., 0987h&nbsp; &nbsp; &nbsp;...code endsend这些数据现在存储于CS:0~CS:x。以cs为基址，偏移得到。6.2 在代码段中使用栈可以使用dw 0, 0, 0, ..., 0的方式，开辟内存空间，然后可以用来存放数据，可以作为栈使用。assume cs:codecode segment&nbsp; &nbsp; &nbsp;dw 0123h, 0456h, ..., 0987h（8个字数据）&nbsp; &nbsp; &nbsp;dw 0,0,0, ... , 0（16个字数据）st: &nbsp;mov ax, cs&nbsp; &nbsp; &nbsp;mov ss, ax&nbsp; &nbsp; &nbsp;mov sp, 30h（前面dw使用了24words，共48bytes，即30H bytes）&nbsp; &nbsp; &nbsp;// 这样栈就出现了~&nbsp; &nbsp; &nbsp;...code endsend st6.3 将数据、代码、栈放入不同的段把数据、代码、栈等放到一个段：（1）程序显得杂乱（2）如果它们所需的空间超过64KB（8086CPU的限制），就不能放到一个段里面了。通过定义数据来获取内存空间，定义多个段：assume cs:code, ds:data, ss:stackdata segment&nbsp; &nbsp; &nbsp;dw 0123h, 0456h, ..., 0987hdata endsstack segment&nbsp; &nbsp; &nbsp;dw 0,0,0, ... , 0stack endscode segmentstart: &nbsp; &nbsp; mov ax, stack ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mov ax, data&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...code endsend start实验6 编写、调试具有多个段的程序Att - 实验题5(5).asmdb 1, 2, 3, 4, 5, ... // define bytedw 1ah, 2bh, 3ch, ... // define wordAtt - 实验题5(6).asm例：mov ax, [bx + 200] 等于 mov ax, [si +200] 以及 mov ax, [di +200]。章七、更灵活的定位内存地址的方法7.1 and 和 or 指令（1）and指令：逻辑与，按位进行与运算。（2）or指令：逻辑或，....。mov al, 01100011Band &nbsp;al, 00111011B&nbsp;// 后缀B代表这是二进制串or &nbsp; &nbsp; al, 00111011B7.2 ASCII7.3 以字符形式给出的数据可以在汇编程序中，用&nbsp;&apos;xxxx&apos; 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码。例：data segment&nbsp; &nbsp; &nbsp;db &apos;unIX&apos;&nbsp; &nbsp; &nbsp;db &apos;foRK&apos;data endscode segmentstart:&nbsp; &nbsp; &nbsp;mov al, &apos;a&apos;&nbsp; &nbsp; &nbsp;mov bl, &apos;b&apos;&nbsp; &nbsp; &nbsp;...code endsend start7.4 大小写转换问题字母 &nbsp; &nbsp; 16进制 &nbsp; &nbsp; 10进制 &nbsp; &nbsp; 二进制A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;41 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;65 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01000001...Z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;90 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;01011010a &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;61 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;97 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 01100001...z &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;7A &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;122 &nbsp; &nbsp; &nbsp; &nbsp; 01111010看得出来大写字母的编码比小写字母小了10000B，即十进制的32，十六进制的20H。那么大写字母转换成小写字母可以：mov [bx], &apos;A&apos;or [bx], 00100000B那么小写字母转换成大写字母可以：mov [bx], &apos;a&apos;and [bx], 11011111B[idata] 直接寻址[bx] 间接寻址7.5&nbsp;[bx + idata] 相对寻址可以用[bx]指明一个内存单位，还有更为灵活的方式：[bx + idata]。如，[bx + 200]，或 [200 + bx]。7.6 用[bx + idata]的方式进行数组的处理7.7 SI 和 DI （寄存器）si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用，但bx可以分为bl和bh。]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 3]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%203%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章四、第一个程序4.2 源程序 例：assume cs:codesgcodesg segment&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;mov ax, 0123H&nbsp; &nbsp; &nbsp;...&nbsp; &nbsp; &nbsp;add ax, bx&nbsp; &nbsp; &nbsp;int 21Hcodesg endsend汇编指令：有对应机器码的指令，可以被译为机器指令，被CPU执行。伪指令：没有对应机器码的指令，是由编译器来执行的指令，编译器根据它来进行相关编译工作。伪指令，如：（1） segment ... ends成对使用，用于定义一个段。xxx segment&nbsp; &nbsp; &nbsp;...xxx ends一个汇编程序，由多个段组成。这些段，用于存放代码、数据、或当作栈空间使用。（2）end汇编程序的结束标记。编译程序碰到伪指令end就会停止对源程序的编译。（3）assume含义为：“假设”。假设某一段寄存器和程序中某一个用segment...ends定义的段相关联。4.4 编译源文件后缀：“.asm”masm：微软的masm5.0汇编编译器。（下载链接：http://download.pchome.net/development/linetools/down-9028-1.html）编译过程中，我们提供源程序文件，最多可以得到3个输出：目标文件.obj、列表文件.lst、交叉引用文件.crf。（后两个是中间结果，在汇编语言课程中，不讨论它们）4.5 连接使用微软的Overlay Linker3.60连接器。连接过程中，需要目标文件.obj、库文件.lib（可能没有），产生exe，还有中间结果映像文件.map。4.6 以简化的方式进行编译和连接输入以下指令，进行编译、连接、运行：masm path\src_file_name;link path\obj_file_name:exe_name*. 重点：masm、link指令后面加上分号“ ; ”就可以跳过中间输入参数的过程4.8 谁将exe中的program装载入内存并使它运行？任何通用的操作系统，都要提供一个称为shell（外壳）的程序，用户使用此程序来操作计算机系统进行工作。DOS中有一个程序command.com，称为命令解释器，就是DOS的Shell程序。用户要执行一个程序：command.com根据输入的文件名找到exe；将exe中的program加载入memory；设置CS:IP（两个寄存器）指向程序的入口；command.com停止运行，CPU运行被调用的程序；运行结束后，返回到command中，等待用户再次输入。4.9程序执行过程的跟踪debug.exe可以将程序加载入内存，设置CS:IP指向程序的入口，但并不放弃对CPU的控制，所以可以单步执行程序，查看每条指令的执行结果。单步的时候，使用T指令，但到了最后一条指令 int 21时，使用P指令。（暂时不要理会that&apos;s why）Q指令：退出debug.exe。章五、[BX]和loop指令[offset]——指一个内存单元的地址，段地址在DS（data segment）段寄存器中，偏移量是&quot;[ ]&quot;中的数字，地址实际是 DS * 16 + offset，即DS * 10H + offset，即DS内的数（16进制）左移一位再与offset相加。(pos)——表示一个寄存器或一个内存单元中的内容。(ax)表示ax中的内容，(al）表示al里的内容。“( )”中的元素有三种：1.寄存器名；2.段寄存器名；3.内存单元物理地址（一个20bits的数据）“( )”所表示的数据有两种类型：1.字节；2.字。属于哪一种类型由寄存器名或具体的运算决定。约定idata表示常量。mov ax, [idata] 就代表 mov ax, [3]... 等。5.2 loop指令，例&nbsp; &nbsp; &nbsp;mov ax, 2&nbsp; &nbsp; &nbsp;mov cx, 11s: &nbsp; add ax, ax&nbsp; &nbsp; &nbsp;loop s &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// s是标号&nbsp; &nbsp; &nbsp;...（1）标号，在汇编语言中，代表一个地址（标识了一个地址）。（2）CPU执行loop s，要进行两步操作：&nbsp; &nbsp; &nbsp;a. (cx) = (cx) - 1&nbsp; &nbsp; &nbsp;b. 判断(cx) 的值，不为0，则转至标号s所标识的地址处执行，即add ax, ax。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 若为0，则执行吓一跳指令，即loop s之后的指令。5.3 在Debug中跟踪用loop指令实现的循环程序大于9FFFH（最后一位H，表示该数为16进制数）的十六进制数，如A000H、B001H、...、FFFFH等，在书写中都是以字母开头的。而在汇编语言中，数据不能以字母开头，所以要在开头加上数字0。Debug程序的G命令：g 0012 ：将程序运行到CS:0012这个地方。P命令：在遇到 loop xxx 的loop指令语句时，使用P命令，debug就会自动将程序一直运行，直到(cx) == 0，然后，指向loop的下一条指令。5.4 Debug和汇编编译器masm对指令的不同处理在汇编程序中，指令“mov ax, [0]”被编译器当作指令“mov ax, 0”处理。Debug将其解释为[idata]是一个内存单元，“idata”是内存单元的偏移地址；而编译器将[idata]解释为idata。那么怎么让写的程序，用汇编编译器也能使用相对寻址？目前方法：将偏移地址送入bx（base 段寄存器）寄存器中，再用[bx]的编写方式，就可以来访问DS:(bx)的内存单元。更好的方法：这么写指令“mov al&nbsp;ds:[0]”，显式地给出段地址所在的段寄存器5.6 段前缀出现在访问内存单元的指令中，用于显式地指明内存单元的段地址。如：ds:、cs:、ss:、es:。5.7 一段安全的空间DOS方式下，DOS和其它合法的程序一般都不会使用0:200~0:2ff（00200H~002ffH）的256bytes的空间。实验4 [bx]和loop的使用（1）编程，向内存0:200~0:23F依次传送0~63（3FH）。（2）进阶要求：只能使用9条指令，包括mov ax, 4c00h 和 int 21h。assume cs:codecode segment&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 20h&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 40hs: &nbsp; mov ds:[bx], bx&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop s&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend（3）将程序mov ax, 4c00h之前的指令复制到内存0:200处。assume cs:codecode segment&nbsp;&nbsp;&nbsp;&nbsp; mov ax, cs&nbsp;&nbsp;&nbsp;&nbsp; mov ds, ax&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 20h&nbsp;&nbsp;&nbsp;&nbsp; mov es, ax&nbsp;&nbsp;&nbsp;&nbsp; mov bx, 0&nbsp;&nbsp;&nbsp;&nbsp; mov cx, 22s:&nbsp;&nbsp;&nbsp;mov al, ds:[bx]&nbsp;&nbsp;&nbsp;&nbsp; mov es:[bx], al&nbsp;&nbsp;&nbsp;&nbsp; inc bx&nbsp;&nbsp;&nbsp;&nbsp; loop s&nbsp;&nbsp;&nbsp;&nbsp; mov ax, 4c00h&nbsp;&nbsp;&nbsp;&nbsp; int 21hcode endsend]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 2]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%202%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社拓展阅读——大小端问题：32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：内存地址0x40000x40010x40020x4003存放内容0x780x560x340x12而在Big-endian模式CPU内存中的存放方式则为：内存地址0x40000x40010x40020x4003存放内容0x120x340x560x78联合体union的存放顺序是所有成员都从低地址开始存放。8086CPU的寄存器：8086 有14个16位寄存器，这14个寄存器按其用途可分为(1)通用寄存器、(2)指令指针、(3)标志寄存器和(4)段寄存器等4类。通用寄存器是那些你可以根据自己的意愿使用的寄存器，修改他们的值通常不会对计算机的运行造成很大的影响。有8个, 又可以分成2组，一组是数据寄存器(4个),另一组是指针寄存器及变址寄存器(4个).数据寄存器分为：AH&amp;AL=AX(accumulator)：累加寄存器，常用于运算;在乘除等指令中指定用来存放操作数，另外,所有的I/O指令都使用这一寄存器与外界设备传送数据。BH&amp;BL=BX(base)：基址寄存器，常用于地址索引CH&amp;CL=CX(count)：计数寄存器，常用于计数；常用于保存计算值，如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.DH&amp;DL=DX(data)：数据寄存器，常用于数据传递。他们的特点是，这4个16位的寄存器可以分为高8位: AH, BH, CH, DH.以及低八位：AL,BL,CL,DL。这2组8位寄存器可以分别寻址，并单独使用。指针寄存器和变址寄存器，包括：SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置BP（Base Pointer）：基址指针寄存器，可用作SS的一个相对基址位置SI（Source Index）：源变址寄存器，可用来存放相对于DS段之源变址指针DI（Destination Index）：目的变址寄存器，可用来存放相对于ES 段之目的变址指针。这4个16位寄存器只能按16位进行存取操作，主要用来形成操作数的地址，用于堆栈操作和变址运算中计算操作数的有效地址。指令指针IP指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加(取出该字节的长度，如：BIU从内存中取出的是1个字节，IP就会自动加1，如果BIU从内存中取出的字节数长度为3，IP就自动加3)，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。标志寄存器8086有一个16位的标志性寄存器FR，在FR中有意义的有9位，其中6位是状态位，3位是控制位。标志寄存器（Flags Register,FR）又称程序状态字(Program Status Word,PSW)。这是一个存放条件标志、控制标志寄存器，主要用于反映处理器的状态和运算结果的某些特征及控制指令的执行。标志寄存器位置图：[5]&nbsp;1514131211109876543210OFDFIFTFSFZFAFPFCFOF：溢出标志位OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。DF：方向标志DF位用来决定在串操作指令执行时有关指针寄存器发生调整的方向。IF：中断允许标志IF位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。具体规定如下：(1)当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求(2)当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。TF：跟踪标志TF。该标志可用于程序调试。TF标志没有专门的指令来设置或清除。（1）如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。（2）如果TF=0，则处于连续工作模式。SF：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为非负数时，SF的值为0，否则其值为1。当运算结果没有产生溢出时，运算结果等于逻辑结果（即应该得到的正确的结果），此时SF表示的是逻辑结果的正负，当运算结果产生溢出时，运算结果不等于逻辑结果，此时的SF值所表示的正负情况与逻辑结果相反，即：SF=0时，逻辑结果为负，SF=1时，逻辑结果为非负。ZF：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果，是否为0时，可使用此标志位。AF：( Assistant Carry Flag)下列情况下，辅助进位标志AF的值被置为1，否则其值为0：(1)、在字操作时，发生低字节向高字节进位或借位时(2)、在字节操作时，发生低4位向高4位进位或借位时。PF：奇偶标志PF用于反映运算结果中“1”的个数的奇偶性。如果“1”的个数为偶数，则PF的值为1，否则其值为0。CF：进位标志CF主要用来反映无符号数运算是否产生进位或借位。如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。段寄存器为了运用所有的内存空间，8086设定了四个段寄存器，专门用来保存段地址：&nbsp;CS（Code Segment）：代码段寄存器DS（Data Segment）：数据段寄存器SS（Stack Segment）：堆栈段寄存器ES（Extra Segment）：附加段寄存器。当一个程序要执行时，就要决定程序代码、数据和堆栈各要用到内存的哪些位置，通过设定段寄存器CS，DS，SS 来指向这些起始位置。通常是将DS固定，而根据需要修改CS。所以，程序可以在可寻址空间小于64K的情况下被写成任意大小。所以，程序和其数据组合起来的大小，限制在DS 所指的64K内，这就是COM文件不得大于64K的原因。8086以内存作为战场，用寄存器做为军事基地，以加速工作。备注：由于所讲的是16位cpu(IP寄存器的位数为16，即：偏移地址为16位)2的16次幂就是64K，所以16位段地址不能超过64K，超过64K会造成64K以上的地址找不到。章三、寄存器（内存访问）3.1 内存中的存储字单元word：即存放一个字型数据（在8086CPU中为16位，根据CPU的位数决定）的内存单元，由位数/8个地址连续的内存单元组成。起始地址位N的字单元简称为：N地址单元。3.2 DS和[address]DS是数据段寄存器，8086CPU不支持将数据直接送入段寄存器的操作，所以只好通过一个寄存器中转，以写入。[address]，即是与CS：IP类似，DS存的是段地址，address指的是地址的偏移值。用该方式获取的是从该地址起始的字型数据（非字节数据）。3.7 CPU提供的栈机制8086CPU的push和pop操作都是以字为单位进行的。段寄存器任意时刻，SS:SP指向栈顶元素。8086CPU对栈上溢和下溢没有防范，需要编程者自己小心编码。问题3.7-3.10等的是拿来练手，熟悉汇编的。现做一下3.9——交换ax和bx中的值：每当SS段寄存器被修改时，下一条指令也会紧跟着被执行！]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASM 汇编语言 1]]></title>
    <url>%2Fasm%2FAssembly%20Language%20-%20Note%201%2F</url>
    <content type="text"><![CDATA[Created on 2014-10教材：《汇编语言》（第二版）王爽 著 清华大学出版社章一、基础知识1.3 汇编语言的组成：（1）汇编指令：机器码的助记符。（核心）（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。（3）其它符号：如+、-、*、/等，由编译器识别，没有对应的机器码。1.7 CPU对储存器的读写总线从逻辑上分3类：地址线、数据线、控制线。章二、寄存器2.2 字在寄存器中的存储低字节：权越小，越低。个位的数字的权是1，十位的权是2，百位的权是4，如此类推。高字节：权比较大的位（该位的数字代表的分量较大），即为高字节。与此相关的是——大小端、网络字节序2.3指令的两个操作对象的位数应该一致。2.9 段寄存器8086CPU有四个段寄存器：CS、DS、SS、ES。2.10 CS和IPCS为代码段（code segment?）寄存器，IP为指令指针（instruction ptr?）寄存器。任意时刻CPU将CS:IP指向的内容当作指令执行。2.11 修改CS、IP的指令jmp指令：jmp 段地址:偏移地址 —— jmp 2AE3:38086CPU的工作过程：（1）从CS:IP指向的内存单位读取指令，读取的指令进入指令缓存器（2）IP指向下一条指令（3）执行指令。（转到步骤（1），重复这个过程）Chapter2 实验1 查看CPU和内存，用机器指令和汇编指令编程Debug是DOS、Windows都提供的实模式（8086方式）程序的调试工具。它可以查看CPU各种寄存器的内容、内存的情况和在机器码级跟踪程序的运行。使用工具：win7 64位系统怎么使用debug指令R &nbsp; &nbsp; 查看、改变CPU寄存器的内容D &nbsp; &nbsp; 查看内存中的内容E &nbsp; &nbsp; 改写内存中的内容U &nbsp; &nbsp; 将内存中的机器指令翻译成汇编指令T &nbsp; &nbsp; 执行一条（CS:IP指向的）机器指令A &nbsp; &nbsp; 以汇编指令的格式，在内存中写入一条机器指令G &nbsp; &nbsp; 跳转执行到指定的内存位置P &nbsp; &nbsp; 程序执行到最后一步，必须使用的指令通用寄存器：ax,bx,cx,dx段寄存器：ds,es,ss,cs偏移地址寄存器：sp.ip,bp,si,di标志寄存器：flag熟悉基础操作过程的截图：实验任务：（1）（2）计算2的8次方。(在内存2000:0开始写该程序）mov ax, 1add ax, axadd ax, axadd ax, ax&nbsp; &nbsp; &nbsp;ormov ax, 1add ax, axjmp 2000:3 &nbsp; &nbsp; (暂时的知识不足以写出循环控制语句！)（3）结论：内存FFF00H~FFFFFH为ROM区,内容可读但不可写。（4）结论：8086的显存地址空间是A0000H～BFFFFH,其中B8000H～BFFFFH为80*25彩色字符模式显示缓冲区,当向这个地址空间写入数据时,这些数据会立即出现在显示器上。]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Windows7 64 位系统上使用 debug.exe]]></title>
    <url>%2Fasm%2F%E5%9C%A8win7%2064%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8A%E4%BD%BF%E7%94%A8debug.exe%2F</url>
    <content type="text"><![CDATA[安装DOSbox软件http://dl.pconline.com.cn/html_2/1/85/id=10233&amp;pn=0&amp;linkPage=1.html下载个debug.exe然后把这放到C盘的根目录下http://www.pc6.com/SoftView/SoftView_26159.html#download然后启动dosbox软件，在下面输入mount c C:\ enter键c: enter键输入debug命令就ok了然后就可使用了masm：微软的masm5.0汇编编译器。（下载链接：http://download.pchome.net/development/linetools/down-9028-1.html）]]></content>
      <categories>
        <category>ASM</category>
      </categories>
      <tags>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Batch 批处理指令]]></title>
    <url>%2Fbatch%2FBatch%20%E6%89%B9%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%20Command%2F</url>
    <content type="text"><![CDATA[Better Ref: 《Windows批处理(cmd/bat)常用命令小结》todobat资料from：网页简明bat教程本地.bat批处理命令简明教程简便句式cmd0 &amp;&amp; cmd_suc &#166;&#166; cmd_failedcmd0指令成功，则执行cmd_suc，否则执行cmd_failed。（例）call php x.php &amp;&amp; echo suc. &#166;&#166; echo failed!rem &nbsp; &nbsp; 注释。（算是一条指令）可以作为空指令使用~::&nbsp; &nbsp; &nbsp;注释。（纯粹的注释）&#64; &nbsp; &nbsp; 不显示当前行的指令echo on/off &nbsp; &nbsp; 回显开关echo. &nbsp; &nbsp; 显示空行（注意：指令最后带一个英文句号！）pause &nbsp; &nbsp; 暂停执行，会显示 “按任意键退出”pause&gt;nul &nbsp; &nbsp; 将显示的内容重定向到nul，即不显示“按任意键退出”nul&nbsp;的官方解释是 &quot;空设备&quot;&lt;nul &nbsp; &nbsp; 回车但不换行&gt;nul &nbsp; &nbsp; 是屏蔽命令的输出内容goto tag &nbsp; &nbsp; 跳转到标签位:tag &nbsp; &nbsp; 冒号后面跟着标签号call bat_file_path &nbsp; &nbsp; 调用另一个批处理文件start &nbsp; &nbsp; 调用外部程序choice /c ync /d default_choice /l limit_time &nbsp; &nbsp; 提示用户输入字符，再据此决定下一步操作。&#37;n &nbsp; &nbsp; 调用.bat时的第n个参数，n为1~9（只能有9个）shift &nbsp; &nbsp; 偏移位置去获取其它参数在批处理文件中pushd &nbsp; &nbsp; 保存当前路径popd &nbsp; &nbsp; 恢复上一个路径mklink &nbsp; &nbsp; 添加符号连接或硬连接path &nbsp; &nbsp; 显示或(暂时)改变(局部的)环境变量pathsetx &nbsp; &nbsp; (长期)设置环境变量setlocal &nbsp; &nbsp; 在批处理文件中，开始将运行环境局部化endlocal &nbsp; &nbsp; 在批处理文件中结束对本地环境特征的修改exit &nbsp; &nbsp; 退出exit&nbsp;&#37;exitCode&#37; &nbsp; &nbsp; 退出cmd.exe时，设置exitCode&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;为&#37;exitCode&#37;exit /b &#37;ret&#37; &nbsp; &nbsp; 退出并设置.bat文件的errorlevel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;（错误返回码）为&#37;ret&#37;&gt; &nbsp; &nbsp; FOR语句for /d /r /l&nbsp;/f&nbsp; &nbsp; 即dir/recursive/file 等FOR {&#37;variable&#166;&#37;&#37;variable} in (set) do command [CommandLineOptions]&#37;variable 指定一个单一字母可替换的参数。(set) 指定一个或一组文件。可以使用通配符。command 指定对每个文件执行的命令。FOR /R [[drive:]path] &#37;variable IN (set) DO command [CommandLineOptions]检查以 [drive:]path 为根的目录树，指向每个目录中的FOR 语句。如果在 /R 后没有指定目录，则使用当前目录。如果集仅为一个单点(.)字符，则枚举该目录树。FOR /L &#37;variable IN (start,step,end) DO command [command-param]FOR /F [&quot;options&quot;] &#37;variable IN (file-set) DO command&nbsp; &nbsp; &nbsp;//注意：圆括号内的参数 没带引号！FOR /F [&quot;options&quot;] &#37;variable IN (&quot;string&quot;) DO command&nbsp;&nbsp; &nbsp; //注意：圆括号内的参数 带双引号！FOR /F [&quot;options&quot;] &#37;variable IN (&apos;command&apos;) DO command&nbsp;&nbsp; &nbsp; //注意：圆括号内的参数 带单引号！options中的设置：eol=c - 指一个行注释字符的结尾(就一个)&nbsp; &nbsp; &nbsp;如eol=; &nbsp; &nbsp; 即每个以分号开头的行将被忽略skip=n - 指在文件开始时忽略的行数。delims=xxx - 指分隔符集。这个替换了空格和跳格键的默认分隔符集。tokens=x,y,m-n,k* - 指每行的哪一个符号被传递到每个迭代&nbsp; &nbsp; &nbsp;如for /f &quot;tokens=1,3 &#37;&#37;i …… &nbsp; &nbsp; 获取每行的第1、第3个&nbsp; &nbsp; &nbsp;如for /f &quot;tokens=2-4 &#37;&#37;i …… &nbsp; &nbsp; 获取每行的第2至第4个&nbsp; &nbsp; &nbsp;如for /f &quot;tokens=2* &#37;&#37;i …… &nbsp; &nbsp; 第二个赋值给&#37;&#37;i，剩下的都赋值给&#37;&#37;jusebackq - 未查&#37;&#37;i变量的加强拓展：&#37;cname:~0,1&#37; &nbsp; &nbsp; 获取cname中的第0字符，到第1个字符结束~I - 删除任何引号(&quot;)，扩充 &#37;I&#37;~fI - 将 &#37;I 扩充到一个完全合格的路径名&#37;~dI - 仅将 &#37;I 扩充到一个驱动器号&#37;~pI - 仅将 &#37;I 扩充到一个路径&#37;~nI - 仅将 &#37;I 扩充到一个文件名&#37;~xI - 仅将 &#37;I 扩充到一个文件扩展名&#37;~sI - 扩充的路径只含有短名&#37;~aI - 将 &#37;I 扩充到文件的文件属性&#37;~tI - 将 &#37;I 扩充到文件的最讨厌这话期/时间&#37;~zI - 将 &#37;I 扩充到文件的大小&#37;~$PATH:I - 查找列在路径环境变量的目录，并将 &#37;I 扩充到找到的第一个完全合格的名称。如果环境变量未被定义，或者没有找到文件，此组合键会扩充空字符串可以组合修饰符来得到多重结果:&#37;~dpI - 仅将 &#37;I 扩充到一个驱动器号和路径&#37;~nxI - 仅将 &#37;I 扩充到一个文件名和扩展名&#37;~fsI - 仅将 &#37;I 扩充到一个带有短名的完整路径名&#37;~dp$PATH:i - 查找列在路径环境变量的目录，并将 &#37;I 扩充到找到的第一个驱动器号和路径。&#37;~ftzaI - 将 &#37;I 扩充到类似输出线路的 DIR（例）文件夹遍历setlocal enabledelayedexpansionFOR /R d: &#37;&#37;i IN (.) DO (&nbsp; &nbsp; &nbsp;set dd=&#37;&#37;i&nbsp; &nbsp; &nbsp;set &quot;dd=!dd:~0,-1!&quot;&nbsp; &nbsp; &nbsp;echo !dd!)其中，感叹号其实就是变量百分号(&#37;)的强化版。之所以要用!而不用&#37;，是因为在for循环中，当一个变量被多次赋值时，&#37;dd&#37;所获取的仅仅是dd第一次被赋予的值；要想刷新dd的值，就必须首先通过命令&quot;setlocal enabledelayedexpansion&quot;来开启延迟变量开关，然后用!dd!来获取dd的值。&gt; &nbsp; &nbsp; IF 语句简便用的句式：if &#37;var == val cmd1 &amp;&amp; cmd2条件语句，true则执行cmd1，否则执行 cmd2。1.比较字符串set /p PW=Please input password:if &#37;PW&#37;==str&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp; echo YES!) ELSE (&nbsp;&nbsp;&nbsp;&nbsp; echo NO!)2.比较数字if not &#37;num1&#37; LSS &#37;num2&#37; (&nbsp; &nbsp; &nbsp;...) else if ...(&nbsp; &nbsp; &nbsp;...) else(&nbsp; &nbsp; &nbsp;...)比较运算符：EQU - 等于NEQ - 不等于LSS - 小于LEQ - 小于或等于GTR - 大于GEQ - 大于或等于3.检测变量是否被定义set var=xxxxxif defined var( ... )4.判断返回值（ERRORLEVEL）if errorlevel n&nbsp;( ... )多组if errorlevel语句，要根据返回码n从大到小排，其原因类似于try...catch语句中的catch规则，具体自行详查。批处理中的返回值一般表示了上个命令的执行结果(成功/失败/等)每个命令执行完毕后返回值，都会做相应的更改。一般返回值为0表示成功,1表示失败。一些第三方的返回值比较特殊，如Choice、Tmos.exe、Cmos.exe，自行详查。if errorlevel n &nbsp; &nbsp; 条件功能：是否为返回码n。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;多组if errorlevel语句，根据返回码n从大到小排。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;因为其执行类似于switch。if exist file_path &nbsp; &nbsp; 是否存在某文件&gt; &nbsp; &nbsp; SET 语句set &nbsp; &nbsp; 显示、设置、去掉windows的环境变量1.给变量赋值 &nbsp; &nbsp; set str=something2.等待用户输入数据 &nbsp; &nbsp; set /p name=请输入你的名字：3.计算 &nbsp; &nbsp; set /a num=(6*2)^2算式中的计算符：() &nbsp; &nbsp; 分组! ~ - &nbsp; &nbsp; &nbsp; &nbsp; 一元运算符* / &#37; &nbsp; &nbsp; &nbsp; 算数运算符+ - &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 算数运算符&lt;&lt; &gt;&gt; &nbsp; &nbsp; 逻辑移位&amp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 按位“与”^ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 按位“异”&#166; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;按位“或”= *= /= &#37;= += -= &nbsp; &nbsp; &nbsp; 赋值&amp;= ^= &#166;= &lt;&lt;= &gt;&gt;= &nbsp; &nbsp; 移位, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 表达式分隔符：&nbsp; &nbsp; &nbsp;set /a支持多行表达式并列，比如set /a num1=1+1,num2+1+2,num3=1+3&nbsp; &nbsp; &nbsp;并且set /a不需要扩展变量，比如set /a num=&#37;num2&#37;+&#37;num3&#37;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 与set /a num=num2+num3等价]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Batch 批处理中的特殊符号]]></title>
    <url>%2Fbatch%2FDOS%20%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%20Symbol%2F</url>
    <content type="text"><![CDATA[指令符号：&amp; &nbsp; &nbsp; 执行相邻的所有指令，无论是否有发生错误&amp;&amp; &nbsp; &nbsp; 前一个指令执行错误，不执行后一个指令|| &nbsp; &nbsp; 抢一个指令执行正确，不执行后一个指令| &nbsp; &nbsp; 管道指令，前一指令的执行结果，作为下一指令的输入&gt; &nbsp; &nbsp; 输出重定向到一个文件，文件清空，从头写&gt;&gt; &nbsp; &nbsp;&nbsp;输出重定向到一个文件，从文件最后开始写&lt; &nbsp; &nbsp; 从一个文件的内容作为某指令的输入&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中。&nbsp;&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中。^ &nbsp; &nbsp; 1.转义符，如果要输出^|&amp;@等的特殊字符，需要用^^、^|、^&amp;、^@等。&nbsp; &nbsp; &nbsp;2.分行符，如以下的多行指令，会输出一行字符：1234@echo 1^2^3^4最后一行不带^，说明指令到这结束。&nbsp; &nbsp; &nbsp;3.异或，用于set指令的计算功能&nbsp; &nbsp; &nbsp;4.其它，详于下文…----------------------------------------------------------------------~① 在for中表示使用增强的变量扩展。② 在%var:~n,m%中表示使用扩展环境变量指定位置的字符串。③ 在set/a中表示一元运算符，将操作数按位取反。!① 在set /a中一元运算符，表示逻辑非。比如set /a a=!0，这时a就表示逻辑1。$① 在findstr命令里面表示一行的结束。② 在prompt命令里面，表示将其后的字符转义（符号化或者效果化）。%① 在set /a中的二元运算符，表示算术取余。② 命令行环境下，在for命令in前，后面接一个字符（可以是字母、数字或者一些特定字符），表示指定一个循环或者遍历指标变量。③ 批处理中，后接一个数字表示引用本批处理当前执行时的指定的参数。④ 其它情况下，%将会被脱去（批处理）或保留（命令行）^① 取消特定字符的转义作用，比如&amp; | &gt; &lt; ! &quot;等，但不包括%。比如要在屏幕显示一些特殊的字符，比如&gt; &gt;&gt; | ^ &amp;等符号时，就可以在其前面加一个^符号来显示这个^后面的字符了，^^就是显示一个^，^|就是显示一个|字符了;② 在set/a中的二元运算符，表示按位异或。③ 在findstr/r的[]中表示不匹配指定的字符集。&amp;① 命令连接字符。比如我要在一行文本上同时执行两个命令，就可以用&amp;命令连接这两个命令。② 在set/a中是按位与。*① 代表任意个任意字符，就是我们通常所说的&quot;通配符&quot;;比如想在c盘的根目录查找c盘根目录里所有的文本文件(.txt)，那么就可以输入命令&quot;dir c:\*.txt&quot;。② 在set /a中的二元运算符，表示算术乘法。③ 在findstr/r中表示将前一个字符多次匹配。-① 范围表示符，比如日期的查找，for命令里的tokens操作中就可以用到这个字符。② 在findstr/r中连接两个字符表示匹配范围。③ -跟在某些命令的/后表示取反向的开关。④ 在set /a中：&nbsp;&nbsp; 1.表示一个负数。&nbsp;&nbsp; 2.表示算术减运算。+① 主要是在copy命令里面会用到它，表示将很多个文件合并为一个文件，就要用到这个+字符了。② 在set/a中的二元运算符,表示算术加法。:① 标签定位符，表示其后的字符串为以标签，可以作为goto命令的作用对象。比如在批处理文件里面定义了一个&quot;:begin&quot;标签，用&quot;goto begin&quot;命令就可以转到&quot;:begin&quot;标签后面来执行批处理命令了。② 在%var:string1=string2%中分隔变量名和被替换字串关系。|① 管道符，就是将上一个命令的输出，作为下一个命令的输入.&quot;dir /a/b |more&quot;就可以逐屏的显示dir命令所输出的信息。② 在set/a中的二元运算符，表示按位或。③ 在帮助文档中表示其前后两个开关、选项或参数是二选一的。/① 表示其后的字符（串）是命令的功能开关（选项）。比如&quot;dir /s/b/a-d&quot;表示&quot;dir&quot;命令指定的不同的参数。② 在set/a中表示除法。&gt;① 命令重定向符，将其前面的命令的输出结果重新定向到其后面的设备中去，后面的设备中的内容被覆盖。比如可以用&quot;dir &gt; lxmxn.txt&quot;将&quot;dir&quot;命令的结果输出到&quot;lxmxn.txt&quot;这个文本文件中去。② 在findstr/r中表示匹配单词的右边界，需要配合转义字符\使用。&lt;① 将其后面的文件的内容作为其前面命令的输入。② 在findstr/r中表示匹配单词的左边界，需要配合转义字符\使用。=① 赋值符号，用于变量的赋值。比如&quot;set a=windows&quot;的意思意思是将&quot;windows&quot;这个字符串赋给变量&quot;a&quot;。② 在set/a中表示算术运算，比如&quot;set /a x=5-6*5&quot;。\① 这个&quot;\&quot;符号在有的情况下，代表的是当前路径的根目录.比如当前目录在c:\windows\system32下，那么你&quot;dir \&quot;的话，就相当与&quot;dir c:\&quot;。② 在findstr/r中表示正则转义字符。,① 在set /a中表示连续表达式的分割符。② 在某些命令中分割元素。.① 在路径的\后紧跟或者单独出现时：&nbsp;&nbsp; 一个.表示当前目录。&nbsp;&nbsp; 两个.表示上一级目录。② 在路径中的文件名中出现时：&nbsp;&nbsp; 最后的一个.表示主文件名与扩展文件名的分隔。?① 在findstr/r中表示在此位置匹配一个任意字符。② 在路径中表示在此位置通配任意一个字符。③ 紧跟在/后表示获取命令的帮助文档。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 二、多符号(符号不能分隔)&amp;&amp;① 连接两个命令，当&amp;&amp;前的命令成功时，才执行&amp;&amp;后的命令。||① 连接两个命令，当||前的命令失败时，才执行||后的命令。&gt;&amp;① 将一个句柄的输出写入到另一个句柄的输入中。&lt;&amp;① 从一个句柄读取输入并将其写入到另一个句柄输出中。%%① 两个连续的%表示在预处理中脱为一个%。② 批处理中，在for语句的in子句之前，连续两个%紧跟一个字符（可以是字母、数字和一些特定字符），表示指定一个循环或者遍历指标变量。③ 批处理中，在for语句中，使用与in之前指定的指标变量相同的串，表示引用这个指标变量。&gt;&gt;① 命令重定向符，将其前面的命令的输出结果追加到其后面的设备中去。② 在set /a中的二元运算符，表示逻辑右移。==① 在if命令中判断==两边的元素是否相同。&lt;&lt;① 在set /a中的二元运算符，表示逻辑左移。+=① 在set /a中的二元运算符。例如set /a a+=b表示将a加上b的结果赋值给a。-=① 在set /a中的二元运算符。例如set /a a-=b表示将a减去b的结果赋值给a。*=① 在set /a中的二元运算符。例如set /a a*=b表示将a乘以b的结果赋值给a。/=① 在set /a中的二元运算符。例如set /a a/=b表示将a除以b的结果赋值给a。%=① 在set /a中的二元运算符。例如set /a a%=b表示将a除以b的余数赋值给a。【注：命令行可以直接用 set /a a%=b ，在批处理里面可以用 set /a a%%=b 。】^=① 在set /a中的二元运算符。例如set /a a&quot;^=&quot;b表示将a与b按位异的结果赋值给a。【注：这里 &quot;^=&quot; 加引号是为了防止^被转义，下同。】&amp;=① 在set /a中的二元运算符。例如set /a a&quot;&amp;=&quot;b表示将a与b按位与的结果赋值给a。|=① 在set /a中的二元运算符。例如set /a a&quot;|=&quot;b表示将a与b按位或的结果赋值给a。&lt;&lt;=① 在set /a中的二元运算符。例如set /a a&quot;&lt;&lt;=&quot;b表示将a按位左移b位的结果赋值给a。&gt;&gt;=① 在set /a中的二元运算符。例如set /a a&quot;&gt;&gt;=&quot;b表示将a按位右移b位的结果赋值给a。\&lt;① 在findstr的一般表达式中表示字的开始处。\&gt;① 在findstr的一般表达式中表示字的结束处。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 三、双符号对(两个符号之间须指定字符串)! !① 当启用变量延迟时，使用!!将变量名扩起来表示对变量值的引用。&apos; &apos;① 在for/f中表示将它们包含的内容当作命令行执行并分析其输出。② 在for/f &quot;usebackq&quot;中表示将它们包含的字符串当作字符串分析。( )① 命令包含或者是具有优先权的界定符，比如for命令要用到这个()，我们还可以在if，echo等命令中见到它的身影。② 在set /a中表示表达式分组。&quot; &quot;① 界定符，在表示带有空格的路径时常要用&quot;&quot;来将路径括起来，在一些命令里面也需要&quot; &quot;符号。② 在for/f中将表示它们包含的内容当作字符串分析。③ 在for/f &quot;usebackq&quot;表示它们包含的内容当作文件路径并分析其文件的内容。④ 在其它情况下表示其中的内容是一个完整的字符串，其中的&gt;、&gt;&gt;、&lt;、&amp;、|、空格等不再转义。` `① 在for/f中表示它们所包含的内容当作命令行执行并分析它的输出。% %① 使用两个单独的%包含一个字符串表示引用以此串为名的环境变量。比如一个%time%可以扩展到当前的系统时间。[ ]① 在帮助文档表示其中的开关、选项或参数是可选的。② 在findstr /r中表示按其中指定的字符集匹配。]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOS 常用指令]]></title>
    <url>%2Fbatch%2FDOS%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%20Command%2F</url>
    <content type="text"><![CDATA[其它资料：《DOS Command Index》from百度知道：dos命令大全help &nbsp; &nbsp; 显示有哪些指令cmd_name /? &nbsp; &nbsp; 查询指令用法dir &nbsp; &nbsp; 显示当前目录的文件及文件夹的列表cd &nbsp; &nbsp; . &nbsp; &nbsp; .. &nbsp; &nbsp; / &nbsp; &nbsp; 等md/rd &nbsp; &nbsp; mkdir / rmdirchdir &nbsp; &nbsp; 显示当前目录的名称或更改当前目录tree &nbsp; &nbsp; 显示目录树结构type &nbsp; &nbsp; 显示文本文件的内容attrib &nbsp; &nbsp; 显示或更改文件属性ren &nbsp; &nbsp; 重命名copy &nbsp; &nbsp; 复制xcopy &nbsp; &nbsp; 复制文件以及目录树move &nbsp; &nbsp; 移动replace &nbsp; &nbsp; 替换erase &nbsp; &nbsp; 删除一个或多个文件del &nbsp; &nbsp; 删除deltree &nbsp; &nbsp; 删除文件夹及其子文件夹与文件format &nbsp; &nbsp; 格式化chkdsk &nbsp; &nbsp; 检查磁盘并显示状态报告vol &nbsp; &nbsp; 显示硬盘卷标，以及serial号码compact &nbsp; &nbsp; 显示或修改NTFS分区上压缩文件fsutil &nbsp; &nbsp; 显示或设置文件系统的设置ipconfig &nbsp; &nbsp; 电脑的ip设置ping &nbsp; &nbsp; 测试是否联通net cmd_name &nbsp; &nbsp; 获取某指令的具体帮助netstat &nbsp; &nbsp; 查看tcp/ip连接状态，如端口nbtstat &nbsp; &nbsp;&nbsp;得到远程主机的NETBIOS信息，比如用户名、所属的工作组、网卡的MAC地址等&nbsp; &nbsp; &nbsp;tracert &nbsp; &nbsp; 查看你的主机到目标地址，经过的路径pathping &nbsp; &nbsp; 类同上，可得到一些上一指令不能显示的信息ftp &nbsp; &nbsp; ftp命令行模式arp &nbsp; &nbsp; 操作ARP缓存，-a显示，-d删除一条，-s添加一条nslookup &nbsp; &nbsp; 排除dns的工具，另查。WMIC &nbsp; &nbsp; WMIC扩展WMI（Windows Management Instrumentation，Windows管理规范） ，提供了从命令行接口和批命令脚本执行系统管理的支持。SC &nbsp; &nbsp;&nbsp;显示、设置服务。与“服务控制器”和已安装设备进行通讯。SC 是用于与服务控制管理器和服务进行通信的命令行程序。shutdown &nbsp; &nbsp; -s关机，-r重启，-a放弃关机，-t倒数秒数。其它自行详查。date &nbsp; &nbsp; /t &nbsp; &nbsp; 显示或修改当前时间time &nbsp; &nbsp; /t &nbsp; &nbsp; 显示或修改当前时间reg &nbsp; &nbsp; 修改注册列表at &nbsp; &nbsp; 计划任务。已不推荐使用！请使用过下一条！schtasks &nbsp; &nbsp; 计划任务。另查assoc &nbsp; &nbsp; 显示或修改文件拓展名的关联类型ftype &nbsp; &nbsp; 显示或修改用于文件拓展名关联的文件类型（例）ASSOC .pl=PerlScriptFTYPE PerlScript=perl.exe %1 %*cls &nbsp; &nbsp; 清空屏幕cmd &nbsp; &nbsp; 启动命令行新实例prompt &nbsp; &nbsp; 改变命令行的（交互）提示，如默认显示的 C:/Users/IceHe&gt;&nbsp;color &nbsp; &nbsp; 调整命令行的前景、背景颜色title &nbsp; &nbsp; 设置cmd窗口的标题ver &nbsp; &nbsp; 显示系统版本find &nbsp; &nbsp; /v &nbsp; &nbsp; 查找内容findstr &nbsp; &nbsp; 查找内容！更强大！sort &nbsp; &nbsp; /r /+n &nbsp; &nbsp; 排序comp &nbsp; &nbsp; 比较两个或两组文件的内容fc &nbsp; &nbsp; 比较两个或两组文件，并显示它们之间的差别]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOS 环境变量]]></title>
    <url>%2Fbatch%2FDOS%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%20Environment%20Variable%2F</url>
    <content type="text"><![CDATA[变量 类型 描述&nbsp;%ALLUSERSPROFILE%&nbsp;局部&nbsp;返回“所有用户配置文件”的位置。&nbsp;%APPDATA%&nbsp;局部&nbsp;返回默认情况下应用程序存储数据的位置。&nbsp;%CD%&nbsp;局部&nbsp;返回当前目录字符串。&nbsp;%CMDCMDLINE%&nbsp;局部&nbsp;返回用来启动当前的 Cmd.exe 的准确命令行。&nbsp;%CMDEXTVERSION%&nbsp;系统&nbsp;返回当前的“命令处理程序扩展”的版本号。&nbsp;%COMPUTERNAME%&nbsp;系统&nbsp;返回计算机的名称。&nbsp;%COMSPEC%&nbsp;系统&nbsp;返回命令行解释器可执行程序的准确路径。&nbsp;%DATE%&nbsp;系统&nbsp;返回当前日期。使用与date /t命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。&nbsp;%ERRORLEVEL%&nbsp;系统&nbsp;返回上一条命令的错误代码。通常用非零值表示错误。*.注意：有些指令不会改变%ERRORLEVEL%的值！&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如echo、setlocal、pause……&nbsp;%HOMEDRIVE%&nbsp;系统&nbsp;返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。&nbsp;%HOMEPATH%&nbsp;系统&nbsp;返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。&nbsp;%HOMESHARE%&nbsp;系统&nbsp;返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。&nbsp;%LOGONSERVER%&nbsp;局部&nbsp;返回验证当前登录会话的域控制器的名称。&nbsp;%NUMBER_OF_PROCESSORS%&nbsp;系统&nbsp;指定安装在计算机上的处理器的数目。&nbsp;%OS%&nbsp;系统&nbsp;返回操作系统名称。Windows 2000 会将该操作系统显示为 Windows NT。&nbsp;%PATH%&nbsp;系统&nbsp;指定可执行文件的搜索路径。&nbsp;%PATHEXT%&nbsp;系统&nbsp;返回操作系统认为可执行的文件扩展名的列表。&nbsp;%PROCESSOR_ARCHITECTURE%&nbsp;系统&nbsp;返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。&nbsp;%PROCESSOR_IDENTFIER%&nbsp;系统&nbsp;返回处理器说明。&nbsp;%PROCESSOR_LEVEL%&nbsp;系统&nbsp;返回计算机上安装的处理器的型号。&nbsp;%PROCESSOR_REVISION%&nbsp;系统&nbsp;返回处理器的版本号。&nbsp;%PROMPT%&nbsp;局部&nbsp;返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。&nbsp;%RANDOM%&nbsp;系统&nbsp;返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。&nbsp;%SYSTEMDRIVE%&nbsp;系统&nbsp;返回包含 Windows 服务器操作系统根目录（即系统根目录）的驱动器。&nbsp;%SYSTEMROOT%&nbsp;系统&nbsp;返回 Windows 服务器操作系统目录的位置。&nbsp;%TEMP% 和 %TMP%&nbsp;系统和用户&nbsp;返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。&nbsp;%TIME%&nbsp;系统&nbsp;返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。&nbsp;%USERDOMAIN%&nbsp;局部&nbsp;返回包含用户帐户的域的名称。&nbsp;%USERNAME%&nbsp;局部&nbsp;返回当前登录的用户的名称。&nbsp;%USERPROFILE%&nbsp;局部&nbsp;返回当前用户的配置文件的位置。&nbsp;%WINDIR%&nbsp;系统&nbsp;返回操作系统目录的位置。]]></content>
      <categories>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[某次 JavaScript 代码优化过程]]></title>
    <url>%2Fjavascript%2F%E6%9F%90%E6%AC%A1js%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目标功能：使id为blink的html标签闪烁。我得到的原始程序：12345678910111213function blinklink() &#123; if (!document.getElementById( 'blink').style.color) &#123; document.getElementById( 'blink').style.color = "red" ; &#125; if (document.getElementById( 'blink').style.color == "red" ) &#123; document.getElementById( 'blink').style.color = "yellow" ; &#125; else &#123; document.getElementById( 'blink').style.color = "red" ; &#125; timer = setTimeout( "blinklink()", 1000);&#125;blinklink();第一版修改：1234567891011// 精简代码：使用 jQuery 写法function blinklink() &#123; if ($('#blink').css('color') == 'red')&#123; $('#blink').css('color', 'white'); &#125; else &#123; $('#blink').css('color', 'red'); &#125; timer = setTimeout('blinklink()', 1000);&#125;blinklink();第二版：123456789101112// 改进定时执行的方法，是代码更容易理解function blinklink() &#123; if ($('#blink').css('color') == 'red')&#123; $('#blink').css('color', 'white'); &#125; else &#123; $('#blink').css('color', 'red'); &#125;&#125;setInterval("blinklink();", 500);// setInterval()：每个预设的毫秒数间隔后，执行指定函数。// 之前这里竟然犯傻使用setTimeout()（在预设的毫秒数后，执行指定的语句）。第三版：123456789101112// 优化性能：用全局变量记录颜色值，避免每次都使用 jQuery 选择器去检索标签的属性var color = 'red' ;function change_color() &#123; if (color == 'red')&#123; color = 'white'; &#125; else &#123; color = 'red'; &#125; return color;&#125;setInterval("$('#blink').css('color', change_color);", 500);第四版：12345678// 精简代码：使用布尔变量// 使用 “ ?: ” 表达式var isRed = true;function change_color()&#123; isRed = !isRed; $('#blink').css('color' , isRed ? 'red' : 'white' );&#125;setInterval('change_color();', 1000);最终（第五）版：123456// 精简代码：压缩语句var isRed = true;function change_color()&#123; $('#blink').css('color' , (isRed = !isRed) ? 'red' : 'white');&#125;setInterval('change_color();', 750);只剩下5行代码了！即使是如此简单的地方，细想一下，都可以有优化的空间，要勤于思考。宽松自由的工作环境、不过于急迫的工作安排，才能更好地避免“随意实现功能就算了”的想法，好好地去想清楚，即使是一小段代码也要写好。避免写出愚蠢的代码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 4]]></title>
    <url>%2Fc%2B%2B%2FEffective%20C%2B%2B%20-%20Reading%20Note%204%2F</url>
    <content type="text"><![CDATA[Created on 2014-05条款44：将参数无关的代码抽离templatesfactor parameter-independent code out of templates.1.Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。2.因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或class成员变量替换template参数。3.因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation type）共享实现码。template&lt;typename T, std::size_t n&gt; // n就是非类型参数class SquareMatrix{public:&nbsp; &nbsp; &nbsp;void invert();};条款45：运用成员函数模板接受所有兼容类型use member function templates to accept &quot;all compatible types&quot;.1.请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数。2.如果你声明member templates用于“泛化copy构造”或“泛化ssignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。template&lt;typename T&gt;class SmartPtr{public:&nbsp; &nbsp; &nbsp;template&lt;typename U&gt;&nbsp; &nbsp; &nbsp;SmartPtr(const SmartPtr&lt;U&gt;&amp; other)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : heldPtr(other.get()) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;T* heldPtr;};条款46：需要类型转换时请为模板定义非成员函数define non-member functions inside templates when type conversion are desired.此条目相当复杂，所以最好查看原书。当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数值之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。条款47：请使用traits class表现类型信息use traits classes for information about types.traits广泛应用于标准程序库。但是，平时使用很少，导致看得不深入，难懂。最好，看原书的条款。此处不详述太多。如何设计并实现一个traits class：（1）确认若干你希望将来可取得的类型相关信息。如迭代器的种类。（2）为该信息选择一个名称。如iterator_category。（3）提供一个template和一组特化版本（如iterator_traits），内含你希望支持的类型相关信息。// 对于5种迭代器种类，C++标准程序库分别提供专属的卷标结构（tag struct）struct input_iterator_tag {};struct output_iterator_tag {};struct forward_iterator_tag : public input_iterator_tag {};struct&nbsp;bidirectional_iterator_tag&nbsp;: public&nbsp;forward_iterator_tag&nbsp;{};struct&nbsp;random_access_iterator_tag&nbsp;: public&nbsp;bidirectional_iterator_tag&nbsp;{};template&lt;...&gt; // 略而未写的template参数class deque{public:&nbsp; &nbsp; &nbsp;class iterator{&nbsp; &nbsp; &nbsp;public:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typedef random_access_iterator_tag iterator_category;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp;};};template&lt;...&gt; // 略而未写的template参数class list{public:&nbsp; &nbsp; &nbsp;class iterator{&nbsp; &nbsp; &nbsp;public:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typedef bidirectional_iterator_tag iterator_category;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp;};};template&lt;typename IterT&gt;struct iterator_traits{&nbsp; &nbsp; &nbsp;typedef typename IterT::iterator_category iterator_category;&nbsp; &nbsp; &nbsp;...}; // 它对用户自定义类型行得通，但对指针（另一种迭代器）行不通。// 因为指针不可能嵌套typedef。template&lt;typename IterT&gt;struct iterator_traits&lt;IterT*&gt;{ // 利用偏特化解决，支持了指针迭代器&nbsp; &nbsp; &nbsp;typedef&nbsp;random_access_iterator_tag&nbsp;iterator_category;&nbsp; &nbsp; &nbsp;...}// advance函数用于移动迭代器// 以下代码是，利用重载技术，在编译期对类型执行取代if...else测试template&lt;typename IterT, typename DistT&gt;void doAdvance(IterT&amp; iter, DistT d, std::random_access_iterator_tag){&nbsp; &nbsp; &nbsp;iter += d;}template&lt;typename IterT, typename DistT&gt;void doAdvance(IterT&amp; iter, DistT d, std::bidirectional_iterator_tag){...}template&lt;typename IterT, typename DistT&gt;void doAdvance(IterT&amp; iter, DistT d, std::input_iterator_tag){...}template&lt;typename IterT, typename DistT&gt;void advance(IterT&amp; iter, DistT d){&nbsp; &nbsp; &nbsp;doAdvance(iter, d, typename std::iterator_traits&lt;IterT&gt;::iterator_category();&nbsp; &nbsp; &nbsp;// 这里就不用if...else去测试用那种方式去移动迭代器了！}1.Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现。2.整合重载技术（overloading）后，traits classes有可能在编译期对类型执行if...else测试条款48：认识template元编程be aware of template metaprograming.1.Template metaprograming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测，和更高的执行效率！2.TMP可被用来生成“基于政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不合适的代码。TMP已被证明是个“图灵完全”（turing-complete）机器，意思是它的威力大到足以计算任何事物。TMP没有循环构件，循环效果由递归完成recursion。但其递归非递归函数调用，而是“递归模板具现化”（recursive template instantiation）。如下的阶乘例子（factorial）：template&lt;unsigned n&gt;struct Factorial{&nbsp; &nbsp; &nbsp;enum { value = n * Factorial&lt;n - 1&gt;::value }; // enum hack};template&lt;&gt;struct Factorial&lt;0&gt;{ // 模板特化&nbsp; &nbsp; &nbsp;enum { value = 1 };};只要你指涉Factorial&lt;n&gt;::value就可以得到n阶乘值。为什么TMP值得学习？（1）确保度量单位正确。使用它，就可以确保（在编译期）程序中所有度量单位的组合都正确，不论计算多复杂。所以它能用于早期侦测。（2）优化矩阵运算。Matrix m1, m2, m3;Matrix res = m1 * m2 * m3;用高级与TMP相关的template技术，即expression templates，就可能消除那些计算中临时产生的对象，并合并循环。使其使用较少的内存，执行速度有大提升。（3）可以生成客户定制之设计模式（custom design pattern）实现品。设计模式如Strategy、Ovserver、Visitor等等都可以多种方式实现出来。运用policy-based design之TMP-based技术，可能产生一些templates用来表述的独立设计选项，可任意组合他们，导致模式实现品带着客户定制的行为。例如智能指针。条款49：了解new-handler的行为understand the behavior of the new-handler.STL容器所使用的heap内存是由容器所拥有的分配器对象（allocator objects）管理，不是被new和delete直接管理。当operator new抛出异常以反映一个未获满足的内存需求之前，它会先调用一个客户制定的错误处理函数，即new-handler。namespace std{&nbsp; &nbsp; &nbsp;typedef void (*new_handler)();&nbsp; &nbsp; &nbsp;new_handler set_new_handler(new_handler p) throw();} // 其返回值也是一个指针，指向set_new_handler被调用前正在执行// （但马上就要被替换）的那个new-handler函数。当operator new无法满足内存申请时，会不断调用new-handler函数函数，直到找到足够内存。设计良好的new-handler必须做以下事情：（1）让更多内存可被使用。（2）安装另一个new-handler。如果目前这个new-handler无法取得更多可用内存，或许它直到另外哪个new-handler有此能力。（3）卸载new-handler。也就是将null指针传给set_new_handler。一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。（4）抛出bad_alloc（或派生自bad_alloc）的异常。这样的异常不会被operator new捕捉，因此会被传播到内存索求处。（5）不返回，通常调用abort或exit。C++不支持class专属的new-handler，其实也不需要。可令每个class提供自己的operator new和new-handler即可。template&lt;typename T&gt;class NewHandlerSupport{public:&nbsp; &nbsp; &nbsp;static std::new_handler set_new_handler(std::new_handler p) throw();&nbsp; &nbsp; &nbsp;static void* operator new(std::size_t size) throw(std::bad_alloc);&nbsp; &nbsp; &nbsp;...private:&nbsp; &nbsp; &nbsp;static std::new_handler currentHandler;};template&lt;typename T&gt;std::new_handler NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw(){&nbsp; &nbsp; &nbsp;std::new_handler oldHandler = currentHandler;&nbsp; &nbsp; &nbsp;currentHandler = p;&nbsp; &nbsp; &nbsp;return oldHandler;}template&lt;typename T&gt;void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size) : throw(std::bad_alloc){&nbsp; &nbsp; &nbsp;NewHandlerHolder h(std::set_new_handler(currentHandler));&nbsp; &nbsp; &nbsp;return ::operator new(size);}// 1.调用set_new_handler，告知Widget的错误处理函数。// 2.调用global operator new，执行实际的内存分配。// 如果失败，operator new会调用Widget专属的new-handler。// 若最终还是无法分配足够内存，会抛出bad_alloc异常。// 然而之后，还要恢复原本的global new-handler，// 然后再传播该异常。为了将原来的handler安装回去，// 使用了资源管理对象，实例即是以下的NewHandlerHolder，防止资源泄漏。// 3.global operator new能够分配足够的内存，operator new会返回一个指针，指向分配所得。// Widget的析构函数会管理global new-handler，// 自动将Widget&apos;s operator new被调用之前的那个new-handler恢复回来~！template&lt;typename T&gt;std::new_handler NewHolderSupport&lt;T&gt;::currentHandler = 0;class NewHandlerHolder{public:&nbsp; &nbsp; &nbsp;explicit NewHandlerHolder(std::new_handler nh)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : handler(nh){}&nbsp; &nbsp; &nbsp;~newHandlerHolder(){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::set_new_handler(handler);&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;std::new_handler handler;&nbsp; &nbsp; &nbsp;NewHandlerHolder(const NewHandlerHolder&amp;);&nbsp; &nbsp; &nbsp;NewHandlerHolder&amp; operator=(const NewHandlerHolder&amp;);};1.set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。2.Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。条款50：了解new和delete的合理替换时机understand when it makes sense to replace new and delete.为什么要替换编译器提供的operator new&amp;delete呢？（1）用来检测运用上的错误。如，new的资源不小心delete掉时，导致内存泄露。如，多次delete，导致了不确定行为。这些都容易识别。但各式各样的编程错误导致overruns（写入点在分配区块之后）或underruns（写入点在分配区块起点之前）。自定义的operator new就可以分配额外空间防止特定byte pattern（即签名，signatures），检查分配区块在某生命时间点，是否发生了overruns或underruns。（2）为了强化效能。定制版性能可以优化超过缺省版本。（3）为了收集使用上的统计数据。（4）为了增加分配和归还的速度。（5）为了降低缺省内存管理器带来的空间额外开销。针对小型对象而开发的分配器（例如Boost的Pool程序库）本质上消除了这样的额外开销。（6）为了弥补却生分配其中的非最佳齐位（suboptimal alignment）。如doubles的访问在x86体系结构上的访问是最快速的。（7）为了将相关对象成簇集中。（8）为了获得非传统的行为。条款51：编写new和delete时需固守常规adhere to convention when writing new and delete.详情最好自己重看原书。以下仅给出最后书中的简单概括：1.operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用new-handler。它也应该有能力处理0 bytes申请。专属版本则还应该处理”比正确大小更大的（错误）申请“。2.operator delete应该在收到null指针时不做任何事。class专属版本则还应该处理”比正确大小更大的（错误）申请“条款52：写了placement new也要写placement deletewrite placement delete if you write placement new.详情最好自己重看原书。以下仅给出最后书中的简单概括：void* operator new(std::size_t) throw(std::bad_alloc); // normal newvoid* operator new(std::size_t, void*) throw(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// placement new&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 从void*指针制定的位置开始分配内存void* operator new(std::size_t, const std::nothrow_t&amp;) throw(); // nothrow newnew和delete如果接受了额外参数，便称为placement的。如果一个带额外参数的operator new没有”带相同额外参数“的对应版operator delete，那么当new的内存分配动作需要取消并恢复旧观时就没有人员和operator delete会被调用。1.当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能因为发生隐微而时断时续的内存泄露。2.当你声明placement new和placement delete，请确定不要无意识（非故意）地掩盖了它们的正常版本。条款53：不要轻忽编译器的警告pay attention to compilere warnings.1.严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取”无任何警告“的荣誉。2.不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一编译器上，你原本倚赖的警告信息有可能消失。条款54：让自己熟悉包括TR1在内的标准程序库&nbsp;familiarize yourself with the standard library， including TR1.STL：容器、迭代器、算法、函数对象、容器适配器、函数对象适配器。iostream:自定缓冲功能。国际化支持：wchar_t。数值处理：复数模板complex、纯数值数组valarray。异常阶层体系：exception、logic_error、runtime_error……C89标准程序库：。。。智能指针：。。。tr1::function、tr1::bindhash tables正则表达式Regular expresstionstuples变量组tr1::array、tr1::mem_fn、tr1::reference_wrapper随机数random number数学特殊函数c99兼容扩充Type traits：用以提供类型（types）的编译器信息。tr1::result_of：是个template，用来推导函数调用的返回类型。条款55：让自己熟悉BoostFamiliarize yourself with BoostBoost程序库对付的主题非常繁多，区分数十个类目，包括：1.字符串与文本处理2.容器3.函数对象和高级编程（例如lambda）4.泛型编程5.模板元编程6.数学和数值7. 正确性与测试8.数据结构9.语言间的支持10.内存11.杂项（1）Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。（2）Boost提供许多TR1组件实现品，以及其它许多程序库。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 3]]></title>
    <url>%2Fc%2B%2B%2FEffective%20C%2B%2B%20-%20Reading%20Note%203%2F</url>
    <content type="text"><![CDATA[Created on 2014-05条款31：将文件间的编译依存关系降至最低minimize complilation dependencies between files.该条款十分复杂，最好阅读原书。以下仅是部分摘录：前置声明 class Date；包含头文件 #include &quot;date.h&quot;handle class和implementation class分开，一个类只提供接口，另一个负责实现该借口（桥接模式）。把对象实现细目隐藏于一个指针背后。class Person{&nbsp; &nbsp; &nbsp;...private:&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;PersonImpl&gt; pImpl; // 借口与实现的分离};分离的关键在于以“声明的依存性”，替换“定义的依存性”，正是编译依存性最小化的本质——现实中让头文件尽可能自我满足：（1）如果使用object references或object ptr可以完成任务，就别使用objects。可以仅用类型的声明式，就可以定义该类型的renference或ptr；但是如果定义某个类型的objects，就需要用到该类型的定义式。（2）如果能够，尽量以class声明式替换class定义式。（3）为声明式和定义式提供不同的头文件。#include &quot;datefwd.h&quot; // 这个头文件内声明（但未定义）class Date#include &lt;iosfwd&gt; // 类同上。abstract base class抽象基类，称为interface class。但C++的抽象类比java、.net的interface灵活，可以有成员变量或成员函数。支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。此做法无论是否涉及templates都适用。条款32：确定你的public继承塑模出is-a关系make sure public inheritance model is &quot;is-a&quot;谨记，继承应该是一种is-a关系！条款33：避免遮掩继承而来的名称avoid hiding inherited names.derived classes内的名称base classes内的名称。在public继承下，从来没有人希望如此。为了让被遮掩的名称在见天日，可用using声明式或转交函数（forwarding functions）。using声明式：class Derived : public Base{public:&nbsp; &nbsp; &nbsp;using Base::mf1; // 让Base class内名为mf1和mf3的所有东西&nbsp; &nbsp; &nbsp;using Base::mf3; // 在Derived作用于内都可见（并且public）&nbsp; &nbsp; &nbsp;virtual void mf1();&nbsp; &nbsp; &nbsp;void mf3();&nbsp; &nbsp; &nbsp;void mf4();};转交函数：class Derived : public Base{public:&nbsp; &nbsp; &nbsp;virtual void mf1()｛&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Base::mf1();&nbsp; &nbsp; &nbsp;｝};条款34：区分接口继承和实现继承differenitiate between inheritance of interface and inheritance of implementation1.接口继承和实现继承不同。在public继承下，derived class总是继承base class的接口。2.pure virtual 函数，只是为了让derived class只继承函数接口。3.简朴的（非纯）impure virtual函数，继承函数接口，以及省缺实现继承。4.non-virtual函数，继承函数接口，以及强制性实现继承。更好的virtual做法：class Airplane{public:&nbsp; &nbsp; &nbsp;virtual void fly(const Airport&amp; destination) = 0;&nbsp; &nbsp; &nbsp;...protected:&nbsp; &nbsp; &nbsp;void defaultFly(const Airport&amp; destination);}void Airplane::defaultFly(const Airport&amp; destination){&nbsp; &nbsp; &nbsp;// 真正的省缺实现放这里}继承时：class ModelA : public Airplane{public:&nbsp; &nbsp; &nbsp;virtual void fly(const Airport&amp; destination){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultFly(destination); // 更加安全&nbsp; &nbsp; &nbsp;}&nbsp;} // 避免有些飞机有着迥然不同的飞行方式，// 而程序员偷懒或忘记，于是错误继承省缺实现，导致飞机失事！条款35：考虑virtual函数意外的其他选择consider alternatives to virtual functions.1.藉由non-virtual interface手法实现Template手法该流派的拥护者，主张virtual函数应该几乎总是private的。class GameCharacter{public:&nbsp; &nbsp; &nbsp;int healthValue() const{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...// 可以做一些事前工作（该手法的优点）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int retVal = doHealthValue();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...//&nbsp;可以做一些事后工作（该手法的优点）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return retVal;&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;virtual int doHealthValue() const {...}};令客户通过public non-virtual成员函数间接调用private virtual函数，称为“non-virtual interface(NVI)”手法，是Template Mothed设计模式的一个特殊表现形式。（设计模式的Template Method和C++ templates并无关联！）2.藉由function ptr 实现 Strategy模式class GameCharacter;int defaultHealthCalc(const GameCharater&amp; gc);class GameCharacter{public:&nbsp; &nbsp; &nbsp;typedef int (*HealthCalcFunc)(const GameCharater&amp;);&nbsp; &nbsp; &nbsp;explicit GameCharater(HealthCalcFunc hcf = defaultHealthCalc)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : healthFunc(hcf)&nbsp; &nbsp; &nbsp;{...}&nbsp; &nbsp; &nbsp;int healthValue() const{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return healthFunc(*this);&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;HealthCalcFunc&nbsp;healthFunc;};3.藉由tr1::function 实现 Strategy模式class GameCharacter;int defaultHealthCalc(const GameCharater&amp; gc);class GameCharacter{public:&nbsp; &nbsp; &nbsp;typedef std::tr1::fucntion&lt;int (const GameCharater&amp;)&gt; HealthCalcFunc;&nbsp; &nbsp; &nbsp;explicit GameCharater(HealthCalcFunc hcf = defaultHealthCalc)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : healthFunc(hcf)&nbsp; &nbsp; &nbsp;{...}&nbsp; &nbsp; &nbsp;int healthValue() const{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return healthFunc(*this);&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;HealthCalcFunc&nbsp;healthFunc;};还有衍生的酷用法（具体自查）short calcHealth(const GameCharacter&amp;);struct HealthCalculator{&nbsp; &nbsp; &nbsp;int operator() (const GameCharacter&amp;) const&nbsp; &nbsp; &nbsp;{...}};class GameLevel{public:&nbsp; &nbsp; &nbsp;float health(const GameCharacter&amp;) const;&nbsp; &nbsp; &nbsp;...};GameCharater(std::tr1::bind(&amp;GameLevel::health,&nbsp; &nbsp; &nbsp;currentLevel, _1));4.古典的Strategy模式class GameCharacter;class&nbsp;HealthCalcFunc{public:&nbsp; &nbsp; &nbsp; virtual int calc (const GameCharacter&amp; gc) const&nbsp; &nbsp; &nbsp;{...}&nbsp; &nbsp; &nbsp;...};HealthCalcFunc defaultHealthCalc;class GameCharacter{public:&nbsp; &nbsp; &nbsp;explicit GameCharater(HealthCalcFunc phcf = &amp;defaultHealthCalc)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : pHealthFunc(phcf)&nbsp; &nbsp; &nbsp;{...}&nbsp; &nbsp; &nbsp;int healthValue() const{&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return&nbsp;pHealthFunc-&gt;calc(*this);&nbsp; &nbsp; &nbsp;}private:&nbsp; &nbsp; &nbsp;HealthCalcFunc *pHealthFunc;};条款36：绝不重新定义继承而来的non-virtual函数never redefine an inherited non-virtual function.non-virtual 函数是静态绑定的（dynamically bound），virtual函数是动态绑定的（statically bound）。所以virtual根据该对象的实际类型调用相应的函数，而non-virtual则是根据指针类型去调用相应的函数的。一个在基类内，声明为non-virtual的函数，它提供的特性是为了该class建立起一个不变性（质），凌驾其（继承它的子类的）特异性。即是，适用于基类父类的该特性，同样适用于其所有子类对象。不变性（invariant）；特异性（specialization）。条款37：绝不重新定义继承而来的缺省参数值never redefine a function&apos;s inherited default parameter value.virtual函数是动态绑定（early binding前期绑定）的，而缺省参数值却是静态绑定（late binding后期绑定）的！子类virtual函数重新指定缺省值的话，是没有用的，使用的缺省值还是基类的缺省值。条款38：通过复合塑模出has-a或“根据某物实现出”model &quot;has-a&quot; or &quot;is-implemented-int-terms of&quot; through composition.composition复合，其同义词包括：layering分层、containment内含、aggregation聚合，embedding内嵌。条款39：明智而审慎低使用private继承use private inheritance judiciously.private继承意味着is-implemented-in-terms-of（根据某物实现出）。它通常比符合（composition）的级别低。但当derived class需要访问protected base class的成员或需要重新定义继承而来的virtual函数时，这么设计是合理的。和复合（composition）不同，private继承可以造成empty base最优化。这对致力于尺寸最小化的程序库开发者而言，可能很重要。条款40：明智而审慎低使用多重继承use multiple inheritance judiciouly.virtual继承，防止derived class有多个base classes对象。class File{...};class InputFile : virtual public File{...};class OutputFile : virtual public File{...};clsss IOFile : public InputFile, public OutputFile{...};但，virtual继承比non-virtual继承的兄弟们体积大，访问virtual base classes的成员变量时，速度也变慢了。1.多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。2.virtual极成灰增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带有任何数据，将是最具实用价值的情况。3.多重继承的确有正当用途。其中一个情节设计“public继承某个Interface class”和“private继承某个协助实现的class”的两两组合。条款41：了解隐式接口和编译期多态understand implicit interfaces and compile-time polymorphism.1.classes和interfaces都支持接口和多态。2.对classes而言接口是显式的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期。3.对templates参数而言，接口是隐式的（implicit），奠基于有效表达式。多态是通过template具现化和函数重载解析（function overloading resolution）发生于编译期。条款42：了解typename的双重意义understand the two meanings of typename.1.声明template参数时，前缀关键字class和typename可互换。2.请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。template&lt;typename T&gt;void func(){&nbsp; &nbsp; &nbsp;typename T::const_iterator&nbsp;iter(container.begin());&nbsp; &nbsp; &nbsp;... // 只是以防T类型中有一个static成员也叫const_iterator，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // typename关键字就说清楚了，这指的是类型，而非其它！}条款43：学习处理模板化基类内的名称know how to access names in templatized base classes.template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;{public:&nbsp; &nbsp; &nbsp;void sendClearMsg(const MsgInfo&amp; info){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendClear(info);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... // 虽然上一句是调用的是基类的函数，但是却无法通过编译！为什么呢？&nbsp; &nbsp; &nbsp;}};因为这是类模板的编程：首先不知道Company是什么类型。不到编译期，MsgSender&lt;Company&gt;就还不会生成具体的模板类，那么该子类就不知道它的父类具体是什么样子的！解决方法：1.最好this-&gt;sendClear(info);2.template&lt;typename Company&gt;class LoggingMsgSender : public MsgSender&lt;Company&gt;{public:&nbsp; &nbsp; &nbsp;using MsgSender&lt;Company&gt;::sendClear;&nbsp; &nbsp; &nbsp;void sendClearMsg(const MsgInfo&amp; info){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sendClear(info);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... // 虽然上一句是调用的是基类的函数，但是却无法通过编译！为什么呢？&nbsp; &nbsp; &nbsp;}};3.最差MsgSender&lt;Company&gt;::sendClear(info);因为如果该函数是virtual的，它会关闭virtual的绑定行为。可在derived class templates内通过“this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 2]]></title>
    <url>%2Fc%2B%2B%2FEffective%20C%2B%2B%20-%20Reading%20Note%202%2F</url>
    <content type="text"><![CDATA[Created on 2014-05条款19：设计class犹如设计typetreat class design as type design.注意：1.新type的对戏那个如何被创建和销毁：以及构造、析构函数，内存分配和释放函数。2.对象的初始化和对象的赋值有什么区别。3.新type对象如果被以值传递，意味着什么？4.什么是新type的合法值？5.你的新type需要配合某个继承图系吗？(inheritance graph)6.你的新type需要什么样的类型转换？7.什么样的操作符和函数对此新type是合理的？8.什么样的标准函数应该驳回？（注意必须声明为private者）9.谁该取用新type的成员？决定哪些是private/public/protected/friend 等。10.什么是新type的未声明接口（undeclared interface）？11.你的新type有多么一般化？考虑它成为一个类模版。class template条款20：宁以pass-by-reference-to-const替换pass-by-valueperfer pass-by-reference-to-const to pass-by-value.缺省情况下C++以by value方式传递对象至函数，函数参数就是实际实参的复本，由对象的copy构造函数提供。pass-by-reference-to-const效率更高，减少了复本对象及其成员对象的构造和析构。而且还可以避免slicing（对象切割）的问题。当一个derived class对象以by-value方式传递并被视为base class对象，base class的copy构造函数会被调用，导致derived class对象的那些特化兴致被切割掉了，只剩下一个base class对象。一般而言，可以合理假设：内置对象和STL的迭代器和函数对象，可以pass-by-value！条款21：必须返回对象时，别妄想返回其referencedon&apos;t try to return a reference when you must return an object.任何函数如果返回一个reference或pointer指向某个local对象，都会一败涂地！TestObj&amp; retLocalObj2(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestObj a(2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;}TestObj&amp; retLocalObj3(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestObj *a = new TestObj(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return *a;}TestObj* retLocalObj4(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TestObj *a = new TestObj(4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return a;}以上第一个例中，local object建立在栈上，返回时local object已会被释放。第二、三个例中，local object建立在堆上，返回的local object不会被释放，但是，之后谁能对这些临时的对象释放，delete？例如：w =&nbsp;retLocalObj2()&nbsp;*&nbsp;retLocalObj3()&nbsp;*&nbsp;retLocalObj4();&nbsp;明显没有机会释放中间变量，导致内存泄漏。正确做法：必须返回新对象，就让那个函数直接返回一个新对象inline const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs){&nbsp; &nbsp; &nbsp;return Rational(lhs.n * rhs.n, lhs.d * rhs.d);}必须承受由此带来的构造、析构成本。绝不要返回pointer和reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款22：将成员变量声明为privatedeclare data members private切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分放哪高温控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性和日后的修改空间。protected并不比public更具有封装性，private可以使其成员变量，对其derived class更有封装性。条款23：宁以non-member、non-friend替换member函数prefer non-member non-friend functions to member functionclass WebBrowser{public:&nbsp; &nbsp; &nbsp;void clearCache();&nbsp; &nbsp; &nbsp;void clearHistory();&nbsp; &nbsp; &nbsp;void removeCookie();&nbsp; &nbsp; &nbsp;// void clearEverything(); // 使用这个成员函数调用前三个函数不够好&nbsp; &nbsp; &nbsp;...}void clearBrowser(){&nbsp; &nbsp; &nbsp;wb.clearCache();&nbsp; &nbsp; &nbsp;wb...} // 这样更好，有更好的封装性、包裹弹性(packaging flexible)和机能扩充性。为什么呢？因为，在类内，越少的代码能够做同一件事，封装性越好clearEverything()也做到了clearCache()...等的函数的工作。在所有函数必须定义在类内的语言来说，可以另外定义一个WebBrowser的工具类utility class，在其中定义一个static member函数完成相关功能。条款24：若所有参数皆需要类型转换，请为此采用non-member函数declare non-member functions when type conversions should apply to all parameters.class Rational{public:&nbsp; &nbsp; &nbsp;...&nbsp; &nbsp; &nbsp;const Rational&nbsp;operator*(const Rational* rhs) const;}result = oneHalf * 2; // 正确result = 2 * oneHalf; // 错误！int 2 无法隐式转换为Rational类型将operator*在类外定义即可：const Rational operator*(const Rational* lhs, const Rational* rhs){...}之前出错的语句也可以正常运行了！其实可以将它定义为class Rational的friend函数，但是应该尽量避免，原因未详述。如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。条款25：考虑写出一个不抛出异常的swap函数consider support for a non-throwing swap.1.当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常；2.如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请特化std::swap。3.调用swap时应针对std::swap使用using声明式，然后调用swap，并且不带有任何“命名空间资格修饰”。4.为“用户定义类型”进行std templates全特化是最好的，但千万不要尝试在std内加入某些对std而言全新的东西。namespace std{&nbsp; &nbsp; &nbsp;template&lt;typename T&gt;&nbsp;// std::swap的典型实现；&nbsp; &nbsp; &nbsp;void swap(T&amp; a, T&amp; b){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; T temp(a); // 只要T类型支持copying构造函数和copy assignment操作符即可&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a = b;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b = temp;&nbsp; &nbsp; &nbsp;}}但是有些用户定义类型，复制的动作并非总有必要。因为，主要情况是，有些成员变量只是指针，指向一个对象，内含真正数据，（这种设计的常见表现形式是所谓的pimpl手法——pointer to implementation）两个对象只需要交换这个指针值即可。所以，可以针对这个用户定义类型，让std::swap进行特化：namespace std{&nbsp; &nbsp; &nbsp;template&lt;&gt; &nbsp; &nbsp; // 这是std::swap针对T是Widget的特化版本&nbsp; &nbsp; &nbsp;void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(a.pImpl, b.pImpl);&nbsp; &nbsp; &nbsp;}} // 但无法通过编译，因为pImpl是private成员。真正解决方法：class Widget{public:&nbsp; &nbsp; &nbsp;void swap(Widget&amp; other){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using std::swap; // 令std::swap在此函数内可用&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(pImpl, other.pImpl); // 编译器根据实际情况，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 调用T专属的版本，或者std中一般化（泛化）的版本&nbsp; &nbsp; &nbsp;}}namespace std{&nbsp; &nbsp; &nbsp;template&lt;&gt;&nbsp; &nbsp; &nbsp;void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b){&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a.swap(b);&nbsp; &nbsp; &nbsp;}}劝告：成员版swap绝不可抛出异常。条款26：尽可能延后变量定义式的出现时间postpone variable definitions as long as possible.1.当一个变量需要使用时，才去声明它。2.为了提高效率，构造时就初始化好它！例：std::string encryted; // 先使用default构造函数encrypted = password; // 再用赋值操作符……不如std::string encryted(password); // 使用copy构造函数初始化了循环时怎么办？Widget w;for(...){&nbsp; &nbsp; &nbsp;w = xxx;}还是for(...){&nbsp; &nbsp; &nbsp;Widget w = xxx;}前者效率高一点，但是w作用域扩大，可理解性和易维护性变差！只有两种情况才使用前者的做法：（1）知道赋值比“构造+析构”的成本低（2）你正在处理代码中效率高度敏感的部分（performance-sensitive）条款27：尽量少做转型操作minimize casting(T)expr; // 两种旧式转型T(expr);const_cast&lt;T&gt;(expr); // 将对象的常量性去除（cast away the constness）dynamic_cast&lt;T&gt;(expr); // 安全向下转型（safe downcasting）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 决定某对象是否归属继承体系中的某个类型（之后细谈）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 唯一无法由旧式语法执行的动作static_cast&lt;T&gt;(expr); // 强迫隐式转换（implicit conversions）&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将non-const转换为const，反向操作不能，只能用const_cast&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 或将int转成double，或相反&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将void*转成type*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将ptr-to-base转为ptr-to-derivedreinterpret_cast&lt;T&gt;(expr); // 企图进行低级转型，实际动作和结果取决于编译器&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 所以它不可移植。将一个long或int转成指针都可以。新式转型比旧式：（1）更加容易辨认，易读（2）转型动作的目标窄化，编译器容易判断出错误1.尽量避免转型，在注重效率的代码中，避免dynamic_cast，最好试着发展无须转型的替代设计。2.如转型是必要的，试着将它隐藏于某个函数背后。客户可以调用该函数，使其不用将转型过程置于其代码中。3.宁可使用新式转型语法，不要使用旧式转型。清晰。条款28：避免返回handles指向对象内部成分avoid returning &quot;handles&quot; to object internals.避免返回handles（包括references、ptr、iterator迭代器）指向对象内部，保证封装性，帮助const成员函数的行为像个const，并将“虚吊号码牌”（dangling handles）的可能性降至最低。（虚吊号码牌，即是野指针，对象已被销毁，但是指向这个地方的指针还在）条款29：为“异常安全”而努力是值得的strive for exception-safe code.exception-safe 异常安全 的两个条件：当异常抛出时，（1）不泄露任何资源。不会代码的出错中断，导致没有delete或者释放掉资源、互斥锁等。（2）不允许数据败坏。因为new失败，可能导致一个指针成为野指针。内部的变量、状态，非原子性，不一致。异常安全函数——提供以下三个保证之一：（1）基本承诺。若异常被抛出，程序内的任何事物仍然保持在有效状态下。（2）强烈保证。若一场抛出，程序状态不改变。（即是变化都是原子性的。）要不是成功执行的状态，要不处于函数调用前的状态。（3）不抛掷（throw）保证。绝不抛出异常。总是能够完成承诺的功能。条款29给了我很大震动，这个条款很长，还是从原书重读较好。因为没有想到，这个代码的严谨性超过了我以前的想象！以下给出最好的那个代码版本：struct PMImpl{&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;Image&gt; bgImage;&nbsp; &nbsp; &nbsp;int imageChanges;};&nbsp;// 为了swap-and-copy而设计的（之前的条款有说）class PrettyMenu{&nbsp; &nbsp; &nbsp;...private:&nbsp; &nbsp; &nbsp;Mutex mutex; // 互斥量&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;PMImpl&gt; pImpl;&nbsp;// 为了swap-and-copy而设计的};void PrettyMenu::changeBackground(std::istream&amp; imgSrc){&nbsp; &nbsp; &nbsp;using std::swap;&nbsp; &nbsp; &nbsp;Lock ml(&amp;mutex);&nbsp; &nbsp; &nbsp;std::tr1::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl));&nbsp; &nbsp; &nbsp;pNew-&gt;bgImge.reset(new Image(imgSrc));&nbsp; &nbsp; &nbsp;++pNew-&gt;imageChanges;&nbsp; &nbsp; &nbsp;swap(pImpl, pNew);}“强烈保证”往往能够以copy-and-swap实现出来，但强烈保证并非对所有函数都可实现或具有现实意义。条款30：透彻了解inlining的里里外外understand the ins and outs of inlining在class声明处，就定义函数过程的，都会隐喻为inline。virtual函数不能够被inline。千万别将构造和析构函数inline！调试器，无法对inline函数设置断点。将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binaryupgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序速度提升的机会最大化。不要只因为function template出现在头文件，就将它们声明为inline。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++ 1]]></title>
    <url>%2Fc%2B%2B%2FEffective%20C%2B%2B%20-%20Reading%20Note%201%2F</url>
    <content type="text"><![CDATA[Created on 2014-05STL&nbsp;&nbsp;&nbsp;&nbsp; Standard Template LibraryTR1&nbsp;&nbsp;&nbsp;&nbsp; 一份RFC的规范，描述加入C++标准程序库的诸多新机能。Boost&nbsp;&nbsp;&nbsp;&nbsp; 一个网站，一个开源的C++程序库。大多数TR1的机能以它的工作为基础条款2：尽量以const，enum，inline代替#defineperfer consts, enums, and inlines to #defines.宏语言定义的变量名，如#define ASPECT_RATIO 1.653中的ASPECT_RATIO，不会进入symbol table，对于编译器不可见。（Extension：符号表，一种用于语言翻译器（例如编译器和解释器）中的数据结构。在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。如常数表、变量名表、数组名表、过程名表、标号表等等，统称为符号表。）enum hack：在类内，声明 enum｛OneConstNum = 5｝；用以声明一个常数。而且取enum量的地址，但对const常量可取地址。条款3：尽量使用constuse const whenever possible基础：char str[] = &quot;test&quot;;char *p = str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // non-const ptr, non-const dataconst char *p = str;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // non-const ptr, const datachar * const p = str;&nbsp;&nbsp;&nbsp;&nbsp; // const ptr, non-const dataconst char * const p = str; // const ptr, const datachar const *p = str;&nbsp;&nbsp;&nbsp;&nbsp; // the same as &quot;const char *p = str;&quot;迭代器：（注意，与前面常识有悖）std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin();&nbsp;&nbsp;&nbsp;&nbsp; // iter的作用像个 T* const*iter = 10;&nbsp;&nbsp;&nbsp;&nbsp; // 没错，改变的只是它所指向的内容++iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 出错，iter本身是const...std::vector&lt;int&gt;::const_iterator cIter = vec.begin();&nbsp;&nbsp;&nbsp;&nbsp; // cIter的作用像个 const T**iter = 11;&nbsp;&nbsp;&nbsp;&nbsp; // 出错，*cIter是const++iter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 没错，改变cIter常函数const不能改变任何成员变量，static变量除外。当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。条款4：确定对象使用前已先被初始化make sure that objects are initialized before they&apos;re used.赋值和初始化不同：用初始化列表来初始化自定义类型，而且效率更高，如果初始化的是built-in类型，则效率与赋值一样;在构造函数内是赋值。OneClass::OneClass()&nbsp; &nbsp; &nbsp;:theName(),&nbsp; &nbsp; &nbsp; theAddress(),&nbsp; &nbsp; &nbsp; thePhones(),&nbsp; &nbsp; &nbsp; num(0){...}假如一个自定义类型的成员变量，还可以这样使用nothing&quot;()&quot;，去调用其default constructor。成员变量初始化顺序：其类内声明的顺序，不关于初始化列表的顺序。所以，初始化列表的顺序最好和其类内声明顺序一样。编译单元：产生单一目标文件（single object file）的那些源码——单一源码文件加上其所include的头文件。local static对象：函数内的static对象。不同的编译单元内的non-local static对象的初始化顺序无明确定义。解决方法：用local static 代替non-local static，即是使用Singleton单例模式。条款5：C++默默编写并调用哪些函数know what functions C++ silently writes and calls.默认构造函数复制构造函数析构函数赋值操作符编译器产生的析构函数是non-virtual的。编译器产生的copy构造函数和copy assignment操作符的版本，只是将non-static成员变量拷贝至目标对象而已。如果你有声明了一个构造函数（无论有无参数），编译器便不会给你创建default的的构造函数了。若base class的copy assignment操作符被声明为private，那么编译器会拒绝为其derived class生成一个copy assignment操作符。条款6：若不想使用编译器自动生成的函数，就该明确拒绝使用private声明它们，且不给出具体的定义。当客户企图拷贝时，编译器会阻止你；假如是友元或者成员函数试图拷贝的话，因为它们没有具体定义，linker链接器就会组织它们。可以定义这样一个基类：class Uncopyable{protected:&nbsp; &nbsp; &nbsp;Uncopyable(){}&nbsp; &nbsp; &nbsp;~Uncopyable(){}private:&nbsp; &nbsp; &nbsp;Uncopyable(const Uncopyable&amp;);&nbsp; &nbsp; &nbsp;Uncopyable&amp; operator=(const Uncopyable&amp;);}class DerivedClass: private Uncopyable{&nbsp; &nbsp; &nbsp;...};这样，帮助重用，而且其子类就都不能调用复制构造函数和复制赋值操作符了。条款7：为多态基类声明virtual析构函数declare destructors virtual in polymorphic base classes.一个基类指针指向子类对象，当这个对象析构的时候，如果基类destructor非virtual，那么只会调用基类的destructor，而子类的则没有被调用，导致部分销毁对象，内存泄漏。基类有virtual函数，其子类就必须有相关的函数实现，即使其不重写。如果一个class不打算成为基类，就不要声明virtual函数。要实现virtual函数，必须携带vptr（virtual table pointer）虚函数表指针vptr指向一个有函数指针组成的数组，成为vtbl（virtual table）虚函数表。每一个带虚函数的class都带有一个相应的virtual table。当调用虚函数，取决于该对象的vptr虚函数指针所指的virtual table虚函数表，编译器在其中寻找适当的函数指针。而且这个虚指针增加了对象的大小，32位系统增加一个4Bytes的vptr，64位则增加8Bytes。所以类内至少有一个virtual函数，才去声明虚的destructor。尽量不要集成STL中不含有virtual函数的容器。总结：带有polymorphic多态性质的base classes应该声明virtual destructor。或它带有任何virtual函数，它就该有虚析构函数。若一个class不作为base class使用，或不是为了多态，就别声明虚析构函数。条款8：别让异常逃离析构函数prevent exceptions from leaving destructors.析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。C++不欢迎在析构函数中抛出异常。条款9：绝不在构造和析构过程中调用virtual函数never call virtual function during construction or destruction在子类的构造函数运行时，子类自身类型被解析为基类，调用的virtual函数是基类的，而不是子类的；析构函数一样，子类自身类型被解析为基类……解决方法：最好将初始化代码，另外放在一个init初始化函数内。条款10：令 operator= 返回一个reference to *thishave assignment operators return a reference to *this.x = y = z;//连锁赋值为了实现连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。条款11：在operator=中处理“自我赋值”handle assignment to self in operator=.赋值操作一般会先释放掉左值，再给左值赋值，假如左值右值是同一个对象，会导致“在停止使用资源之前意外释放了它”！所以Widget&amp; Widget::operator=(const Widget &amp;rhs){&nbsp; &nbsp; &nbsp;if(this == &amp;rhs) return *this; // 证同测试 identity test&nbsp; &nbsp; &nbsp;...}还有其它方法的！确保对象自我赋值时operator=有良好的行为。有关技术包括：1.证同测试；2.copy-and-swap；3.精心周到的语句顺序。2.copy-and-swap；Widget tmp(rhs);swap(temp); // 交换*this和rhs的数据return *this;3.精心周到的语句顺序。Bitmap *pOrig = pb;this.pb = new Bitmap(*rhs.pd); // 先创建复本delete pOrig; // 再delete原本return *this;条款12：复制对象时勿忘其每一个成分copy all parts of an objectcopying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。PriorityCustomer::PriorityCustomer（const&nbsp;PriorityCustomer&amp; rhs)&nbsp; &nbsp; &nbsp;: Customer(rhs),&nbsp; &nbsp; &nbsp; priority(rhs.priority){&nbsp; &nbsp; &nbsp;...}PriorityCustomer&amp;&nbsp;PriorityCustomer::operator=(const&nbsp;PriorityCustomer&amp; rhs){&nbsp; &nbsp; &nbsp;Customer::operator=(rhs);&nbsp; &nbsp; &nbsp;priority = rhs.priority; // 其它成员变量的赋值&nbsp; &nbsp; &nbsp;return *this;}条款13：以对象管理资源use objects to manage resources.Investment *pInv = createInvestment();... // 中间的代码可能抛出异常，可能return，&nbsp; &nbsp; &nbsp;// 导致最后无法运行到delete那一行，内存泄漏delete pInv;可以把资源放到对象里面，利用析构函数自动调用的机制，确保资源释放的问题。例如智能指针shared_ptr、unique_ptr。std::auto_ptr&lt;Investment&gt; pInv(createInvestment());关键：1.获得资源后立即放进管理对象内。这个观念被称为“资源取得时机便是初始化时机”。（Resource Acquisition Is Initialization——RAII）2.管理对象运用析构函数确保资源被释放。若资源释放动作可能导致抛出异常，看条款8怎么处理。（另外使用一个普通函数进行该操作）auto_ptr和tr1::shared_ptr、unique_ptr等都在其析构函数内做delete而不是delete[]，意味着别将动态分配的array数组交给智能指针！会内存泄漏。C++并没有特别针对“动态分配数组”而设计类似的智能指针，vector、string可以取代动态分配而得的数组。boost::scored_array和boost::shared_array classes，就提供了以上你想要的内容，可是还没有采纳入C++标准库中。条款14：在资源管理类中小心copying行为think carefully about copying behaviour in resource-managing classes.RAII对象被复制，应该怎么处理，有两种方式：1.禁止复制。因为这样并不合理。2.使用类似于shared_ptr的引用计数（reference-count）。而且要注意：1.深拷贝底部资源2.或者转移底部资源的拥有权，如unique_ptr条款15：在资源管理类中提供对原始资源的访问provide access to raw resource in resource-managing classes.1.APIs往往要求访问原始资源raw resources，所以每个RAII class应该提供一个get()方法，2.对原始资源的访问可能经由显式转换或隐式转换。一般隐式转换较方便，显式转换较安全。class Font(){&nbsp; &nbsp; &nbsp;...&nbsp; &nbsp; &nbsp;FontHandle f; // 原始资源&nbsp; &nbsp; &nbsp;operator FontHandle() const // 隐式转换&nbsp; &nbsp; &nbsp;{ return f; }}条款16：成对使用new和delete时要采用相同形式use the same form in corresponding uses of new and delete.避免 typedef std::string AddressLines[4]; // 忘了typedef的用法自己查查！因为当你 std::string* pal = new AddressLines;别人不知道该用delete pal; 还是 delete[] pal;（这个才正确）。new时，使用了[]，必须在相应的delete表达式中也试用[]。条款17：以独立语句将newed对象置入智能指针store newed objects in smart pointers in standalone statments.以独立语句将new出的对象储存于（置入）智能指针内。如果不这样做，一旦有一场被抛出，有可能导致难以察觉的资源泄漏。processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority());不同编译器以何种顺序执行：A. &nbsp; &nbsp; new WidgetB. &nbsp; &nbsp; tr1::shared_ptr的构造函数C. &nbsp; &nbsp; 调用priority()假如以ACB顺序执行，“调用priority()”时可能抛出异常，导致new出的Widget没有及时放入智能指针，还是导致内存泄漏了……所以分开写成这样：std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget);processWidget(pw, priority());条款18：让借口容易被正确被使用，不易被误用make interface easy to use correctly and hard to use incorrectly.函数调用的时候，参数的顺序可能出错，所以可以通过导入相应的类型预防。如：Date(const Month&amp; m, const Day&amp; d);// 而非直接用int指代月份和日，还可以用enumInvestment* createInvestment(); // 这样要求用户记得delete，而且不超过1次不能将责任推给智能指针，因为用户还是可能忘记使用。所以std::tr1::shared_ptr&lt;Investment&gt; createInvestment();强行返回智能指针，先发制人，要求客户使用智能指针。智能指针可以指定删除器，而非总是使用delete。std::tr1::shared_ptr&lt;Investment&gt; pInv(0, getRidOfInvestment);getRidOfInvestment是作为删除器的函数名（函数指针）。上例并不够好，0只是个int，而非空指针，而智能指针坚持要一个指针，所以std::tr1::shared_ptr&lt;Investment&gt; pInv(static_cast&lt;Investment*&gt;(0), getRidOfInvestment);阻止误用的办法：建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。tr1：：shared_ptr支持定制删除器 (custom deleter)。可以防范DLL问题，可被用来自动解除互斥锁（见条款14，原书）。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ Primer 第五版]]></title>
    <url>%2Fc%2B%2B%2FC%2B%2B%20Primer%205th%2F</url>
    <content type="text"><![CDATA[Created on 2014-04Download - C++ Primer 5th.pdf]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 面试宝典]]></title>
    <url>%2Fc%2B%2B%2FC%2B%2B%20Interview%20Book%2F</url>
    <content type="text"><![CDATA[Created on 2014-03Download - C++ Interview 程序员面试笔试宝典.pdf]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 编程规范]]></title>
    <url>%2Fc%2B%2B%2FC%2B%2B%20Code%20Standards%20%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[Created on 2014-02Download - C++ Code Standards.pdf]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间管理日志]]></title>
    <url>%2Flifelogs%2F</url>
    <content type="text"><![CDATA[新的体悟记于 2017-01-01 更新于 2017-03-10停止更新我还在一直做个人时间使用情况的记录和统计，即时间日志，但是不会继续在本博客中的更新其具体内容了。停止更新时间日志的原因换了新的工具，没时间将它适配到原有的工具链上，于是没办法方便地使用工具链自动推送时间日志到博客。根本原因其实还是我觉得：公开自己的时间日志已经意义不大了。原有的工具链打造记录统计时间日志的工具链花了我不少的时间和精力 —— 查阅、学习、组装、调试……Evernote 记录：每天新建一篇时间日志，用来记录、统计时间的使用情况，精度是半小时。AppleScript + Python 脚本：根据模板自动生成新一天的空白时间日志，并添加到 Evernote。从 Evernote 读取前一天的时间日志，统计时间使用情况，然后将结果写回 Evernote 的时间日志里，同时也记录到数据库中。MySQL 数据库：存储每日、每周、每月、每年的时间使用情况的统计结果，包括各类事务的时长，以及占总时长的百分比等。本博客：每个月初将上一个月的所有时间日志推送到博客的 LifeLogs 目录下，然后生成索引，并将其添加到本文中。新工具原有的工具链我使用了两年多，期间持续进行了非常多的修复、优化和补充，已经足够自动化和好用了。可是它的使用、维护和升级依然越发显得麻烦，因为我现在的我更倾向于更「简单、专注」的生活。如果折腾这样一个工具链是为了证明自己有所谓的“极客范”，那么目的已经达到了，已经没有必要再继续折腾它了。iOS App「BlockyTime 时间块」它的时间记录和统计的方式契合我现有的习惯，简单的点、选的操作即可完成时间记录和统计，方便省心。既然已经有了一个足够好的现成解决方案，何苦继续自己折腾呢？人生很短，还有很多更重要更美好的事等着我去做呢。时间日志的目的其实在我知道《 奇特的一生 》这本书之前，早就开始做时间记录了。我为什么要做时间日志？现实生活中的各种活动，往往缺少足够有效的反馈，无论是正面的还是反面。我认为的「有效」的反馈，应该是「及时」，甚至是「即时」的。显然，半年一次的 KPI 考核就不够「有效」。正如《 游戏改变世界 》一书所说，我想把现实生活过得像是「游戏」，拥有及时的反馈。每努力半小时，我都会记录下来，仿佛我真的有一条「经验槽」，不知不觉它又涨了。好像是只要我不断「打怪升级」就能走上人生巅峰：「你看！今天除了睡觉 50% 的时间都有在学习呢！」每虚度半小时，我也会记录下来，我可能会懊恼，但是这样才能够促使自己及时反省、思考、调整，改进自己的行为和观念：内务花费的时间太多，怎么才能更快地做完？打游戏、看动漫太多，要节制。迷失我参照「一万小时理论」，循着以上思路来使用时间日志，直到最近我才发现自己早已到达瓶颈，而且卡在那了……瓶颈：经过长时间的实践努力，基本可以做到每天除去睡觉的时间，（一周平均）可以做到 45% 的时间用于学习和工作，很难再提高了。经过统计分析，这个结果至少对我来说，还是不容易达成的。怪圈：我确确实实投入了不少时间去努力，但是成果寥寥，碌碌无为。虽然我可能也注重效率，但却忽略了实效，重要的是成果，我可以正确地做事，但更需要做正确的事，做最重要的事。不然一切不过是盲目的自我感动，南辕北辙、劳而无功。我之前对日常工作不够关注（虽然工作也只是手段），我太贪心了，关注太多无谓的多余的东西。对「努力、学习、工作」的定义太宽泛，统计出来的时间虚高。例如，一般的阅读真的不能算是学习，因为读得太快太随意是不可能有效地吸收其中的知识的，至少对我来说是这样。基于原有的统计方式，我过分关注投入的「时长」而忽视了「实效」，对真正重要的事投入不够。实效虽然重要的事投入产出比高，但是它们往往做起来比较困难，更耗费心力，不容易长时间专注投入。我恐惧陌生的领域，枉论「恐慌区」，我连「学习区」都常常怯于面对。我倾向于做自己感兴趣的事，毕竟容易长时间坚持做下去。然而这些事往往是自己擅长的，投入产出比已经不够高了，重复做也提高有限。我陷入了「舒适区」。寻路经过了不少的实践和思考，我终于肯重视「刻意练习」了。近来我又产生了许多新的体悟，更加热爱「简单、专注」的生活了。我不需要那么多信息：不看报刊了，很少看知乎、公众号，不再盲目刷书，虽然朋友圈、微博还没戒掉。我真的「信息成瘾」了，但不想溺死在信息的海洋里。如果知晓某些信息的益处只有「徒增谈资」的话，我宁可「不知道」。我不需要那么多朋友：社交网络让我产生了太多的“幻觉”和无谓的情绪波动，不如认认真真对待眼前的每一个人，多和真正愿意把你当作朋友的好友通信。我决定花更多时间去思考：更快地做事，不如正确地做事；但是根本上，还是得做正确的事。战略上的懒惰，是战术上的勤奋是无法弥补的，选择比行动更重要，「磨刀不误砍柴工」，「三思而后行」。时间日志格式Explanations for Log Format - 日志记录格式的说明2017一月：加班重构主项目；沉迷 ACGMN。二月：春节，休憩。三月：思一年之计。四月：饮恨。五月：闭关。2016一月：月光，学习。 学 49 动 8 废 5Jan: use up, learn.二月：休息，懒。 学 37 动 4 废 4Feb: Relax, lazy.三月：迷乱，迁居。 学 50 动 9 废 4Mar: confused, move house.四月：加班，新项目。 学 47 动 7 废 5Apr: work overtime, new project.五月：微博头条，新朋友。 学 50 动 11 废 4May: TopWeibo, new friends.六月：疲累。 学 46 动 10 废 4Jun: tired.七月：迷乱，冲绳。 学 38 动 9 废 5Jul: dizzy, Okinawa.八月：晚睡，迁到新浪新总部。 学 50 动 10 废 5Aug: sleep late, move to the new Sina headquarter.九月：计划，反馈，月光，纠结，讲究方法。 学 51 动 11 废 6Sep: plan &amp; feedback, use up, hesitating, methodology十月：重构，痛苦，精简。 学 44 动 11 废 8Oct: refactor, pain, less.十一月：重构主项目，沉浸工作。十二月：重构主项目，赶进度；沉迷精品 iOS 游戏。2015一月：适应，北京。 学 40 动 4 废 3Jan: adapt, Beijing.二月：压力，新年。 学 34 动 2 废 2Feb: pressure, new year.三月：技术博客，工具控。 学 34 动 4 废 7Mar: tech blog, tool zealot.四月：毕业设计，悠闲。 学 26 动 8 废 10Apr: graduation design, leisure.五月：毕业设计，论文，混乱的生活。 学 30 动 8 废 6May: graduation design, paper, chaotic life.六月：毕业季，最后一月。 学 21 动 4 废 2Jun: graduation season, the last month七月：新浪，入职，新起点。 学 29 动 3 废 2Jul: Sina, entry, new begining.八月：公司公寓，适应。 学 34 动 5 废 2Aug: apartment, adapt.九月：单元测试，新人培训。 学 33 动 6 废 4Sep: unit test, orientation.十月：音乐节，运动。 学 40 动 9 废 4Oct: music festival, sports.十一月：运动，饮食，睡眠，好习惯。 学 49 动 8 废 3Nov: sports, eating, sleep, good habits.十二月：学习，运动。 学 50 动 9 废 4Dec: learn, sports.2014八至十二月 时间统计实习，校招。Aug ~ Dec Time Stat: intership, campus recruiting.十一月：挣扎，旅行，云南。Nov: struggle, travel, Yunnan, Lijiang.十二月：实习，旅行，北京。Dec: intership, travel, Beijing.皇皇三十载，书剑两无成。《自洛之越》孟浩然]]></content>
      <categories>
        <category>time mgt</category>
      </categories>
      <tags>
        <tag>time mgt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IceHe's CV]]></title>
    <url>%2Fabout_en%2F</url>
    <content type="text"><![CDATA[NOT COMPLETE : I will finish translation if necessary.MeI’m Ice He / Hzy A Cantonese in Beijing, dive into tech. Less. 宁静致远。 Animate , Badminton , 毽球 Weibo Mobile API PHP Server-side Developer x#icehe.me WeChat | Zhihu | WeiboTraits Tools - QuickSoftwares &amp; Hardwares Shortcuts - EfficientDefault &amp; Custom Logs - Time Mgt.Time Usage Rec. &amp; StatisticsLife FavoritesBooks , Music , Movies , Games … Reading BookmarksQ&amp;A , Notes , Articles … Technology BookmarksDocs , Courses , Blogs , ArticlesPast My MomentsGood old days Old ArticlesWhen I was teenFriends Jan Fan | Shiwey Yan | SF ZhouPython,ML&amp;NLP | Game Developer | ACMerTechnology Blog : icehe.meWeb , Thoughts , C++ … GitHub : IceHeTools’ confs , Blog src , Auto scriptsSkill Levels Proficient Familiar Competent KnowPrograming Langs PHP C++ JavaScript Java Python C ASMOS macOS Windows 8.1 CentOS 7 UbuntuDB SQL MySQL MS SQL Server 2008 Oracle DBWeb HTML CSS jQuery Docker Nginx RedisScripts AppleScript Bash Batch fileTools Git Vim Zsh Qt 4 / 5IDE PhpStorm PyCharm Visual Studio EclipseLangs Mandarin Cantonese EnglishTalk &amp; Write about TechnologyExperience微博移动 - 服务端开发 微梦创科网络技术（中国）有限公司 - 微博移动 - 服务端研发&emsp;2015.07 ~ TodayMAPI（移动应用服务）部门 - 职责：「微博移动端」（手机、平板）的服务端 API 的开发与维护，包括 开放平台 API 、各业务方 与 微博移动端（H5、客户端）之间信息的聚合与适配对接重构 微博移动 API v7 项目 Sora 的登录模块，以及相关接口开发维护 手机微博管理后台 v5（B/S）频道打点管理模块2016.04 ~ 2016.08 参与「微博头条」的服务端 API 及其 CMS 后台的开发与维护：完全重构 频道订阅模块，开发维护 供产品运营人员使用的 CMS 频道列表管理后台部分重构 微博头条客户端行为日志记录模块，兼容微博客户端的行为日志格式开发维护 微博头条频道 Feed、微博广场头条流、热门微博头条流、文章与标签分享等 APIPHP 7 , Docker , Yaf , Lumen , Nginx , Redis , MySQL , CentOS 6.5 , GitLab毕业设计 - 进程安全测量毕业设计 - 基于进程安全测量的安全管理&emsp;2015.03 ~ 2015.05包括：安全测量模块（Linux Loadable Kernel Module）、安全管理器（Qt GUI）原理：用 SHA-1 分别计算进程在内存中的代码段与参数段，得出定长的信息摘要作为特征值（方便比对），去比对标准特征值，便可判断进程是否被篡改，或程序是否被替换C/C++ , Loadable Kernel Module , CentOS 7 , Qt Framework微博移动 - 服务端 实习&nbsp;微梦创科网络技术（中国）有限公司 - 手机微博 - 服务端研发 实习生&emsp;2014.12 ~ 2015.02「手机微博管理后台」v5（B/S）- 开发「活动管理，常量管理，日程管理」等模块PHP 5.6 , Yaf , HTML , CSS , JavaScript , jQuery , MySQL华为软件 - Web 研发 实习华为软件技术（深圳）有限公司 - 软件研发 实习&emsp;2014.07 ~ 2014.10「广东移动电子渠道项目」即 官网 建设 - 开发「移动商城」、「我的移动」模块的部分需求JavaEE , Spring , Struct2 , MyBatis , OracleDB , JSP , JavaScript , jQuery华工实验室 - PC C/S华南理工 IBM 实验室 - 成员&emsp;2013.03 ~ 2014.05「华工教学云平台」Windows 客户端（C++ Qt GUI），及 Linux 服务端的部分功能C , C++ , Qt Framework , CentOS 6.5Education华南理工 - 软件工程华南理工大学 - 软件学院 - 软件工程&emsp;2011.09 ~ 2015.07微电子工艺实习（88 , 1/82）电路与电子技术（94 , 2/82）电路与电子技术实验（82 , 2/82）C++程序设计（90 , 7/82）数字逻辑（90, 9/82）2013~2014学年度「校级三等奖学金」执信中学广州市执信中学&emsp;2008.09 ~ 2011.072008、2009、2010 年「三好学生」（前 20%）2011 届「优秀毕业生」（前 20%）Others华工毽球社 - 社长华南理工毽球社 - 社长&emsp;2012.09 ~ 2014.062016.05.15 「京津冀天津毽球邀请赛」混合团体冠军（1/16）2016.03.13 「天津星五洲杯毽球邀请赛」混合团体亚军（2/16）广东省第十五届「高校杯毽球邀请赛」男子团体第七名（7/32）广东省第六届「大学生毽球精英挑战赛」男子团体 16 强（16/32)广东省第十六届「高校杯毽球邀请赛」男子团体 16 强（16/32）2011 至 2014 「大学城毽球联赛」分获亚军、季军、亚军、季军（前7）2013 至 2015 「华工双人毽球争霸赛」分获冠军、亚军、冠军（前16）2011「华工院际毽球赛」冠军华工职业体验协会 - 会长华南理工职业体验协会 - 会长&emsp;2013.03 ~ 2014.06任期内，协会在社团联合会的年度综合测评中积 96.7 分，排名从第 36 跃升至第 5（5/59）承办「2013 全球创业周中国站《创业课堂》高校巡讲-华工站」活动（广州）邀请到零点研究咨询集团董事长兼 CEO 袁岳 先生作主讲嘉宾出席 2013 年 第三届「全球创业周中国站校园伙伴高峰论坛」（上海）参加 2013 年 第三届「梦想 Safari 素质教育论坛」（珠海）承办「过来人托业杯职场精英挑战赛」大学城分赛区初赛举办「一站到底」华工版举办「生存挑战营」（在陌生城市挣返校费用）2 届承办「黑苹果职业访问大赛」华工场承办「职场好声音」讲座 2 场主讲「策划撰写、商务礼仪」2 场培训举办 会员服务活动 6 场举办 素质拓展 2 场华工职业发展协会 - 干事华工学生职业发展协会 - 综合事务部 - 干事&emsp;2011.09 ~ 2012.06说服广州信诚人寿 HR 负责人为「超完美计划培训营」优胜者提供岗位：经理人 2 个、实习生 10 个说服南方报业集团传媒研究院为「职协企观月」活动提供 40 个免费参观南方报业集团的名额举办 「就业服务月之公关危机」 比赛（纪念第一次办比赛，虽小）优职英才 - 市场部实习优职英才（北京）教育科技公司 - 市场部 - 实习生&emsp;2011.07 ~ 2012.12筹划执行校园推广活动，运营微博营销号，参与文案内容制作于广州各高校执行 15+ 场推广公司品牌的讲座、交流会、公开课:P.post-body .fancybox img.pic_styl{display:inline!important;height:140px;width:auto}]]></content>
      <categories>
        <category>whoami</category>
      </categories>
      <tags>
        <tag>whoami</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CV 简历]]></title>
    <url>%2Fabout%2F</url>
    <content type="text"><![CDATA[介绍我是 Ice He / Hzy 广州人在北京，潜心技术 微博移动应用服务 PHP 服务端开发 - Mobile API x#icehe.me # → @ 微信 , 微博 , 博客 , GitHub , 知乎 , 豆瓣 Less. 宁静致远。 tech. , ACGMN , 羽毛球 , 毽球特点 工具控 - 我的利器Apps &amp; 硬件 效率厨 - 我的快捷键默认 &amp; 自定义 省察 - 时间管理日志时间使用情况记录 &amp; 统计生活 最喜爱的书、文章、音乐、电影、游戏… 文字阅读收藏问答、笔记、文章… 技术阅读收藏文档、教程、博客、文章…: P 回忆Good old days 旧文为赋新词强说愁技术 博客 : icehe.me笔记、总结、思考、Mac、Git、C++、ASM… GitHub : IceHe工具配置、博客托管、自动化脚本、作品…技能级别 Proficient 精通 Familiar 熟悉 Competent 胜任 Know 理解编程语言 PHP C++ Python Java JavaScript C ASMOS macOS Windows 8.1 CentOS 7 UbuntuDB MySQL MS SQL Server 2008 Oracle DBWeb HTML CSS jQuery Docker Nginx脚本 AppleScript Bash Batch fileTools Git Vim Zsh Qt 4 / 5IDE PhpStorm PyCharm Visual Studio Eclipse语言 普通话 粤语 英语 技术相关内容的基本阅读写作，以及简单的听力对话经验微博移动 - 服务端开发 微梦创科网络技术（中国）有限公司 - 微博移动 - 服务端研发&emsp;2015.07 ~ 现在MAPI（移动应用服务）部门 - 职责：「微博移动端」（手机、平板）的服务端 API 的开发与维护，包括 开放平台 API 、各业务方 与 微博移动端（H5、客户端）之间信息的聚合与适配对接重构 微博移动 API v7 项目 Sora 的登录模块，以及相关接口开发维护 手机微博管理后台 v5（B/S）频道打点管理模块2016.04 ~ 2016.08 参与「微博头条」的服务端 API 及其 CMS 后台的开发与维护：完全重构 频道订阅模块，开发维护 供产品运营人员使用的 CMS 频道列表管理后台部分重构 微博头条客户端行为日志记录模块，兼容微博客户端的行为日志格式开发维护 微博头条频道 Feed、微博广场头条流、热门微博头条流、文章与标签分享等 APIPHP 7 , Docker , Yaf , Lumen , Nginx , Redis , MySQL , CentOS 6.5 , GitLab毕业设计 - 进程安全测量毕业设计 - 基于进程安全测量的安全管理&emsp;2015.03 ~ 2015.05包括：安全测量模块（Linux Loadable Kernel Module）、安全管理器（Qt GUI）原理：用 SHA-1 分别计算进程在内存中的代码段与参数段，得出定长的信息摘要作为特征值（方便比对），去比对标准特征值，便可判断进程是否被篡改，或程序是否被替换C/C++ , Loadable Kernel Module , CentOS 7 , Qt Framework微博移动 - 服务端 实习&nbsp;微梦创科网络技术（中国）有限公司 - 手机微博 - 服务端研发 实习生&emsp;2014.12 ~ 2015.02「手机微博管理后台」v5（B/S）- 开发「活动管理，常量管理，日程管理」等模块PHP 5.6 , Yaf , HTML , CSS , JavaScript , jQuery , MySQL华为软件 - Web 研发 实习华为软件技术（深圳）有限公司 - 软件研发 实习&emsp;2014.07 ~ 2014.10「广东移动电子渠道项目」即 官网 建设 - 开发「移动商城」、「我的移动」模块的部分需求JavaEE , Spring , Struct2 , MyBatis , OracleDB , JSP , JavaScript , jQuery华工实验室 - PC C/S华南理工 IBM 实验室 - 成员&emsp;2013.03 ~ 2014.05「华工教学云平台」Windows 客户端（C++ Qt GUI），及 Linux 服务端的部分功能C , C++ , Qt Framework , CentOS 6.5教育华南理工 - 软件工程华南理工大学 - 软件学院 - 软件工程&emsp;2011.09 ~ 2015.07微电子工艺实习（88 , 1/82）电路与电子技术（94 , 2/82）电路与电子技术实验（82 , 2/82）C++程序设计（90 , 7/82）数字逻辑（90, 9/82）2013~2014学年度「校级三等奖学金」执信中学广州市执信中学&emsp;2008.09 ~ 2011.072008、2009、2010 年「三好学生」（前 20%）2011 届「优秀毕业生」（前 20%）其它大学实践。华工毽球社 - 社长华南理工毽球社 - 社长&emsp;2012.09 ~ 2014.062016.05.15 「京津冀天津毽球邀请赛」混合团体冠军（1/16）2016.03.13 「天津星五洲杯毽球邀请赛」混合团体亚军（2/16）广东省第十五届「高校杯毽球邀请赛」男子团体第七名（7/32）广东省第六届「大学生毽球精英挑战赛」男子团体 16 强（16/32)广东省第十六届「高校杯毽球邀请赛」男子团体 16 强（16/32）2011 至 2014 「大学城毽球联赛」分获亚军、季军、亚军、季军（前7）2013 至 2015 「华工双人毽球争霸赛」分获冠军、亚军、冠军（前16）2011「华工院际毽球赛」冠军华工职业体验协会 - 会长华南理工职业体验协会 - 会长&emsp;2013.03 ~ 2014.06任期内，协会在社团联合会的年度综合测评中积 96.7 分，排名从第 36 跃升至第 5（5/59）承办「2013 全球创业周中国站《创业课堂》高校巡讲-华工站」活动（广州）邀请到零点研究咨询集团董事长兼 CEO 袁岳 先生作主讲嘉宾出席 2013 年 第三届「全球创业周中国站校园伙伴高峰论坛」（上海）参加 2013 年 第三届「梦想 Safari 素质教育论坛」（珠海）承办「过来人托业杯职场精英挑战赛」大学城分赛区初赛举办「一站到底」华工版举办「生存挑战营」（在陌生城市挣返校费用）2 届承办「黑苹果职业访问大赛」华工场承办「职场好声音」讲座 2 场主讲「策划撰写、商务礼仪」2 场培训举办 会员服务活动 6 场举办 素质拓展 2 场华工职业发展协会 - 干事华工学生职业发展协会 - 综合事务部 - 干事&emsp;2011.09 ~ 2012.06说服广州信诚人寿 HR 负责人为「超完美计划培训营」优胜者提供岗位：经理人 2 个、实习生 10 个说服南方报业集团传媒研究院为「职协企观月」活动提供 40 个免费参观南方报业集团的名额举办 「就业服务月之公关危机」 比赛（纪念第一次办比赛，虽小）优职英才 - 市场部实习优职英才（北京）教育科技公司 - 市场部 - 实习生&emsp;2011.07 ~ 2012.12筹划执行校园推广活动，运营微博营销号，参与文案内容制作于广州各高校执行 15+ 场推广公司品牌的讲座、交流会、公开课TODO : CV English Ver.:P写一部小说就像在黑夜里开车。你只能看到车灯照亮的部分，但是你却可以走完整个旅程。E.L. Doctorow.post-body .fancybox img.pic_styl{display:inline!important;height:140px;width:auto}]]></content>
      <categories>
        <category>whoami</category>
      </categories>
      <tags>
        <tag>whoami</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旧博索引]]></title>
    <url>%2Fthink%2Fold_blog%2F</url>
    <content type="text"><![CDATA[过去回头看过去的自己，免不了觉得幼稚、可笑、矫情、讨人厌……犯过的傻，虽然时隔已久，现在回想起来，依然能让我面红耳赤；犯过的错，依然历历在目、铭记在心，但是现在再怎么后悔，也弥补不了了。都是些「黑历史」啊，可是它们都过去了。即使是现在，我依然难免经常犯傻犯错。不过不要紧，只要我还能不断地「尝试」，努力工作学习，经历更多的人和事，总会慢慢成熟起来。而且急不来。旧博客QQ Zone &nbsp; 飘。Gone with the wind.置顶文章146. &nbsp; 2012-06-09 &nbsp; 停更，后会无期56. &nbsp; 2009-05-30 &nbsp; 成长的足迹.（不再续篇）二〇一六五月166. &nbsp; 2016-05-21 &nbsp; 无题二〇一五六月165. &nbsp; 2015-06-13 &nbsp; 2015年夏，毕业。- 我的大学 &lt;35&gt; 终164. &nbsp; 2015-06-11 &nbsp; 2014年冬 - 北京，续 &lt;34&gt;二〇一四十二月163. &nbsp; 2014-l2-31 &nbsp; 2014年冬 - 游丽江，北京实习 &lt;33&gt;九月162. &nbsp; 2014-09-27 &nbsp; 2014年秋9月 &lt;32&gt; &nbsp; ( 已删除 )- ???. &nbsp; 2014-09-27 &nbsp; 2014年秋9月 &lt;32&gt;八月161. &nbsp; 2014-08-10 &nbsp; 2014年夏8月 - 实习&lt;31&gt;七月160. &nbsp; 2014-07-06 &nbsp; 2014年夏 - 日常 &lt;30&gt;五月159. &nbsp; 2014-05-19 &nbsp; 2014年春末 - 毽球 &lt;29&gt;158. &nbsp; 2014-05-11 &nbsp; [转] 云珠沙龙三月157. &nbsp; 2014-03-16 &nbsp; 每天努力填满欲望 - 感慨 &lt;28&gt;一月156. &nbsp; 2014-01-12 &nbsp; 四川之旅 - 四川 &lt;27&gt;二〇一三十二月155. &nbsp; 2013-12-08 &nbsp; 你想要的，用什么来交换？ - 感慨 &lt;26&gt;十一月154. &nbsp; 2013-11-10 &nbsp; 纠结。- 实验室生活 &lt;25&gt;十月153. &nbsp; 2013-10-23 &nbsp; 随笔 - 随想 &lt;24&gt;九月152. &nbsp; 2013-09-14 &nbsp; 2013年秋 - 回想 &lt;23&gt;八月151. &nbsp; 2013-08-31 &nbsp; 2013年夏 - 上海 &lt;22&gt;六月150. &nbsp; 2013-06-01 &nbsp; 呓语。6.1 &lt;21&gt;五月149. &nbsp; 2013-05-23 &nbsp; 卮言。5.23 &lt;20&gt;三月148. &nbsp; 2013-03-17 &nbsp; 岁月静好。 &lt;19&gt;二〇一二十一月147. &nbsp; 2012-11-10 &nbsp; 偶然更新。六月146. &nbsp; 2012-06-09 &nbsp; 停更，后会无期五月145. &nbsp; 2012-05-13 &nbsp; 思念是一种病。&lt;18&gt;四月144. &nbsp; 2012-04-20 &nbsp; ゆめ。梦想。&lt;17&gt;143. &nbsp; 2012-04-02 &nbsp; 一如蓝蔷薇之于夏日。&lt;16&gt;三月142. &nbsp; 2012-03-18 &nbsp; Magic and Ecstasy. &lt;15&gt;二月141. &nbsp; 2012-02-17 &nbsp; 最后的浪花。&lt;12&gt;140. &nbsp; 2012-02-14 &nbsp; 破。&lt;11&gt;一月139. &nbsp; 2012-01-06 &nbsp; 自曝。&lt;10&gt;138. &nbsp; 2012-01-25 &nbsp; 新愿。&lt;09&gt;137. &nbsp; 2012-01-18 &nbsp; 冬。&lt;08&gt;二〇一一十二月136. &nbsp; 2011-12-03 &nbsp; 流年。&lt;07&gt;十一月135. &nbsp; 2011-11-13 &nbsp; 逝。&lt;06&gt;十月134. &nbsp; 2011-10-30 &nbsp; 梦想。&lt;05&gt;133. &nbsp; 2011-10-23 &nbsp; 间秋。&lt;04&gt;132. &nbsp; 2011-10-02 &nbsp; 新秋。我的大学 &lt;03&gt;九月131. &nbsp; 2011-09-25 &nbsp; 2011秋。大学生活 &lt;02&gt;130. &nbsp; 2011-09-19 &nbsp; NewPage. 我的大学 &lt;01&gt;129. &nbsp; 2011-09-16 &nbsp; 尽。 高中生活 &lt;玖七&gt; 终八月128. &nbsp; 2011-08-11 &nbsp; 雨夏事纪。下 &lt;玖六&gt;127. &nbsp; 2011-08-10 &nbsp; 雨夏事纪。上 &lt;玖五&gt;六月126. &nbsp; 2011-06-23 &nbsp; 十年一梦。&lt;玖三&gt;七月125. &nbsp; 2011-07-11 &nbsp; 2011年夏。&lt;玖四&gt;二月124. &nbsp; 2011-02-12 &nbsp; 弘毅。[长篇] &lt;玖二&gt;123. &nbsp; 2011-02-03 &nbsp; 你好, 兔年！&lt;玖一&gt;一月122. &nbsp; 2011-01-09 &nbsp; 目录 续121. &nbsp; 2011-01-01 &nbsp; 新。&lt;九十&gt;二〇一〇十二月120. &nbsp; 2010-12-07 &nbsp; Road. &lt;捌九&gt;十一月119. &nbsp; 2010-11-13 &nbsp; 深秋。&lt;捌八&gt;十月118. &nbsp; 2010-10-24 &nbsp; 校运 - 执信的狂欢节。&lt;捌七&gt;117. &nbsp; 2010-10-24 &nbsp; [视频资源][下]执信校运。&lt;捌六&gt;116. &nbsp; 2010-10-24 &nbsp; [视频资源][上]执信校运。&lt;捌五&gt;九月115. &nbsp; 2010-09-22 &nbsp; 施。&lt;捌四&gt;114. &nbsp; 2010-09-12 &nbsp; 轮回。&lt;捌三&gt;八月113. &nbsp; 2010-08-31 &nbsp; 夏末。&lt;捌二&gt;112. &nbsp; 2010-08-15 &nbsp; Dull. 高中生活 &lt;捌一&gt;111. &nbsp; 2010-08-04 &nbsp; 盛夏。高中生活 &lt;八十&gt;七月110. &nbsp; 2010-07-11 &nbsp; 仲夏. 高中生活 &lt;柒九&gt;109. &nbsp; 2010-07-04 &nbsp; 物语. 高中生活 &lt;柒八&gt;六月108. &nbsp; 2010-06-20 &nbsp; Canon. 高中生活&lt;柒七&gt;107. &nbsp; 2010-06-09 &nbsp; 梦. 高中生活 &lt;柒六&gt;五月106. &nbsp; 2010-05-16 &nbsp; 2010 执信 GoldVoice 大赛. 高中生活 &lt;柒五&gt;105. &nbsp; 2010-05-12 &nbsp; 宁夏. 高中生活 &lt;柒四&gt;104. &nbsp; 2010-05-08 &nbsp; 狂热的夏——生日会&amp;毽赛. 高中生活 &lt;柒三&gt;103. &nbsp; 2010-05-03 &nbsp; 鼎湖山之旅. 高中生活 &lt;柒二&gt;四月102. &nbsp; 2010-04-24 &nbsp; 时雨. 高中生活 &lt;柒一&gt;101. &nbsp; 2010-04-10 &nbsp; 毒. 高中生活 &lt;七十&gt;100. &nbsp; 2010-04-04 &nbsp; 执春, 一模, 球赛. 高中生活 &lt;陆九&gt;三月99. &nbsp; 2010-03-20 &nbsp; 十八. 高中生活 &lt;陆八&gt;98. &nbsp; 2010-03-14 &nbsp; 执信杯篮球赛 &amp; 社团 OpenDay. 高中生活 &lt;陆七&gt;97. &nbsp; 2010-03-07 &nbsp; 白日梦. 高中生活 &lt;陆六&gt;二月96. &nbsp; 2010-02-18 &nbsp; 执念. 高中生活 &lt;陆五&gt;95. &nbsp; 2010-02-14 &nbsp; 春. 高中生活 &lt;陆四&gt;94. &nbsp; 2010-02-09 &nbsp; 悦游. 高中生活 &lt;陆三&gt;93. &nbsp; 2010-02-03 &nbsp; 执信 2010 科技节 &amp; 解慰 . 高中生活 &lt;陆二&gt;一月92. &nbsp; 2010-01-27 &nbsp; 释放. 高中生活 &lt;陆一&gt;91. &nbsp; 2010-01-10 &nbsp; 任时光… 高中生活 &lt;六十&gt;90. &nbsp; 2010-01-02 &nbsp; 元旦 15 班班会 &amp; 4 班班聚. 高中生活 &lt;伍九&gt;89. &nbsp; 2010-01-02 &nbsp; 执信09跳蚤市场. 高中生活 &lt;伍八&gt;二〇〇九十二月88. &nbsp; 2009-12-27 &nbsp; 简. 高中生活 &lt;伍七&gt;87. &nbsp; 2009-12-20 &nbsp; 蹉跎. 高中生活 &lt;伍六&gt;86. &nbsp; 2009-12-13 &nbsp; 执信 09 SYL 晚会！Dec.11 [下] 高中生活 &lt;伍五&gt;85. &nbsp; 2009-12-12 &nbsp; 乐游园-秋游. Dec.11 [上] 高中生活 &lt;伍四&gt;84. &nbsp; 2009-12-05 &nbsp; 决变. 高中生活 &lt;伍三&gt;十一月83. &nbsp; 2009-11-29 &nbsp; 球赛惜败, 09 DJ &amp; 41 校庆. 高中生活 &lt;伍二&gt;82. &nbsp; 2009-11-22 &nbsp; 匆匆 &amp; 执信杯足球赛. 高中生活 &lt;伍一&gt;81. &nbsp; 2009-11-21 &nbsp; 非一般 09 执信校运！[下] 高中生活 &lt;五十&gt;80. &nbsp; 2009-11-21 &nbsp; 非一般 09 执信校运！[中] 游行视频集 高中生活 &lt;肆九&gt;79. &nbsp; 2009-11-16 &nbsp; 非一般 09 执信校运！[上] 高中生活 &lt;肆八&gt;78. &nbsp; 2009-11-07 &nbsp; 澄天. 高中生活 &lt;肆七&gt;十月77. &nbsp; 2009-10-31 &nbsp; 无奈. 高中生活 &lt;肆六&gt;76. &nbsp; 2009-10-24 &nbsp; 锦瑟年华. 高中生活 &lt;肆五&gt;75. &nbsp; 2009-10-17 &nbsp; Secret. 高中生活 &lt;肆四&gt;74. &nbsp; 2009-10-01 &nbsp; 微凉初秋. 高中生活 &lt;肆三&gt;九月73. &nbsp; 2009-09-26 &nbsp; 目录.72. &nbsp; 2009-09-19 &nbsp; 闲情几许. 高中生活 &lt;肆二&gt;71. &nbsp; 2009-09-12 &nbsp; 9.11 相聚别离 &amp; 班会. 高中生活 &lt;肆一&gt;70. &nbsp; 2009-09-05 &nbsp; 新的故事 序幕 高中生活 &lt;四十&gt;八月69. &nbsp; 2009-08-28 &nbsp; 期待. 高中生活 &lt;叁九&gt;68. &nbsp; 2009-08-08 &nbsp; 一年. 高中生活 &lt;叁八&gt;67. &nbsp; 2009-08-01 &nbsp; 究极 拟人化七月66. &nbsp; 2009-07-28 &nbsp; 小時候…… 2005 届 6 年 1 班.65. &nbsp; 2009-07-24 &nbsp; 就这样，高一结束了。高中生活 &lt;叁七&gt;64. &nbsp; 2009-07-18 &nbsp; 华灯. 分班之旅 [下] 高中生活 &lt;叁六&gt;63. &nbsp; 2009-07-17 &nbsp; 苍穹. 分班之旅 [上] 高中生活 &lt;叁五&gt;62. &nbsp; 2009-07-10 &nbsp; 再见 – 献给高一四. 高中生活 &lt;叁四&gt;61. &nbsp; 2009-07-03 &nbsp; 没有学会的.六月60. &nbsp; 2009-06-21 &nbsp; 阅游志59. &nbsp; 2009-06-13 &nbsp; 『文』我快被逼疯了58. &nbsp; 2009-06-12 &nbsp; 对生活有借鉴意义的心理现象57. &nbsp; 2009-06-07 &nbsp; 纯真的传说 &amp; 14 人的 KTV 高中生活 &lt;叁三&gt;五月56. &nbsp; 2009-05-30 &nbsp; 成长的足迹.（不再续篇）55. &nbsp; 2009-05-29 &nbsp; 快乐，理想。54. &nbsp; 2009-05-24 &nbsp; [囧] 生存在执信..53. &nbsp; 2009-05-23 &nbsp; 执信杯篮球赛 [4] 最终战！高中生活 &lt;叁二&gt;52. &nbsp; 2009-05-16 &nbsp; 执信杯篮球赛 [3] 半决赛！高中生活 &lt;叁一&gt;51. &nbsp; 2009-05-16 &nbsp; 学农拾遗. 高中生活 &lt;三十&gt;50. &nbsp; 2009-05-09 &nbsp; 5.3-5.8 学农. 高中生活 &lt;廿九&gt;49. &nbsp; 2009-05-02 &nbsp; 2009 执信 GoldVoice 大赛视频 &lt;下&gt;48. &nbsp; 2009-05-01 &nbsp; 2009 执信 GoldVoice 大赛视频 &lt;上&gt;四月47. &nbsp; 2009-04-25 &nbsp; 阅薇志–昼域. &amp; GV 的遗憾. 高中生活 &lt;廿八&gt;46. &nbsp; 2009-04-19 &nbsp; 第一次课外班集体活动. 高中生活 &lt;廿七&gt;45. &nbsp; 2009-04-11 &nbsp; 叱咤舞会. 高中生活 &lt;廿六&gt;44. &nbsp; 2009-04-14 &nbsp; 再见，张群起舞 &amp; 期中考. 高中生活 &lt;廿五&gt;三月43. &nbsp; 2009-03-28 &nbsp; 执信之春-决赛. 高中生活 &lt;廿四&gt;42. &nbsp; 2009-03-27 &nbsp; 执信杯篮球赛 [2] 险胜！高中生活 &lt;廿三&gt;41. &nbsp; 2009-03-21 &nbsp; 执信之春-初赛. 高中生活 &lt;廿二&gt;40. &nbsp; 2009-03-16 &nbsp; 难忘生日这一天. 高中生活 &lt;廿一&gt;39. &nbsp; 2009-03-14 &nbsp; OpenDay 社团开放日，高中生活 &lt;二十&gt;38. &nbsp; 2009-03-07 &nbsp; 执信杯篮球赛 [1]！初秀 高中生活 &lt;十九&gt;二月37. &nbsp; 2009-02-28 &nbsp; &lt;精品&gt; 2008 执信 GoldVoice 映像放出!!36. &nbsp; 2009-02-21 &nbsp; 新·名人传35. &nbsp; 2009-02-21 &nbsp; 新·名人传 234. &nbsp; 2009-02-14 &nbsp; 我们老师的“简介”. 高中生活 &lt;十八&gt;33. &nbsp; 2009-02-07 &nbsp; 新的学期，新的希望! GL.HF! 高中生活 &lt;十七&gt;一月32. &nbsp; 2009-01-31 &nbsp; 博客乱谈31. &nbsp; 2009-01-26 &nbsp; 《美好的青春舞曲》等 最棒的春晚节目啊！ to rm30. &nbsp; 2009-01-25 &nbsp; 寒冷的新一年，难忘的又一年. 高中生活 &lt;十六&gt;29. &nbsp; 2009-01-20 &nbsp; 执信 DJ、SYL 晚会精彩视频&amp;杂想 高中生活 &lt;十五&gt;28. &nbsp; 2009-01-17 &nbsp; 我最难忘的 GoldVoice 初赛 高中生活 &lt;十四&gt;27. &nbsp; 2009-01-15 &nbsp; 科技节 高中生活 &lt;十三&gt;26. &nbsp; 2009-01-10 &nbsp; 学期“总结” 高中生活 &lt;十二&gt;二〇〇八十二月25. &nbsp; 2008-12-31 &nbsp; 执信跳蚤市场 高中生活 &lt;十一&gt;24. &nbsp; 2008-12-20 &nbsp; 残余的相片….初中回忆之二23. &nbsp; 2008-12-19 &nbsp; 非常有趣的视频（三）（超强推荐） to rm22. &nbsp; 2008-12-13 &nbsp; SYL 晚会与某人生日 高中生活 &lt;十&gt;21. &nbsp; 2008-12-13 &nbsp; 执信秋游-闲适 高中生活 &lt;九&gt;20. &nbsp; 2008-12-05 &nbsp; 41 中校庆-追念 高中生活 &lt;八&gt;19. &nbsp; 2008-12-03 &nbsp; 一问，一答十一月18. &nbsp; 2008-11-29 &nbsp; [转] 4班好样的!! 执信羽毛球赛 [修改版]. 高中生活 &lt;七&gt;17. &nbsp; 2008-11-24 &nbsp; BTSuperMan…执信超强人16. &nbsp; 2008-11-22 &nbsp; DJ 大赛——精彩啊！高中生活 &lt;六&gt;15. &nbsp; 2008-11-16 &nbsp; 高中生活 &lt;五&gt; 附同学搞笑视频14. &nbsp; 2008-11-14 &nbsp; 很强大的雷人视频集锦（二）13. &nbsp; 2008-11-05 &nbsp; 校运劲舞！劲武! [校运绝对精彩]. 高中生活 &lt;四&gt;十月12. &nbsp; 2008-10-31 &nbsp; Trying. 高中生活 &lt;三&gt;11. &nbsp; 2008-10-27 &nbsp; 我曾经的冲动——学舞。学yoyo.10. &nbsp; 2008-10-25 &nbsp; 08.10.24-25 执信校运会9. &nbsp; 2008-10-19 &nbsp; 很强大的雷人视频集锦（一）8. &nbsp; 2008-10-18 &nbsp; 爆笑漫画——本人与朋友精选7. &nbsp; 2008-10-17 &nbsp; 老师语录与本人杂录 高中生活 &lt;二&gt;6. &nbsp; 2008-10-15 &nbsp; BT的教育-英语的问题——韩寒5. &nbsp; 2008-10-07 &nbsp; BT的教育-数学的问题——韩寒九月4. &nbsp; 2008-09-28 &nbsp; 囧与乐 高中生活 &lt;一&gt;3. &nbsp; 2008-09-28 &nbsp; 搞笑跆拳道..中学回忆之一…2. &nbsp; 2008-09-20 &nbsp; BT的教育-应该废除学生作文!!——韩寒1. &nbsp; 2008-09-13 &nbsp; 我家的宠物们！？]]></content>
      <categories>
        <category>think</category>
      </categories>
      <tags>
        <tag>think</tag>
      </tags>
  </entry>
</search>